<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="向上攀爬之路不是比站在顶峰更让人热血澎湃吗">
<meta name="theme-color" content="#000">
<title>个人笔记</title>
<link rel="shortcut icon" href="/favicon.ico?v=1646133821936">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>个人笔记</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item nav-item-active">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
      <div
        class="section-layout gemini ">
        <div class="section-layout-wrapper">
          <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">我是谁</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>笔记</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">38</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">0</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
            <div class="section-box gemini box-shadow-wrapper">
              <section class="friends-section bg-color slide-down-in">
                <div class="firends-box" align="center">
                  <h1 class="firends-title" itemprop="name headline">
                    友链
                  </h1>
                  
                    
                        
                </div>
                <hr>
                <div style="text-align:center">
                  <span class="with-love">
                    <i class="fa fa-heart"></i>
                  </span>
                  <span class="language" data-lan="leave-message">如需添加友链,可以在关于中找到我的联系方式告知我</span>
                  <span class="with-love">
                    <i class="fa fa-heart"></i>
                  </span>
                </div>
                <hr>
                <div class="friends-note">
                  <p><strong class="language" data-lan="format">友链格式：</strong></p>
                  <ul>
                    <li><span class="language" data-lan="site-name">网站名称：</span>个人笔记</li>
                    <li><span class="language" data-lan="site-link">网站地址：</span><a href="https://bingery111.github.io" data-pjax-state="">https://bingery111.github.io</a></li>
                    <li><span class="language" data-lan="site-desc">网站描述：</span>向上攀爬之路不是比站在顶峰更让人热血澎湃吗</li>
                    <li><span class="language" data-lan="site-img">网站头像：</span>
                      <a href="https://bingery111.github.io/images/avatar.png">https://bingery111.github.io/images/avatar.png</a>
                    </li>
                  </ul>
                </div>
                
  

              </section>
            </div>
        </div>
      </div>
      <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/c/"" data-c="
          &lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;br&gt;
[!TOC]&lt;/p&gt;
&lt;h3 id=&#34;vscode&#34;&gt;vscode&lt;/h3&gt;
&lt;p&gt;shift+alt+f 文档格式化&lt;/p&gt;
&lt;p&gt;ctrl+k ctrl+f 选择快注释&lt;/p&gt;
&lt;h3 id=&#34;1&#34;&gt;1&lt;/h3&gt;
&lt;p&gt;endl -- end line（结束这一行）&lt;/p&gt;
&lt;h3 id=&#34;2-c语句&#34;&gt;2、C++语句&lt;/h3&gt;
">C++</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/python3-bi-ji/"" data-c="
          &lt;h3 id=&#34;一-查看python版本&#34;&gt;一、查看python版本&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;python --version
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;二-python3基本语法&#34;&gt;二、python3基本语法&lt;/h3&gt;
&lt;p&gt;1、Python中单行注释以 # 开头&lt;br&gt;
2、行与缩进（使用缩进来表示代码块）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if True:
    print (&amp;quot;True&amp;quot;)
else:
    print (&amp;quot;False&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、多行语句&lt;br&gt;
使用反斜杠 \ 来实现多行语句&lt;/p&gt;
">python3笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/xshell-bao-cuo-qing-kuang/"" data-c="
          &lt;p&gt;1、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WARNING! The remote SSH server rejected X11 forwarding request.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决办法：（1）编辑文件：/etc/ssh/sshd_config，设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;X11Forwarding yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）配置Xshell 6连接属性，如下图，取消勾取即可&lt;br&gt;
SSH-隧道-x11转移去掉勾选&lt;/p&gt;
">xshell报错情况</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/ji-yu-ecs-he-nas-da-jian-ge-ren-wang-pan/"" data-c="
          &lt;h3 id=&#34;目标&#34;&gt;目标&lt;/h3&gt;
&lt;p&gt;1、NAS文件存储系统基本知识&lt;br&gt;
2、 Apache + PHP语言环境的安装和部署&lt;br&gt;
3 、挂载NAS文件存储系统&lt;br&gt;
4、 Linux 系统基础命令&lt;/p&gt;
&lt;h3 id=&#34;nas&#34;&gt;NAS&lt;/h3&gt;
&lt;p&gt;文件存储NAS：提供标准的文件访问协议，用户无需对现有应用做任何修改，即可使用具备无限容量及性能扩展、单一命名空间、多共享、高可靠和高可用等特性的分布式文件系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br&gt;
1、标准文件协议，既支持NFS也支持SMB&lt;br&gt;
2、共享、无限扩容、高可靠&lt;br&gt;
3、良好的性能指标，支持横向拓展&lt;/p&gt;
&lt;h3 id=&#34;应用&#34;&gt;应用&lt;/h3&gt;
&lt;p&gt;1、启动创建好的ECS&lt;br&gt;
2、安装OwnCloud&lt;br&gt;
OwnCloud是一款开源的云存储软件，基于PHP的自建网盘。基本上是私人使用，没有用户注册功能，但是有用户添加功能，你可以无限制地添加用户，OwnCloud支持多个平台（windows，MAC，Android，IOS，Linux）。&lt;br&gt;
3、打开终端，添加软件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /etc/yum.repos.d/
wget --no-check-certificate https://download.opensuse.org/repositories/isv:ownCloud:server:10/CentOS_7/isv:ownCloud:server:10.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4、进入root目录，安装OwnCloud-files&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /root/
yum -y install https://labfileapp.oss-cn-hangzhou.aliyuncs.com/owncloud-complete-files-10.5.0-3.1.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5、查看安装是否成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ll /var/www/html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、安装Apache服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行以下命令安装Apache服务&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;yum install httpd -y
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;执行以下命令启动Apache服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;systemctl start httpd.service
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;浏览器输入ECS弹性公网ip，即可&lt;/li&gt;
&lt;li&gt;添加OwnCloud配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;vim /etc/httpd/conf/httpd.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;Directory&gt;内容后添加以下内容&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# owncloud config
Alias /owncloud &amp;quot;/var/www/html/owncloud/&amp;quot;
&amp;lt;Directory /var/www/html/owncloud/&amp;gt;
    Options +FollowSymlinks
    AllowOverride All
    &amp;lt;IfModule mod_dav.c&amp;gt;
        Dav off
    &amp;lt;/IfModule&amp;gt;
    SetEnv HOME /var/www/html/owncloud
    SetEnv HTTP_HOME /var/www/html/owncloud
&amp;lt;/Directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;7、安装、配置PHP&lt;br&gt;
OwnCloud是基于PHP开发的云存储软件，需要PHP运行环境&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行以下命令手动更新rpm源&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;rpm -Uvh https://labfileapp.oss-cn-hangzhou.aliyuncs.com/epel-release-latest-7.noarch.rpm 
rpm -Uvh https://labfileapp.oss-cn-hangzhou.aliyuncs.com/webtatic-release.rpm 
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;执行以下命令安装PHP 7.2版本&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;yum -y install php72w
yum -y install php72w-cli php72w-common php72w-devel php72w-mysql php72w-xml php72w-odbc php72w-gd php72w-intl php72w-mbstring
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;将PHP配置到Apache中&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;find / -name php.ini
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;执行以下命令打开httpd.conf文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;vi /etc/httpd/conf/httpd.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在文件最后添加上&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;PHPIniDir /etc/php.ini
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;重启Apache服务&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;systemctl restart httpd.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;8、配置OwnCloud&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;登录OwnCloud创建个人网盘了&lt;/li&gt;
&lt;li&gt;打开用户本地浏览器，输入ECS弹性IP/owncloud&lt;/li&gt;
&lt;li&gt;自定义输入管理员账号和密码，然后单击存储&amp;amp;数据库，选择SQLite，最后单击安装完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;9、挂载NAS服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、完成OwnCloud初始化之后就可以将NAS存储包挂载到您的网盘服务器上&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;2、打开无痕浏览器页面，复制 云产品资源 列表中 「一键复制子账号登陆链接」 粘贴到浏览器，输入 云产品资源列表 中的子账号密码，即可登录当前子账号。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;3、输入云产品资源提供的子用户名和密码，登录阿里云控制台。在产品列表页，搜索NAS，然后单击文件存储NAS&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;4、在左侧导航栏中，单击文件系统列表。在页面上方，选择资源提供的地域 ，例如：华东2 上海。在文件系统列表页面，可以根据云产品资源列表中提供的nasFileSystemId找到您的NAS资源，然后单击文件系统 ID，进入文件系统详情页&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;5、选择挂载使用，然后单击添加挂载点，专有网络选择cn-shanghai-vpc-csn、交换机选择cn-shanghai-b-csn和权限组选择VPC默认权限组，最后单击确定&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;6、切换至命令行终端页面，执行以下命令安装cifs-utils工具包&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo yum -y install cifs-utils
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;7、执行以下命令，查看apache的uid和gid&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cat /etc/passwd|grep apache
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;8、切换至无痕浏览器，在文件存储NAS控制台页签，单击通过命令行挂载到ECS，挂载文件系统选择Linux，在Linux ECS上安装CIFS客户端选择Centos，查看挂载SMB文件系统命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;9、复制挂载SMB文件系统的命令，并且您需要将命令中/mnt改为/var/www/html/owncloud/data/admin/files，uid和gid值改为apache的uid和gid&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;10、切换至命令行终端页面，执行上一步骤的修改后的挂载命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;11、执行以下命令查看挂载是否成功&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;df -h | grep aliyun
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：NAS挂载成功后，OwnCloud网盘中的默认目录和文件不可读写，请在网盘中新建目录上传&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;12、可以在OwnCloud网盘中，新建文件夹并上传文件，并且可以在/var/www/html/owncloud/data/admin/files目录下查找到您上传的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;配置相应的shell脚本&#34;&gt;配置相应的shell脚本&lt;/h3&gt;
&lt;p&gt;待后续研究&lt;/p&gt;
&lt;h3 id=&#34;一键部署&#34;&gt;一键部署&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用限制：&lt;/strong&gt;&lt;br&gt;
1、仅支持ECS Linux操作系统。其中，CoreOS、FreeBSD和Fedora-CoreOS版本不支持使用控制台一键挂载功能。&lt;/p&gt;
&lt;h3 id=&#34;心得&#34;&gt;心得：&lt;/h3&gt;
&lt;p&gt;1、配置还是比较麻烦的，如果是几十或者上百服务器，最好的做法是利用shell脚本一键配置。&lt;br&gt;
2、服务器部分还是只会各个部分的管理操作不会进行对应用户的授权，将来需要打磨的地方&lt;/p&gt;
">基于ECS和NAS搭建个人网盘</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/ecs-pei-zhi/"" data-c="
          &lt;h3 id=&#34;1-通过终端远程访问主机&#34;&gt;1、通过终端远程访问主机&lt;/h3&gt;
&lt;p&gt;使用安全远程访问协议 **SSH **来访问您的主机，在主机上开启了 SSHD 的远程服务&lt;br&gt;
主机开放了相应的端口，通常情况端口号是 22。&lt;/p&gt;
&lt;p&gt;部分Linux系统中，SSHD服务会禁用 root 用户远程登录, 登录时可能报用户名或者密码错误。&lt;/p&gt;
&lt;p&gt;使用root进行远程登录, 需要通过其他方式(如vnc)连接到服务器，并修改配置文件:/etc/ssh/sshd_config,将&lt;br&gt;
PermitRootLogin no&lt;br&gt;
修改为&lt;br&gt;
PermitRootLogin yes&lt;br&gt;
重启 SSHD 服务&lt;br&gt;
sudo service sshd restart&lt;br&gt;
再尝试使用Workbench登录远程主机&lt;/p&gt;
&lt;h3 id=&#34;vnctelnetssh区别&#34;&gt;VNC/Telnet/SSH区别&lt;/h3&gt;
&lt;p&gt;VNC (Virtual Network Computing)是虚拟网络计算机的缩写，远程控制工具。Linux 中，VNC 包括以下四个命令：vncserver，vncviewer，vncpasswd，和 vncconnect。大多数情况下只需要两个命令：vncserver 和 vncviewer&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VNC原理&lt;/strong&gt;&lt;br&gt;
VNC系统由客户端，服务端和一个协议组成。VNC的服务端目的是分享其所运行机器的屏幕， 服务端被动的允许客户端控制它。 VNC客户端（或Viewer） 观察控制服务端，与服务端交互。 VNC 协议 Protocol (RFB)是一个简单的协议，传送服务端的原始图像到客户端（一个X,Y 位置上的正方形的点阵数据）， 客户端传送事件消息到服务端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Telnet&lt;/strong&gt;&lt;br&gt;
Telnet是进行远程登录的标准协议，它是当今Internet上应用最广泛的协议之一。它把用户正在使用的终端或计算机变成网络某一远程主机的仿真终端，使得用户可以方便地使用远程主机上的软、硬件资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SSH&lt;/strong&gt;&lt;br&gt;
Telnet协议在带来便利性的同时，也带来了许多安全问题，最突出的就是Telnet协议使用明文的方式传送所有的数据（包括账号和口令），数据在传输过程中很容易被入侵者窃听或篡改所以建议使用更安全的其它的服务&lt;br&gt;
SSH是目前通常使用的远程管理协议，它是一个在应用程序中提供安全通信的协议，通过SS可以安全地访问服务器，因为SSH基于成熟的公钥加密体系，把所有传输的数据进行加密，保证数据在传输时不被恶意破坏、漏露和篡改。&lt;/p&gt;
&lt;h3 id=&#34;生成ssh公钥&#34;&gt;生成SSH公钥&lt;/h3&gt;
&lt;p&gt;默认情况下，用户的 SSH 密钥存储在其 ~/.ssh 目录下。 进入该目录并列出其中内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -o
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：.ssh在服务器中默认存在，需要使用ls -a选项。&lt;br&gt;
这条命令会产生两个隐藏文件：.ssh  .ssh.pub，打开.ssh.pub，里面既是ssh key，将其输入到github中即可git clone。&lt;/p&gt;
&lt;h3 id=&#34;git配置&#34;&gt;git配置&lt;/h3&gt;
&lt;p&gt;1、检查是否安装过git（不是用man）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git --version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若出现以上版本号，则代表已经安装了git，不需要再次安装了，否则就安装&lt;/p&gt;
&lt;h3 id=&#34;xshell远程连接&#34;&gt;xshell远程连接&lt;/h3&gt;
&lt;p&gt;1、在控制台设置密码&lt;br&gt;
2、打开xshell，新建会话，输入ip地址，和端口（默认为22），之后输入用户名和密码&lt;br&gt;
&lt;img src=&#34;https://bingery111.github.io/post-images/1645151419052.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3、绑定域名，进入域名控制台，添加A类记录即可。&lt;br&gt;
4、验证：打开cmd/terminal，ping网址，若是服务器网址即可，注：与网页托管无关&lt;/p&gt;
&lt;h3 id=&#34;xftp连接远程服务器&#34;&gt;xftp连接远程服务器&lt;/h3&gt;
&lt;p&gt;只需要添加公网ip以及用户密码即可&lt;/p&gt;
">ECS配置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/mu-biao-shou-du-linux-xi-tong-dai-ma/"" data-c="
          &lt;p&gt;时间：终身&lt;/p&gt;
">(目标)熟读linux系统代码</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/jia-ru-kai-yuan-she-qu-cong-she-qu-zhong-cheng-chang/"" data-c="
          &lt;p&gt;开源软件有许多好处，总结起来，最重要的有三点。&lt;br&gt;
　　首先，开源软件对用户的权利保护得更充分一些。举例来说，如果有一天微软公司不复存在了，那么 Windows、Office 这些本来由微软公司负责维护的软件很可能由于没人维护下去而被淘汰，但开源软件却不存在这样的问题，开源软件不会因某个人不存在而变得停滞不前。用户曾经花费巨资购买的 386、486 微机，现在却只能作为一堆废品来处理，原因就在于缺乏性能优异的应用软件来持续支持，但功能强大的自由软件却可以在这些 386、486 微机上跑得很好。&lt;br&gt;
　　其次，开源软件由于发布很广，开源软件的问题更容易暴露出来，这使得当这些问题解决以后开源软件就变得更加完美。&lt;br&gt;
　　最后，开源软件对用户个性化的需求更容易满足。由于软件过多地引进了工程化管理，使得软件的标准化程度越来越高。这固然可以增加软件的开发效率，但却使得人们都需要按照一个模式去操作软件。正常人使用着很方便的软件，左撇子使起来就很别扭。随着手机、PDA 等新产品的出现，这种个性化的需求会表现得更加强烈。开源软件由于源代码是公开的，所以这些个性化需求更容易得到满足。软件不能单纯用工程表现，在这个问题上，开源软件的开发方式给了人们很深的启示。&lt;br&gt;
　　共创软件联盟的刘澎则指出，开源文化是人类几千年的智慧结晶，是一种必然的历史发展趋势，这种发展趋势是谁也阻挡不了的。今天，已不可能有人会否认互联网所蕴含的价值，但人们有没有注意过互联网发展初期是一个什么样子呢？几十年前的互联网只是具备了一些核心的协议，应用价值也并没有显现出来，但这根本不会妨碍互联网发展成今天这个样子。互联网在发展初期实质上就是一种开源的形式，今天的开源软件与此非常类似。发展趋势本身就具有一种力量，Windows 之所以应用得这么广，在于它符合现代操作系统的标准。现代操作系统的标准就是一种趋势，Linux 也符合这些标准，这使得 Linux 也将注定成为了一种优秀的操作系统。&lt;br&gt;
　　刘澎同时认为：“目前开源软件的发展进入到了一个低谷的时期，这其实是开源软件发展的必经阶段。因为开源软件的商业推广模式在创立初期就出现了问题，所以才有今天的发展低谷，可见这个低谷并没有超越于发展趋势之外。我们在二十世纪九十年代中期就采用开源技术解决了路由技术，这个项目在商业上也获得了巨大的成功。事实上，国内有许多开源项目，如 Hopen 等，都做得非常成功。因此，面对暂时的困难，就认为中国无开源，认为开源没有希望，是一种敷浅的表现。&lt;br&gt;
　　中国工程院院士倪光南指出：“从产业层面看，以 Linux 为代表的开源软件增强了我国软件业讨价还价的能力，并且使得软件的市场空间增大了。我们必须看到，国产 CPU 必须有 Linux 支持，否则就会因使用范围太窄而不能投入实际应用。”&lt;br&gt;
开源的本质&lt;br&gt;
　　在许多人眼中，开源就意味着只有付出而没有任何回报，然而，开源的本意却是“ When programmers can read, redistribute, and modify the source code for a piece of software, the software evolves ”（只要程序员对软件的某一部分实现阅读、重新分发和修改代码，即可称作开源）。既使是要求极为严格的GPL协议，也仅要求使用GPL源码这个部分开源，而 BSD 协议则仅仅要求在 End User License 中，保留原来的协议就可以了。&lt;br&gt;
　　由此看来，开源软件同样可以做到“别人怎么赚钱，我们也怎么赚钱”，开源与商业利益并是完全对立的。在国内保障体系还不完善的情况下，国内的软件公司和程序员完全可以利用开源软件解决吃饭和生存的问题。而开源软件也并不只包含 Linux 这样的系统软件，目前热门的 ERP、CRM 乃至知识管理、商业智能同样可以基于开源软件开发。&lt;br&gt;
　　对程序员个体而言，加入开源社区也并非一无所获。国外许多程序玩家通过社区的锻炼获益匪浅，功成名就者也不乏其人。国内的软件工程技术人员参与过大型开发项目的少而又少，中软 COSIX 项目尽管归于失败，但通过这个项目培养出来的参与过大型项目开发的人员已被几大外资软件公司瓜分殆尽。而现实的问题却是，一方面程序人员抱怨没有项目可供练手，另一方面却又不愿加入开源社区得到锻炼。无论国内的程序员有着什么样的想法，开源社区却绝对不失为获得大型开发项目经验和扬名立万的良好场所。&lt;br&gt;
　　对软件公司来说，开源还是增加软件需求的好方法。软件发展到今天，由于过多地引入了工程方法，使得软件越来越趋于标准化。对个人用户而言，同样的软件，用惯右手的人使用起来得心应手，然而左撇子用起来却怎么使怎么别扭。而对企业用户而言，管理软件的使用必然伴随着管理方式的变化，然而，并不是说管理软件带来的总是适合用户的管理变革，这时用户就会提出系统必须要和管理实现互动的要求，显然，开源软件处理这类问题更为方便。&lt;br&gt;
　　与国内软件公司远离开源的情况相反, Sun 公司把 Solaries 操作系统的源代码毫无保留地公开给了业界,微软也已宣布将把投入巨资开发的 Windows CE 的 70% 的源代码以 5 美元的象征性价格出让给业界。微软公司和 Sun 公司当然明白这样做带来的好处，源代码开放以后，业界更容易形成基于某类产品的技术标准，这将为技术的拥有者带来更大的市场。而对下游的服务厂商而言，可以更容易地为用户提供更好的服务，表面看来微软公司和 Sun 公司在服务市场损失了一部分收入，但这部分损失会在产品市场得到更大的补偿。&lt;br&gt;
　　从根本上讲，开源与非开源的开发只是开发方法上的不同，采用开源方式开发出的软件产品，也可以采用不同的商业模式来实现其价值。开源不是怪物，开源也不会让某些公司保不住饭碗，相反，开源可以培养出更多高水平的人才，开源软件能应用于核心应用，也能创造出更广阔的需求市场，从而改善软件产业环境。&lt;br&gt;
　　来自CSDN网站关于开源的调查表明，抱有“开放源代码会使公司失去收入来源”和“加入开源社区意味着只有付出没有回报”想法的人，只占到总调查人数的十分之一；明确表明无条件不加入开源社区的调查者不足 3%；反进来，认为开源拥有良好商业前景的调查者占到了十分之七，认为能从开源中取得回报的调查者更是占到了十分之八。&lt;br&gt;
然而，日渐成熟的开源技术与惨淡的生态环境还是形成了强烈的对比，开发人员对于开源的高涨热情与开源社区的惨淡同样形成了强烈的对比，被赋予了太多使命的开源让我们感受到了从未有过的沉重。面对着这些强烈的反差，我们不得不开始思考一个问题：中国开源路在何方？&lt;br&gt;
中国开源路在何方&lt;br&gt;
　　谈起中国开源的发展道路，这绝对是一个仁者见仁，智者见智的问题。关于这个问题的答案，涉及到了心态、人才、政府支持、产业等方方面面。应该说，经过了几年的普及，开源在国内确实已经拥有一批拥趸，政府在这方面也下了不少力气，而现在所需的，是要把这些力量汇聚成一股合力。为此，发展开源首先要保持良好的心态，其次是要选择正确的方法，最后是要实现开源成果向产业的顺利转化，当然，政府的支持同样是不可缺少的。总之，开源软件的推动工作是一项系统工程，其中需要用到太多公众的力量和智者的思想。&lt;br&gt;
开源的心态&lt;br&gt;
　　对许多事情而言，态度往往决定一切，发展开源无疑就属于这类事情。从事过开源实践的人对开源界人士有一个共识，那就是开源界人士的浮躁。关于这一点，无论是早期创办 Turbolinux 公司的 Iris Miller，还是把开源软件引入国内的宫敏，再到开源的实践者刘澎都有同感。&lt;br&gt;
　　开源软件界的人很浮躁，往往是没有听别人把话讲完，就开始了指责。这个时候，如果他们能够静下心来再听别人讲五分钟，结果常常是五分钟过去后，这种指责已经没有办法进行下去了，因为他们误解了别人的意思，别人的意见是正确的。事实上，浮躁也绝不仅是国内开源者的专利，国外开源者也概莫能外。在 Linux 开发的初期，Linus 曾经删掉了 Linux 系统的一部分程序，这遭到了他身边 20 多个高级开发人员的反对，这些人在网上公开发文，表示 Linus 先生应该征询他们的意见后再决定删除与否。但 Linus 先生马上就回复了这些问题，他表示他读了关于这些程序的所有文档，最后发现这是一个黑洞，而保留这些程序的后果只会延续这些错误。最后大家都对 Linus 先生表示了歉意，承认他们并没有读过全部的文档。&lt;br&gt;
　　浮躁带来的最大后果是容易让人忘乎所以，于是开源就变成了带有感情色彩的开源，Linux 也一度成了让人用着就想哭的 Linux。共创软件联盟的副理事长刘澎认为，发展开源就要以“进化论”的观点来看待开源软件。而以“进化论”论的观点去看待开源软件的发展，就是要从市场需求的角度去考虑开源软件的发展。开源软件变成某种具体的产品后，能否生存下去，要看市场上是否存在需求，如果不存在需求，以指令的方式强制生产，肯定要出问题，这种产品的寿命也不会太长。如果存在需求，即使眼前看起来困难重重，但这种产品还是具备生命力的，一定会有企业克服重重困难让这种产品面市。以“进化论”论的观点去看待开源软件的发展，就不能无视“拔苗助长”现象的发生。&lt;br&gt;
洪峰则认为，开发开源软件要有一种做学问的态度，因为这不是今天投入多少，明天就能产出多少的问题。许多知识是人类几代人积累的结果，天才科学家为解决微积分中无究小的问题，花了 150 年的时间，而解决开根号的问题花了一千年。&lt;br&gt;
　　与浮躁相伴随的，还有一种心态，就是悲观。浮躁使人头脑发热，还会使开源的发展脱离正常的发展轨迹。于是，内心的狂热与无情的现实就特别容易使人悲观。刘澎对此谈了他的看法，当开源运动陷入低谷后，刘澎同样感受到了失落，他觉得别人都亏欠了自己。这时，有个朋友问他：“难道你就没有缺点吗？”为此，刘澎反省了自己，这才领悟出“我们花了国家那么多钱，却做了许多失败的项目，这怎么能算是国家亏待了自己呢”。据此，刘澎认为要想克服困难，去解决问题，就需要保持一种良好的心态。对从事开源软件研发的企业来说，不要总是指责周围的环境，要多从自己身上找缺点。反过来，经历过失败也并不一定是一件坏事，因为失败本身就是一种财富。刘澎坚信，经历过失败以后，我们才耐得住困难，在艰苦的环境中才能生存得下去。刘澎同时认为，面对暂时的困难，就认为中国无开源，认为开源没有希望，是一种敷浅的表现。&lt;br&gt;
开源的瓶颈&lt;br&gt;
　　在 Linus 和 Richard stallman 创立开源软件的初期，他们并没有很好地解决开源软件日后的商业发展模式，这使得开发开源软件的企业在经营上遇到了很大的困难。同时，在现阶段，中国的软件开发人员首先要解决的是吃饭问题，先要生存才谈得上发展，因此，国内开源社区的发展缺乏物质基础。这些使得国内开源的发展不可避免地落入到低潮。基于这个原因，国内开源界的人士普遍认为缺乏良好的商业发展模式，是制约开源运动发展的瓶颈。CSDN 的调查显示：对于程序员加入开源社区的前提这个问题，十分之四的程序员选择了自己有足够经济基础的答案，近十分之三的人选择了“得到赞助或从中得到回报”的答案。也就是说，如果商业模式的问题得到解决，将有近十分之七的程序人员加入到各类开源社区中去，这是一个让人感到振奋的数字。&lt;br&gt;
　　对于这个问题，开源运动的倡导者洪峰给出了这样的解释：开源发展的制约瓶颈在于开源软件厂商没有找到开源项目中存在的稀缺性的东西。传统经济学的出发点是资源的稀缺性，在这种理论指导下，政府采用了强迫性，商业软件强调竞争性，但开源软件中只有合作性，稀缺性仿佛不存在，开源厂商无法找到开源软件所蕴含的稀缺性，厂商开发出的开源软件的价值就得不到体现，开源发展的制约瓶颈也就产生了。但是随着人类的发展，合作性会被越来越多地采用。关于这一点我们可以从政府的法制建设的完善中感受到。&lt;br&gt;
　　以开源教育为例，如果学生自己去学习，那么付出的成本将非常大，许多学生在大学中专门学习了四年计算机知识，还是不会编程；而我如果给出了学习的线路图，为学生提供辅导，学生的学习成本就可以下降很多。经过两年甚至两个月的学习，就可以成为编程高手。我为此付出了大量的时间和精力，因此就可以把学生节省下来的成本的一部分,作为费用收上来。这就是利用了开源的稀缺性。实际上开源软件完全可以利用其他形式实现赢利，我们可以见到尽管数学定理都是公开的，但这并不表明每个人都能够成为数学家。要成为数学家还就需要付出很大的成本，这种成本就是稀缺性的源头。&lt;br&gt;
　　对于个人而言，由于找不到这种稀缺性，同样使得一些人不愿加入开源社区。事实上，在开源社区内，你给别人提供了帮助的同时，也得到了非常多的帮助。国外开源社区内的许多程序员都是利用了开源社区，最终他们提高了知名度，也找到了很好的工作。因此，合作也能对个人产生价值。由于国内只有很少一部分人真正理解开源软件的意义和规则，中国软件企业大多也是在按照专有软件模式在运作，使得国内参与开源社区的人太少。因此，要想打破这个瓶颈，首先就需要把开源软件的含义讲清楚。&lt;br&gt;
　　虽然阻碍开源发展的瓶颈是商业模式问题，但要解决商业模式的问题又会涉及到方方面面的问题，这就使得阻碍开源发展问题变成了许多个，著名的 IT 评论人雁鸣先生把这些因素归结为普及程度低、公共资源稀缺、人才缺乏、开源项目少、厂商和社区缺乏合作、应用难以推广、服务滞后、源码不开放、标准不统一等九个问题。&lt;br&gt;
开源需要什么样的人才&lt;br&gt;
　　阻碍开源社区发展的最直接的原因就是人气的缺乏,而要解决这个问题,除了要让开发人员明了开源的本质外,还需要让他们明白开源的发展究竟需要什么类型的人才。对这个问题，不同的专家给出了不同的意见，但大致分起来，开源人才又可以分为社区内的人才和产业内的人才，这些人才当中既需要使用层面的人才，又需要高端的开发人才。从数量上看，使用层面的人才需求较多，而开发层面的人才需求较少，整体人才数量将呈金字塔状排列。&lt;br&gt;
　　就开源社区内的人才来看，洪峰认为 Perl、Linux 等开源软件的创立者都是精英，而中国开源社区缺乏的恰恰就是这种精英。开源社区需要各种层次的人才，有应用型人才，也有开发型人才，但就目前来说，急需的是高水平的开发人才。要成为高水平的开源开发人才，要迈过一个很高的门槛，而国内迈过了这个门槛的人还太少。怎么叫迈过这个门槛了呢？基本要求是把 Linux 内核研究过一遍，还要能熟练使用各种开发工具。Linux 的内核压缩以后是 20M，打印出来后相当于 60 多本砖头厚的书，国内很少有人能完成这个工作。而这只是一个学习的过程，真正要成为能对开源社区做出贡献的人才，还要具有相当的创造性。&lt;br&gt;
　　洪峰同时认为，中国开源社区的成长空间是惊人的，北京有这么多聪明的学生，他们之所以没有加入到开源社区内，是因为高校没有给出适合学生的清晰的发展路线图。如果我们给出他们清晰的发展路线图，中国的开源社区的发展将是充满光明的。&lt;br&gt;
　　在产业层面，刘澎认为要发展中国的开源软件，在现阶段所需要的不是精英。事实上，也不存在什么精英。所谓精英只不过是比别人早几年认识到了开源软件，如果宫敏先生当年不把开源软件引进到中国，会有另一个人把开源软件引进来。Linus 写 Linux 内核确实付出了艰苦的努力，但并不是说另一个人就不可能完成这件事情。Linux内核并不能直接应用，真正让 Linux 成为一种优秀的操作系统的原因，在于后期大量的工作。&lt;br&gt;
　　刘澎坚持这样一种观点：现在做开源软件的人缺乏一种献身精神。许多开源的倡导者谈开源文化时显得觉悟很高，但到了实际工作中，开发某个具体开源项目时，动辄就要求上万元的月薪。从这个角度看，发展开源软件目前急需的是有执行能力而又有着对开源文化的信仰的人才。此外，国内开源软件还缺乏复合型人才，往往是原来搞研究的人在搞开源软件项目，这些人只能起到“车间主任的角色”，当上级领导下达生产任务后去完成,而不能实现从研发到把技术成果转换成商业成果的全过程。因此，开源软件界同样需要学会了在市场中同最精明的商人打交道的人。&lt;br&gt;
　　刘澎强调，这并不是说开源厂商不需要高层次的人才，相反，我们要抱着一种科学的态度严格挑选人才。举例来说，一个职业篮球队需要一名右前锋，找到一名原来打左前锋的职业选手，问他能否适应右前锋的位置，可能会得到否定的答案。然而找一名业余的多面手，我们可能得到肯定的答案。但他的技术水平不行，最终还是要放弃。因此，我们要找的是高水平的专业人才。&lt;br&gt;
　　软件技术的竞争归根到底还是人的竞争，对此，开源软件也不能例外。从技术层面看，软件的竞争，既不只是金钱的竞争，也不单纯是代码量的竞争，而更多的是创造力的竞争，也正因为如此，人才问题才应该被摆在软件业发展的首位，开源也才因为对于人才培养有着更好的效果而更具魅力。针对开源人才问题，IT 评论人雁鸣先生一针见血地指出，当前发展开源急需两类人：运用开源技术的管理软件的开发者和开源教育的推广者。&lt;br&gt;
政府支持是灵丹妙药吗&lt;br&gt;
　　在影响开源发展的因素中，政府支持一直是一个争议较大的问题。韩国的开源软件从业者已能自毫地说，他们的开源软件发展水平要远远高于中国的开源软件水平，这其中，政府的支持功不可没。另一方面，我们也能见到因政府干预而造成的种种负面作用。于是，政府支持是不是促进开源发展的灵丹妙药这个问题，就成了摆在中国开源发展道路上的一个大问题。&lt;br&gt;
　　就政府支持的问题,洪峰认为在软件这场智力竞争中，首先应该允许多种形式并存；一方面需要有国家队的选手，另一方面也要有个人选手存在。其中,由个人选手组成的开源社区的成长与产、学环境有着很大关系。Linux 为什么诞生于芬兰，而没有诞生于中国或是美国呢？原因就在于芬兰赫尔辛基大学从二十世纪七十年代就很注重操作系统的研究，积累了很多图书和代码。Linus 正是在前人的基础上才创立了 Linux。然而，国内在产、学环境方面对开源的发展存在着诸多限制因素。如目前经费的支配存在着垄断，并不是每个有创意的人都能拿到经费。你要把你的思想和别人共享，就要出书，但出版业是垄断的；你要传播你的思想办教育，国家不承认你的文凭，你就招不到学生。因此，洪峰强调，在这个问题上，政府不应该当运动员，而应该是规则的制定者。要让所有的纳税人受益，政府所要做的是制定好游戏规则。开源的发展还是一个反学术垄断的问题。&lt;br&gt;
　　洪峰同时认为，发展开源软件要抱着一种“入静”的心态，抛开浮躁。并不是要先把生活搞好了，再去搞开源软件，而一旦迈过了基本的门槛，回报就会来了。要知道许多开源软件项目的创立者在创立项目之初经济上也很贫困，但多年的心血换来的是一种超越层次的成功。但问题是目前整个环境太过浮躁，如大学中要求一年发表多少篇论文，但就是没有人统计这些论文中有多少获得过国际奖项，这些论文又有多少原创性。IT 业的一大挑战就在于原创，创造出一种新思想，就会带来巨大的收益。创意产生于人的头脑，并不完全产生于军团做战。因此，政府需要为开源的发展创造一个良好的生态环境，这是政府支持中最为重要的一部分。&lt;br&gt;
　　刘澎则认为，必须重新审视对待开源的保护策略，对待开源软件不能完全采取保护策略，如果把开源软件当作温室里的花朵，开源软件就永远也长不大。我们应该正视一个很有意思的现象：几千年过去以后，人人喊打的老鼠繁殖得比主宰这个世界的人类还要多，而人们视之为保护动物的老虎却进了动物保护园。目前开源社区在经济上遇到了一些困难，但中软、红旗、共创等开源软件企业自身经营也很困难，因此不可能指望他们资助开源社区。同时，国家的资金也应该只用来支持那些踏踏实实搞开源研究的人，而不应落入打着开源的幌子却在为自己谋私利的人手中。&lt;br&gt;
事实上，影响开源发展的还有一个重要的问题，就是国内软件的有效需求不足。在凯恩斯看来，当企业找不到出路时，政府就应出面采取一些诸如启动公共工程建设之类的措施来刺激经济的增长。与此同理，政府也应该考虑在同等条件下，政府可以将采购需要更多地向国产软件（特别是开源软件）倾斜。中国工程院院士沈昌祥介绍说：“国内目前急需安全等级达到A级的操作系统，在国内开发不出A级操作系统的情况下，只好采用国外的产品，而在许多机要部门，这是一个隐患。正因为如此，国家正在下大力气开发A级操作系统，许多从事开源软件研发的机构找到我，要求得到一个机会。这实际上就是需求促进开源发展的一个例子。”&lt;br&gt;
　　由此看来，在目前的情况下，开源的发展确实离不开政府的支持。而政府支持成为开源发展的灵丹妙药的前提，一是不能用包办代替的方法把开源管死，二是要在宏观层面结合开源发展的需求提供适时的政策帮助。&lt;br&gt;
开源与产业&lt;br&gt;
　　提起开源的发展，另一个不得不提的问题就是开源与产业的关系问题。业内专家普遍认为，发展开源软件可以促进软件产业的发展，而反过来，实现开源成果的产业化以后，又可以解决开源的商业模式问题，使得开源软件更好地向前发展。从这个角度说，开源与产业是一种互济的关系。&lt;br&gt;
　　对开源与产业的关系，洪峰举了这样一个例子：在中国西部，人们由于吃不饱饭就想到了挖山，其结果是造成了生态环境的恶化，反过来，人们因此而变得越发贫困。这就形成了一个恶性循环。现在政策反过来了，政府开始鼓励人们种树、种草，并给予一定的补助。这样一来，生存环境改善了，就业机会也增加了，形成了一个好的循环，人们的日子就越来越好过。洪峰感叹，同样的方法为什么不能应用在开源的发展上呢？&lt;br&gt;
　　倪光南院士指出：“政府原来的做法是支持五、六种 Linux，这样每家得到的支持力度又都不够。现在政府改为制订 Linux 标准，去引导在 Linux 上的开发，目前我国制订的中文 Linux 标准已经引起了一些国家、Linux 社区和跨国公司的关注。”一个产业的健康发展，需要不同厂商间的竞争与合作，而标准关系到整个产业链的各个环节，政府在其中的用意，完全可以通过信息产业部苟仲文副部长的一番话表现出来：“从以往看来，政府扶持企业，往往达不到政府所需的科研技术开发效果。即使达到了，又会形成新的垄断，企业往往不愿将研究成果与别的企业分享，最终还是达不到政府想通过个别企业来推动某技术产品在产业界形成主流产品的良好愿望。所以，我们政府在 Linux 这件事上，将转向支持基础的、开放的、公共的、服务的能力建设之上，而不是光支持某些企业公司的发展，依靠他们来走这条路。”&lt;br&gt;
　　早在二十世纪八十年代末，倪光南先生就提出了国内 IT 业“无芯无魂”的问题，当时，倪光南先生的建议并没有得到普遍的重视。而在此之后，我们为了弥补操作系统的问题，走了一条封闭开发之路。试想如果当时我们就采用开源的方式解决这些问题，相信今日IT业的格局已不是这个样子了。从这一问题上，我们不难发现开源在整个IT产业中所起的作用有多大。&lt;br&gt;
　　老话重提，今日的开源又走到了技术成熟而生态环境薄弱的十字路口，风险与机会混杂着摆在我们面前。面对着风险与机遇，我们必须明白，我们今天的行动将决定着经历了冰与火的融合之后的明天的中国开源的命运。&lt;/p&gt;
">加入开源社区，从社区中成长</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/sql-zhu-ru/"" data-c="
          &lt;p&gt;1&lt;/p&gt;
">(目标)SQL注入</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/oss-dui-xiang-yun-cun-chu/"" data-c="
          &lt;p&gt;1&lt;/p&gt;
">(目标)OSS对象云存储</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/ge-ren-she-qu-ji-hua-2-ge-yue/"" data-c="
          &lt;p&gt;目标：三年（2022）&lt;br&gt;
地址：git@github.com:yourkevin/NiterForum.git&lt;/p&gt;
&lt;h3 id=&#34;相关知识学习&#34;&gt;相关知识学习&lt;/h3&gt;
&lt;h2 id=&#34;jdk&#34;&gt;JDK&lt;/h2&gt;
&lt;p&gt;JDK是 Java 语言的软件开发工具包，主要用于移动设备、嵌入式设备上的java应用程序。JDK是整个java开发的核心，它包含了JAVA的运行环境（JVM+Java系统类库）和JAVA工具&lt;/p&gt;
">(目标)个人社区计划</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/ansible-zi-dong-hua-yun-wei/"" data-c="
          &lt;h3 id=&#34;学习目标长期&#34;&gt;学习目标：长期&lt;/h3&gt;
">(目标)ansible自动化运维</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/ji-yu-nextcloud-gou-jian-si-ren-yun-cun-chu/"" data-c="
          &lt;h3 id=&#34;目标15天部署成功217-&#34;&gt;目标：15天部署成功（2/17-）&lt;/h3&gt;
&lt;h3 id=&#34;1-配置&#34;&gt;1、配置：&lt;/h3&gt;
&lt;p&gt;最低配置：2核4g&lt;br&gt;
操作系统：CentOS7.x, Ubuntu20.04, Amazon Linux2&lt;br&gt;
公有云：AWS, Azure, 阿里云, 华为云, 腾讯云&lt;br&gt;
私有云：KVM, VMware, VirtualBox, OpenStack&lt;br&gt;
服务器配置：	最低2核6G，存储20GB以上，Swap分区2GB以上&lt;/p&gt;
&lt;h3 id=&#34;2-部署&#34;&gt;2、部署&lt;/h3&gt;
&lt;p&gt;将Nextcloud预装在线复制到服务器中&lt;/p&gt;
&lt;h3 id=&#34;云平台三种镜像部署&#34;&gt;云平台三种镜像部署&lt;/h3&gt;
&lt;p&gt;1、选购时作为服务器启动环境&lt;br&gt;
2、云市场&lt;br&gt;
3、已有服务器则重装系统&lt;/p&gt;
&lt;h3 id=&#34;脚本自动化部署&#34;&gt;脚本自动化部署&lt;/h3&gt;
&lt;p&gt;自动预装包在线下载到云服务器，基于Ansible脚本&lt;/p&gt;
&lt;h3 id=&#34;安装指南&#34;&gt;安装指南&lt;/h3&gt;
&lt;p&gt;以root用户登录Linux，一键自动化命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget -N https://ghproxy.com/https://raw.githubusercontent.com/Websoft9/ansible-linux/main/scripts/install.sh; bash install.sh -r nextcloud
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装注意事项&#34;&gt;安装注意事项：&lt;/h3&gt;
&lt;p&gt;安装中的注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作不慎或网络发生变化，可能会导致SSH连接被中断，安装就会失败，此时请重新安装&lt;/li&gt;
&lt;li&gt;安装缓慢、停滞不前或无故中断，主要是网络不通（或网速太慢）导致的下载问题，此时请重新安装&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;镜像部署-脚本部署&#34;&gt;镜像部署、脚本部署&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;项&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;镜像部署&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;脚本部署&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;部署成功率&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2-5分钟&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20-60分钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;技能要求&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;99.99%&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;80%，受制于网络和地域原因，可能会部署失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;安全&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;云厂商测试通过&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;内测通过&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;版本&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;固定&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;适当可变&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;费用&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;按需订阅&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;免费&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;源码&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;100%开源&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;100%开源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;云支持&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;公有云&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;公有云，私有云&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">(目标)基于Nextcloud构建私人云存储</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/hcna/"" data-c="
          &lt;p&gt;1&lt;/p&gt;
">(目标)HCNA</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/acaacpace-ren-zheng/"" data-c="
          &lt;h2 id=&#34;aca认证学习&#34;&gt;ACA认证学习：&lt;/h2&gt;
">(目标)ACA/ACP/ACE认证</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/c-yu-yan-zhi-zhen/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E7%90%86%E8%A7%A3%E6%95%B0%E7%BB%84&#34;&gt;一、理解数组&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%95%B0%E7%BB%84&#34;&gt;1.1 为什么要有数组？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89&#34;&gt;1.2 数组定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%BF%E7%94%A8&#34;&gt;1.3 数组元素的使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83&#34;&gt;二、内存分布&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C&#34;&gt;三、常见操作&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E9%81%8D%E5%8E%86&#34;&gt;3.1 数组元素的遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%E6%95%B0%E7%BB%84%E8%B5%8B%E5%88%9D%E5%80%BC&#34;&gt;3.2 数组赋初值&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84&#34;&gt;四、二维数组&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41-%E6%9C%AC%E8%B4%A8&#34;&gt;4.1 本质&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42-%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E5%9B%BE&#34;&gt;4.2 内存映像图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%B5%8B%E5%88%9D%E5%80%BC&#34;&gt;4.3 二维数组赋初值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#44-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86&#34;&gt;4.4 二维数组的遍历&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2&#34;&gt;五、字符数组与字符串&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51-%E5%AD%97%E7%AC%A6%E4%B8%B2&#34;&gt;5.1 字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52-%E8%BF%90%E7%AE%97%E7%AC%A6sizeof&#34;&gt;5.2 运算符：sizeof()&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#521-sizeof%E7%9A%84%E7%94%A8%E6%B3%95&#34;&gt;5.2.1 sizeof()的用法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#5211-sizeof%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%A7%B0&#34;&gt;5.2.1.1 sizeof(数据类型名称)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5212-sizeof%E5%8F%98%E9%87%8F%E5%90%8D%E7%A7%B0%E6%88%96%E6%95%B0%E7%BB%84%E5%90%8D%E7%A7%B0&#34;&gt;5.2.1.2 sizeof(变量名称或数组名称)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5213-sizeof%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F&#34;&gt;5.2.1.3 sizeof(字符串常量)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#53-strlen%E5%87%BD%E6%95%B0&#34;&gt;5.3 strlen()函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#54-%E6%80%BB%E7%BB%93&#34;&gt;5.4 总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AD%E8%AF%B4%E6%98%8E&#34;&gt;六、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三步走战略的打法，五大能力培养体系的构建。&lt;/p&gt;
&lt;p&gt;数组、指针、函数，并列 C 语言三大重点，尤其 C 指针，堪称 C 之灵魂，从 C 数组开始，勤思苦练，必须多敲、搞清楚底层原理，系统设计，从宏观、哲学上理解 C 之精髓。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强烈建议：b 站郝斌 C 视频结合着看。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一-理解数组&#34;&gt;一、理解数组&lt;/h2&gt;
&lt;h3 id=&#34;11-为什么要有数组&#34;&gt;1.1 为什么要有数组？&lt;/h3&gt;
&lt;p&gt;数组：多个内存变量元素，共同使用一个变量名称，并用下标加以区分。&lt;/p&gt;
&lt;p&gt;数组与变量一样，必需先定义，再使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[10]; //定义了一个名称为 a 的，拥有 10 个 int 类型元素的数组；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;定义数组时，[] 里的内容不能是浮点数据，也不能是变量或者含有变量的表达式。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[1+2*2], b[&#39;a&#39;]; //这种定义是正确的；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-数组定义&#34;&gt;1.2 数组定义&lt;/h3&gt;
&lt;p&gt;int ar[10];&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这只能表示存在一个拥有 10 个 int 类型的元素的数组 ar，在这条定义语句之外的其他地方，ar 不表示数组的任何一个元素，也不表示数组的所有元素，它仅仅是数组名称而已。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;13-数组元素的使用&#34;&gt;1.3 数组元素的使用&lt;/h3&gt;
&lt;p&gt;数组元素的定义、与使用，是完全不一样的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;设有如下数组：int a[10];

a 数组的 10 个元素分别是：a[0]，a[1],  a[2]......a[9]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组元素下标范围取值范围在[0, n)之间，其中 n 为数组元素个数，这个数组将在内存中占用 40B 的连续存储空间。&lt;/p&gt;
&lt;h2 id=&#34;二-内存分布&#34;&gt;二、内存分布&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数组在内存中的存储方式&lt;/strong&gt;&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_jpg/iaumSdLKJXtQ8QIPf25Hcygz3eCYWcjuyASEUSQh4JdDYZPKtm92AaxBQLQLNXrWZPWGcuxXLhut1dpPV2tG6qw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39;&gt;&lt;/div&gt;
&lt;p align=center&gt;(一维数组存储方式)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int array[5];

array 数组应该有 5 个元素：array[0]、array[1]、array[2]、array[3]、array[4];

此时，我们的考虑，array[0]、array[4] 的前面 array[-1]、后面 array[5] 是否还有内存空间，还能访问到吗？
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;逻辑上不存在，物理上存在！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组的定义仅仅约束的是人的思想，根本无法约束计算机的行为，关于数组下标越界，只是一个传说！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C 语言编译软件是不能发现“下标越界”的错误的！这意味着：“下标越界”这种错误完全需要靠程序员非常高的编程素养来避免！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;三-常见操作&#34;&gt;三、常见操作&lt;/h2&gt;
&lt;h3 id=&#34;31-数组元素的遍历&#34;&gt;3.1 数组元素的遍历&lt;/h3&gt;
&lt;p&gt;对于数组中的元素，进行不重复、无遗漏的一次性访问。&lt;/p&gt;
&lt;p&gt;下面几种错误的输出方式：&lt;/p&gt;
&lt;p&gt;int a[10]; 元素有：a[0]......a[9]，打算输出 a 数组中的所有值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&amp;quot;%d\n&amp;quot;, int a[10]);  //错误
printf(&amp;quot;%d\n&amp;quot;, a[10]);  //这条语句被 C 语言认为，输出的是数组 a 的，下标为 10 的，第 11 个元素的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于已经定义了一个拥有 n 个元素的数组 ar；对于这个数组所有元素进行遍历的程序框架是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for(i = 0; i &amp;lt; n; i++)
{
    ...ar[i]...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;总是从下标为 0 的元素开始遍历；&lt;/li&gt;
&lt;li&gt;下标总是连续变化，这意味着，对数据的遍历是连续的，不跳跃，不重复；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据存储在数组中需要满足的 3 个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从下标为 0 的第一个元素（首元素）开始存放；&lt;/li&gt;
&lt;li&gt;连续存放；&lt;/li&gt;
&lt;li&gt;上述两个特点必须保持动态满足（意思是：无论删除还是插入数据，在删除或插入数据后，依然要满足上述两个基本条件）；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对于数组的编程，主要考虑的是下标，或者可以说：玩数组就是玩下标。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;32-数组赋初值&#34;&gt;3.2 数组赋初值&lt;/h3&gt;
&lt;p&gt;数组赋初值操作仅能发生在数组定义语句未结束时。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[5] = {1, 2, 3, 4, 5};
int a[5] = {1, 2, 3, 4, 5, 6}; //语法错误
int a[5] = {1, 2, 3}; //不完全赋初值：初值个数少于所申请的数组元素个数，则从下标为 0 的元素开始，前面连续若干个元素被赋初值，其余元素的值被 C 语言统一赋值为 0(不是垃圾数据)
int a[100] = {1};
int a[5] = {}; //语法错误
int a[]; //语法错误，不能形成有效的数据类型（长度不定）
int a[] = {1, 2, 3, 4, 5, 6, 7}; //定义数组，不明确声明数组元素个数，但赋初值；则，数组元素个数取决于初值个数
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四-二维数组&#34;&gt;四、二维数组&lt;/h2&gt;
&lt;h3 id=&#34;41-本质&#34;&gt;4.1 本质&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[3][4]; //3行4列；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;计算机内存根本就没有二维及多维数组，因为内存是一维，线性管理的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;42-内存映像图&#34;&gt;4.2 内存映像图&lt;/h3&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_jpg/iaumSdLKJXtQ8QIPf25Hcygz3eCYWcjuyVuwWHcQYXYc4OEt3YCk4uiaBYN2vhtLibiaVQ3UaskYYX52YeIo2ib1x2Q/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39;&gt;&lt;/div&gt;
&lt;p align=center&gt;(二维数组存储方式)&lt;/p&gt;
&lt;h3 id=&#34;43-二维数组赋初值&#34;&gt;4.3 二维数组赋初值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
};  //二维数组是集合的集合；

int a[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}; //二维数组的本质还是一维的了；
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[3][4] = {{1}, {2}, {3}, {4}}; //语法错误，初始化数据个数过多；
int a[3][4] = {{}, {1}}; //语法错误；

int a[][4] = {...};
int a[][4][5] = {...};  //这种缺省的数组初始化是正确的；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;44-二维数组的遍历&#34;&gt;4.4 二维数组的遍历&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for(i = 0; i &amp;lt; row; i++){
    for(j = 0; j &amp;lt; col; j++){
            ...a[i][j]...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;五-字符数组与字符串&#34;&gt;五、字符数组与字符串&lt;/h2&gt;
&lt;h3 id=&#34;51-字符串&#34;&gt;5.1 字符串&lt;/h3&gt;
&lt;p&gt;以 0 结束的字符数组,&lt;strong&gt;这里的 0，就是数字 0，不是字符零 &#39;0&#39;，其ASCII 码值为 48。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;&amp;quot;abcdef&amp;quot;
012345
printf(&amp;quot;%c\n&amp;quot;, &amp;quot;abcdef&amp;quot;[3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char s[5] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;}; //字符数组
char s[5] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;0&#39;}; //字符数组
char s[5] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, 0}; //字符串
char s[5] = &amp;quot;ABCD&amp;quot;; //字符串
char s[5] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;}; //字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;字符串常量（&amp;quot;&amp;quot;，所括起来的内容）的最后，一定存在着一个看不见的 0 结束标志！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char s[6] = &amp;quot;abcdef&amp;quot;;  //语法错误，最后有一个 0 结束标志；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52-运算符sizeof&#34;&gt;5.2 运算符：sizeof()&lt;/h3&gt;
&lt;p&gt;它是一个运算符，而非函数！！！，是一个单目运算符，其运算优先级在单目运算符中最低。&lt;/p&gt;
&lt;h4 id=&#34;521-sizeof的用法&#34;&gt;5.2.1 sizeof()的用法&lt;/h4&gt;
&lt;h5 id=&#34;5211-sizeof数据类型名称&#34;&gt;5.2.1.1 sizeof(数据类型名称)&lt;/h5&gt;
&lt;p&gt;sizeof(int)、sizeof(float)、sizeof(char)，其计算结果：&lt;strong&gt;相关数据类型所占用的内存空间的字节数。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;5212-sizeof变量名称或数组名称&#34;&gt;5.2.1.2 sizeof(变量名称或数组名称)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char a;
double b;
short c[100];

sizeof(a) ==&amp;gt; 1B
sizeof(b) ==&amp;gt; 8B
sizeof(c) ==&amp;gt; 200B
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;5213-sizeof字符串常量&#34;&gt;5.2.1.3 sizeof(字符串常量)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;sizeof(&amp;quot;abcde&amp;quot;) ==&amp;gt; 6B;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其运算结果：&lt;strong&gt;该字符串常量在内存中所占用的字节数（该数值是字符串长度+1，这个 1B 就是 0 结束标志！）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;53-strlen函数&#34;&gt;5.3 strlen()函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;是用来计算字符串长度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若要调用 strlen() 函数，则必须在程序的最开始加上：#include&amp;lt;string.h&amp;gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&amp;quot;%d\n&amp;quot;, strlen(&amp;quot;abcdefg&amp;quot;));  //结果为7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于字符串的处理：&lt;strong&gt;遇 0 则止（调用字符串函数）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;54-总结&#34;&gt;5.4 总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;sizeof() 是计算所占用的空间字节大小；&lt;/li&gt;
&lt;li&gt;strlen() 是计算字符串数组的长度，遇 0 则止；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章仅仅是数组入门，对于数组的本质掌握是非常的关键，尤其在跟指针的结合，理解，打好基础，进阶提升。&lt;/p&gt;
">（C语言）指针</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/c-yu-yan-shu-zu/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E7%90%86%E8%A7%A3%E6%95%B0%E7%BB%84&#34;&gt;一、理解数组&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%95%B0%E7%BB%84&#34;&gt;1.1 为什么要有数组？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89&#34;&gt;1.2 数组定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%BF%E7%94%A8&#34;&gt;1.3 数组元素的使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83&#34;&gt;二、内存分布&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C&#34;&gt;三、常见操作&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E9%81%8D%E5%8E%86&#34;&gt;3.1 数组元素的遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%E6%95%B0%E7%BB%84%E8%B5%8B%E5%88%9D%E5%80%BC&#34;&gt;3.2 数组赋初值&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84&#34;&gt;四、二维数组&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41-%E6%9C%AC%E8%B4%A8&#34;&gt;4.1 本质&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42-%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E5%9B%BE&#34;&gt;4.2 内存映像图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%B5%8B%E5%88%9D%E5%80%BC&#34;&gt;4.3 二维数组赋初值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#44-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86&#34;&gt;4.4 二维数组的遍历&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2&#34;&gt;五、字符数组与字符串&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51-%E5%AD%97%E7%AC%A6%E4%B8%B2&#34;&gt;5.1 字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52-%E8%BF%90%E7%AE%97%E7%AC%A6sizeof&#34;&gt;5.2 运算符：sizeof()&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#521-sizeof%E7%9A%84%E7%94%A8%E6%B3%95&#34;&gt;5.2.1 sizeof()的用法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#5211-sizeof%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%A7%B0&#34;&gt;5.2.1.1 sizeof(数据类型名称)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5212-sizeof%E5%8F%98%E9%87%8F%E5%90%8D%E7%A7%B0%E6%88%96%E6%95%B0%E7%BB%84%E5%90%8D%E7%A7%B0&#34;&gt;5.2.1.2 sizeof(变量名称或数组名称)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5213-sizeof%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F&#34;&gt;5.2.1.3 sizeof(字符串常量)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#53-strlen%E5%87%BD%E6%95%B0&#34;&gt;5.3 strlen()函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#54-%E6%80%BB%E7%BB%93&#34;&gt;5.4 总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AD%E8%AF%B4%E6%98%8E&#34;&gt;六、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三步走战略的打法，五大能力培养体系的构建。&lt;/p&gt;
&lt;p&gt;数组、指针、函数，并列 C 语言三大重点，尤其 C 指针，堪称 C 之灵魂，从 C 数组开始，勤思苦练，必须多敲、搞清楚底层原理，系统设计，从宏观、哲学上理解 C 之精髓。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强烈建议：b 站郝斌 C 视频结合着看。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一-理解数组&#34;&gt;一、理解数组&lt;/h2&gt;
&lt;h3 id=&#34;11-为什么要有数组&#34;&gt;1.1 为什么要有数组？&lt;/h3&gt;
&lt;p&gt;数组：多个内存变量元素，共同使用一个变量名称，并用下标加以区分。&lt;/p&gt;
&lt;p&gt;数组与变量一样，必需先定义，再使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[10]; //定义了一个名称为 a 的，拥有 10 个 int 类型元素的数组；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;定义数组时，[] 里的内容不能是浮点数据，也不能是变量或者含有变量的表达式。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[1+2*2], b[&#39;a&#39;]; //这种定义是正确的；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-数组定义&#34;&gt;1.2 数组定义&lt;/h3&gt;
&lt;p&gt;int ar[10];&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这只能表示存在一个拥有 10 个 int 类型的元素的数组 ar，在这条定义语句之外的其他地方，ar 不表示数组的任何一个元素，也不表示数组的所有元素，它仅仅是数组名称而已。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;13-数组元素的使用&#34;&gt;1.3 数组元素的使用&lt;/h3&gt;
&lt;p&gt;数组元素的定义、与使用，是完全不一样的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;设有如下数组：int a[10];

a 数组的 10 个元素分别是：a[0]，a[1],  a[2]......a[9]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组元素下标范围取值范围在[0, n)之间，其中 n 为数组元素个数，这个数组将在内存中占用 40B 的连续存储空间。&lt;/p&gt;
&lt;h2 id=&#34;二-内存分布&#34;&gt;二、内存分布&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数组在内存中的存储方式&lt;/strong&gt;&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_jpg/iaumSdLKJXtQ8QIPf25Hcygz3eCYWcjuyASEUSQh4JdDYZPKtm92AaxBQLQLNXrWZPWGcuxXLhut1dpPV2tG6qw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39;&gt;&lt;/div&gt;
&lt;p align=center&gt;(一维数组存储方式)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int array[5];

array 数组应该有 5 个元素：array[0]、array[1]、array[2]、array[3]、array[4];

此时，我们的考虑，array[0]、array[4] 的前面 array[-1]、后面 array[5] 是否还有内存空间，还能访问到吗？
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;逻辑上不存在，物理上存在！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组的定义仅仅约束的是人的思想，根本无法约束计算机的行为，关于数组下标越界，只是一个传说！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C 语言编译软件是不能发现“下标越界”的错误的！这意味着：“下标越界”这种错误完全需要靠程序员非常高的编程素养来避免！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;三-常见操作&#34;&gt;三、常见操作&lt;/h2&gt;
&lt;h3 id=&#34;31-数组元素的遍历&#34;&gt;3.1 数组元素的遍历&lt;/h3&gt;
&lt;p&gt;对于数组中的元素，进行不重复、无遗漏的一次性访问。&lt;/p&gt;
&lt;p&gt;下面几种错误的输出方式：&lt;/p&gt;
&lt;p&gt;int a[10]; 元素有：a[0]......a[9]，打算输出 a 数组中的所有值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&amp;quot;%d\n&amp;quot;, int a[10]);  //错误
printf(&amp;quot;%d\n&amp;quot;, a[10]);  //这条语句被 C 语言认为，输出的是数组 a 的，下标为 10 的，第 11 个元素的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于已经定义了一个拥有 n 个元素的数组 ar；对于这个数组所有元素进行遍历的程序框架是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for(i = 0; i &amp;lt; n; i++)
{
    ...ar[i]...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;总是从下标为 0 的元素开始遍历；&lt;/li&gt;
&lt;li&gt;下标总是连续变化，这意味着，对数据的遍历是连续的，不跳跃，不重复；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据存储在数组中需要满足的 3 个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从下标为 0 的第一个元素（首元素）开始存放；&lt;/li&gt;
&lt;li&gt;连续存放；&lt;/li&gt;
&lt;li&gt;上述两个特点必须保持动态满足（意思是：无论删除还是插入数据，在删除或插入数据后，依然要满足上述两个基本条件）；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对于数组的编程，主要考虑的是下标，或者可以说：玩数组就是玩下标。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;32-数组赋初值&#34;&gt;3.2 数组赋初值&lt;/h3&gt;
&lt;p&gt;数组赋初值操作仅能发生在数组定义语句未结束时。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[5] = {1, 2, 3, 4, 5};
int a[5] = {1, 2, 3, 4, 5, 6}; //语法错误
int a[5] = {1, 2, 3}; //不完全赋初值：初值个数少于所申请的数组元素个数，则从下标为 0 的元素开始，前面连续若干个元素被赋初值，其余元素的值被 C 语言统一赋值为 0(不是垃圾数据)
int a[100] = {1};
int a[5] = {}; //语法错误
int a[]; //语法错误，不能形成有效的数据类型（长度不定）
int a[] = {1, 2, 3, 4, 5, 6, 7}; //定义数组，不明确声明数组元素个数，但赋初值；则，数组元素个数取决于初值个数
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四-二维数组&#34;&gt;四、二维数组&lt;/h2&gt;
&lt;h3 id=&#34;41-本质&#34;&gt;4.1 本质&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[3][4]; //3行4列；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;计算机内存根本就没有二维及多维数组，因为内存是一维，线性管理的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;42-内存映像图&#34;&gt;4.2 内存映像图&lt;/h3&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_jpg/iaumSdLKJXtQ8QIPf25Hcygz3eCYWcjuyVuwWHcQYXYc4OEt3YCk4uiaBYN2vhtLibiaVQ3UaskYYX52YeIo2ib1x2Q/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39;&gt;&lt;/div&gt;
&lt;p align=center&gt;(二维数组存储方式)&lt;/p&gt;
&lt;h3 id=&#34;43-二维数组赋初值&#34;&gt;4.3 二维数组赋初值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
};  //二维数组是集合的集合；

int a[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}; //二维数组的本质还是一维的了；
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[3][4] = {{1}, {2}, {3}, {4}}; //语法错误，初始化数据个数过多；
int a[3][4] = {{}, {1}}; //语法错误；

int a[][4] = {...};
int a[][4][5] = {...};  //这种缺省的数组初始化是正确的；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;44-二维数组的遍历&#34;&gt;4.4 二维数组的遍历&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for(i = 0; i &amp;lt; row; i++){
    for(j = 0; j &amp;lt; col; j++){
            ...a[i][j]...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;五-字符数组与字符串&#34;&gt;五、字符数组与字符串&lt;/h2&gt;
&lt;h3 id=&#34;51-字符串&#34;&gt;5.1 字符串&lt;/h3&gt;
&lt;p&gt;以 0 结束的字符数组,&lt;strong&gt;这里的 0，就是数字 0，不是字符零 &#39;0&#39;，其ASCII 码值为 48。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;&amp;quot;abcdef&amp;quot;
012345
printf(&amp;quot;%c\n&amp;quot;, &amp;quot;abcdef&amp;quot;[3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char s[5] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;}; //字符数组
char s[5] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;0&#39;}; //字符数组
char s[5] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, 0}; //字符串
char s[5] = &amp;quot;ABCD&amp;quot;; //字符串
char s[5] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;}; //字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;字符串常量（&amp;quot;&amp;quot;，所括起来的内容）的最后，一定存在着一个看不见的 0 结束标志！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char s[6] = &amp;quot;abcdef&amp;quot;;  //语法错误，最后有一个 0 结束标志；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52-运算符sizeof&#34;&gt;5.2 运算符：sizeof()&lt;/h3&gt;
&lt;p&gt;它是一个运算符，而非函数！！！，是一个单目运算符，其运算优先级在单目运算符中最低。&lt;/p&gt;
&lt;h4 id=&#34;521-sizeof的用法&#34;&gt;5.2.1 sizeof()的用法&lt;/h4&gt;
&lt;h5 id=&#34;5211-sizeof数据类型名称&#34;&gt;5.2.1.1 sizeof(数据类型名称)&lt;/h5&gt;
&lt;p&gt;sizeof(int)、sizeof(float)、sizeof(char)，其计算结果：&lt;strong&gt;相关数据类型所占用的内存空间的字节数。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;5212-sizeof变量名称或数组名称&#34;&gt;5.2.1.2 sizeof(变量名称或数组名称)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char a;
double b;
short c[100];

sizeof(a) ==&amp;gt; 1B
sizeof(b) ==&amp;gt; 8B
sizeof(c) ==&amp;gt; 200B
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;5213-sizeof字符串常量&#34;&gt;5.2.1.3 sizeof(字符串常量)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;sizeof(&amp;quot;abcde&amp;quot;) ==&amp;gt; 6B;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其运算结果：&lt;strong&gt;该字符串常量在内存中所占用的字节数（该数值是字符串长度+1，这个 1B 就是 0 结束标志！）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;53-strlen函数&#34;&gt;5.3 strlen()函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;是用来计算字符串长度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若要调用 strlen() 函数，则必须在程序的最开始加上：#include&amp;lt;string.h&amp;gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&amp;quot;%d\n&amp;quot;, strlen(&amp;quot;abcdefg&amp;quot;));  //结果为7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于字符串的处理：&lt;strong&gt;遇 0 则止（调用字符串函数）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;54-总结&#34;&gt;5.4 总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;sizeof() 是计算所占用的空间字节大小；&lt;/li&gt;
&lt;li&gt;strlen() 是计算字符串数组的长度，遇 0 则止；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章仅仅是数组入门，对于数组的本质掌握是非常的关键，尤其在跟指针的结合，理解，打好基础，进阶提升。&lt;/p&gt;
&lt;h2 id=&#34;六-说明&#34;&gt;六、说明&lt;/h2&gt;
&lt;p&gt;原创文章链接：&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzU4MjQ3NzEyNA==&amp;amp;mid=2247483942&amp;amp;idx=1&amp;amp;sn=2746282247afd15cfcd3d5d27cf198e1&amp;amp;chksm=fdb6f60dcac17f1bda35132ff44bc260b0a6aef3bff509bb94edaa8ca987c6be12013fa5ee83&amp;amp;token=1250675081&amp;amp;lang=zh_CN#rd&#34;&gt;C 语言程序设计--&amp;gt;数组&lt;/a&gt;&lt;/p&gt;
">（C语言）数组</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/c-yu-yan-shu-ju-lei-xing-ji-yun-suan-fu/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&#34;&gt;一、数据类型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%86%E5%88%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F&#34;&gt;1.1 计算机识别数据的方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%E5%AD%98%E5%82%A8%E9%95%BF%E5%BA%A6&#34;&gt;1.2 存储长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&#34;&gt;1.3 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-c-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B64%E4%BD%8D&#34;&gt;1.4 C 语言中的数据类型(64位)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E8%BF%90%E7%AE%97%E7%AC%A6&#34;&gt;二、运算符&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6&#34;&gt;2.1 算术运算符&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#211-%E6%95%B0%E5%AD%A6%E5%A4%84%E7%90%86%E7%B1%BB%E5%87%BD%E6%95%B0&#34;&gt;2.1.1 数学处理类函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6&#34;&gt;2.2 关系运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6&#34;&gt;2.3 逻辑运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6&#34;&gt;2.4 赋值运算符&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#241-%E7%AE%80%E5%8D%95%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6&#34;&gt;2.4.1 简单赋值运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#242-%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6&#34;&gt;2.4.2 复合赋值运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#243-%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6&#34;&gt;2.4.3 自增、自减运算符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#25-%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6&#34;&gt;2.5 三目运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#26-%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6&#34;&gt;2.6 逗号运算符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E8%A1%A5%E5%85%85%E5%9B%9B%E4%B8%AA%E9%97%AE%E9%A2%98&#34;&gt;三、补充四个问题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%E5%85%B3%E4%BA%8E%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E9%97%AE%E9%A2%98&#34;&gt;3.1 关于运算符优先级的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&#34;&gt;3.2 数据类型转换&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#321-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&#34;&gt;3.2.1 自动类型转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#322-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&#34;&gt;3.2.2 强制类型转换&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33-%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97&#34;&gt;3.3 短路运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#34-%E5%85%B3%E4%BA%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0&#34;&gt;3.4 关于输入/输出函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E8%AF%B4%E6%98%8E&#34;&gt;四、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一-数据类型&#34;&gt;一、数据类型&lt;/h2&gt;
&lt;p&gt;数据类型：计算机对数据的识别方式和存储长度。&lt;/p&gt;
&lt;h3 id=&#34;11-计算机识别数据的方式&#34;&gt;1.1 计算机识别数据的方式&lt;/h3&gt;
&lt;p&gt;计算机只能识别 0 和 1 ，对于 1001 0110 其解释方式有很多，不同的数据类型其解释就不一样。&lt;/p&gt;
&lt;p&gt;1001 0110：我可以理解为：无符号数，整型、补码、浮点数、ASCII 码、指针(字节编号)，等，怎么确定到底是哪一个？取决于数据类型。&lt;/p&gt;
&lt;h3 id=&#34;12-存储长度&#34;&gt;1.2 存储长度&lt;/h3&gt;
&lt;p&gt;计算机总是以 2 的整数次幂个字节来存储数据，因此常见的长度为：1B、2B、4B、8B。&lt;/p&gt;
&lt;h3 id=&#34;13-数据类型&#34;&gt;1.3 数据类型&lt;/h3&gt;
&lt;p&gt;数据类型有 2 个关键要素，&lt;strong&gt;识别方式和长度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上面的两个要素，必须都明确的指出，如果有一个不确定，则不能形成有效的数据类型。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;14-c-语言中的数据类型64位&#34;&gt;1.4 C 语言中的数据类型(64位)&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;标识符&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;长度&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;识别方式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;char&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1B&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;字符型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ASCII码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;short&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2B&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;短整型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;补码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;int&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4B&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;整型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;补码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;long&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;8B&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;长整型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;浮点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;float&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4B&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单精度&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;浮点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;double&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;8B&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;双精度&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;浮点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;*&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;8B&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;地址/指针&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;字节编号&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;二-运算符&#34;&gt;二、运算符&lt;/h2&gt;
&lt;h3 id=&#34;21-算术运算符&#34;&gt;2.1 算术运算符&lt;/h3&gt;
&lt;p&gt;优先级由高到低：()、+/-(正/负号)、*、/、%、+、-；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/ 除法：整型除以整型，结果是整型（截取整数部分）；&lt;/li&gt;
&lt;li&gt;%取余数：只能是整型量参与运算：char、short、int、long；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;211-数学处理类函数&#34;&gt;2.1.1 数学处理类函数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;abs(x) ==&amp;gt; |x|(适用于整型数值)&lt;/li&gt;
&lt;li&gt;fabs(x) ==&amp;gt; |x|(适用于浮点值)&lt;/li&gt;
&lt;li&gt;sqrt(x) ==&amp;gt; 求 x 的算法平方根&lt;/li&gt;
&lt;li&gt;pow(x,y) ==&amp;gt; x 的 y 次方&lt;/li&gt;
&lt;li&gt;exp(x) ==&amp;gt; e 的 x 次方&lt;/li&gt;
&lt;li&gt;log(x) ==&amp;gt; ln(x)&lt;/li&gt;
&lt;li&gt;log10(x) ==&amp;gt; lg(x)&lt;/li&gt;
&lt;li&gt;sin(x) ==&amp;gt; sin(x)&lt;/li&gt;
&lt;li&gt;cos(x) ==&amp;gt; cos(x)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-关系运算符&#34;&gt;2.2 关系运算符&lt;/h3&gt;
&lt;p&gt;常见：&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=、!=、==&lt;/p&gt;
&lt;p&gt;关系运算符的优先级低于算术运算符。&lt;/p&gt;
&lt;p&gt;关系运算符的运算结果：&lt;strong&gt;只有 1(真) 和 0(假)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&amp;quot;%d\n&amp;quot;, (2 &amp;gt; 1) * 5);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实这样运算的：优先级() &amp;gt; &lt;em&gt;，所以先进行 2 &amp;gt; 1的运算，其结果为真，也就是 1，1&lt;/em&gt;5=5，其最终的输出就为：5。&lt;/p&gt;
&lt;p&gt;写一个 x 大于 2 小于 10 的数学表达式，10 &amp;gt; x &amp;gt; 2，C语言认为这个写法是错误的，我们是在写程序，不是在写数学表达式，一定的记住：数学表达式跟程序还是有很大的差异的，正确写法：2 &amp;lt; x &amp;amp;&amp;amp; x &amp;lt; 10。&lt;/p&gt;
&lt;h3 id=&#34;23-逻辑运算符&#34;&gt;2.3 逻辑运算符&lt;/h3&gt;
&lt;p&gt;常见：!、&amp;amp;&amp;amp;、||&lt;/p&gt;
&lt;p&gt;!(单目运算符：只有一个操作对象)，高于双目运算符的优先级。&lt;/p&gt;
&lt;p&gt;对于逻辑运算符，C 语言会将两侧的当做表达式看待，其最终的结果是：0 为假，非 0 为真，是一个逻辑的判断。&lt;/p&gt;
&lt;h3 id=&#34;24-赋值运算符&#34;&gt;2.4 赋值运算符&lt;/h3&gt;
&lt;p&gt;除了赋值运算符外，其他任何运算都不能改变变量的值；不能对常量或者表达式进行赋值运算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;赋值的本质：覆盖，覆盖空间中的原值。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;241-简单赋值运算符&#34;&gt;2.4.1 简单赋值运算符&lt;/h4&gt;
&lt;p&gt;=：仅仅比 , 运算符优先级高，变量 = 表达式；&lt;/p&gt;
&lt;h4 id=&#34;242-复合赋值运算符&#34;&gt;2.4.2 复合赋值运算符&lt;/h4&gt;
&lt;p&gt;+=、-=、*=、/=、%=，仅仅比 , 运算符优先级高；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;n *= 4+6; &amp;lt;==&amp;gt; n = n * (4 + 6);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引入的意义：可以对 C 中变量名称过长得到解决。&lt;/p&gt;
&lt;h4 id=&#34;243-自增-自减运算符&#34;&gt;2.4.3 自增、自减运算符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;++、--：运算符的本质是赋值运算符；&lt;/li&gt;
&lt;li&gt;均为单目运算符，优先级高于所有的双目，且优先级低于 !(逻辑非)；&lt;/li&gt;
&lt;li&gt;++i：先对变量 i 增 1，在参加其后所有运算；&lt;/li&gt;
&lt;li&gt;i++：先用原值参加后续运算，本条语句执行完毕，在自增 1；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;25-三目运算符&#34;&gt;2.5 三目运算符&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;?: 其优先级仅仅高于赋值运算符；&lt;/li&gt;
&lt;li&gt;语法：条表 ?  表1  :  表2，看前面表达式的结果，为真执行表 1，为假执行表 2；&lt;/li&gt;
&lt;li&gt;得到 a 和 b 中的最大值：a &amp;gt; b ? a : b;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;26-逗号运算符&#34;&gt;2.6 逗号运算符&lt;/h3&gt;
&lt;p&gt;逗号运算符的优先级是最低的，逗号是用来分隔多个表达式的，其运算结果是：最后一个表达式的运算结果。&lt;/p&gt;
&lt;h2 id=&#34;三-补充四个问题&#34;&gt;三、补充四个问题&lt;/h2&gt;
&lt;h3 id=&#34;31-关于运算符优先级的问题&#34;&gt;3.1 关于运算符优先级的问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一次只比较两个相邻运算符；&lt;/li&gt;
&lt;li&gt;一次只处理相邻两个运算符中的一个；&lt;/li&gt;
&lt;li&gt;当前运算符是否运算，取决于与相邻运算符的优先级比较结果：当前运算符 “低于” 其后的运算符，则不运算，否则，就运算；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32-数据类型转换&#34;&gt;3.2 数据类型转换&lt;/h3&gt;
&lt;h4 id=&#34;321-自动类型转换&#34;&gt;3.2.1 自动类型转换&lt;/h4&gt;
&lt;p&gt;在参加运算的两个运算数的数据类型不一样，C 语言会对其进行自动的类型转换工作，其原则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;由短类型向长类型进行靠拢，由简单类型向复杂类型靠拢；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;char--&amp;gt;short--&amp;gt;int--&amp;gt;float--&amp;gt;double；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;322-强制类型转换&#34;&gt;3.2.2 强制类型转换&lt;/h4&gt;
&lt;p&gt;语法：（数据类型名称）表达式；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;source = (double) 1 / 5 //其结果就是double类型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;强制类型转换：&lt;strong&gt;仅仅是对这个变量的值进行转换，是绝对不可能改变变量的数据类型，且也是运算符，是单目运算符中优先级最低的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;33-短路运算&#34;&gt;3.3 短路运算&lt;/h3&gt;
&lt;p&gt;逻辑运算中的0、1铁律：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0  &amp;amp;&amp;amp;  A  ==&amp;gt;  0、1  &amp;amp;&amp;amp;  A  ==&amp;gt;  A&lt;/li&gt;
&lt;li&gt;0  ||  A  ==&amp;gt;  A、1  ||  A  ==&amp;gt;  1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;短路运算是仅仅发生在逻辑运算表达式中。&lt;/p&gt;
&lt;p&gt;在 &amp;amp;&amp;amp; 运算符的左侧表达式的值为 0，或在 || 的左侧为非 0 ，此时整个逻辑表达式的结果已经确定，&lt;strong&gt;C 语言会发生短路运算，即对于右侧表达式不予运算。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;34-关于输入输出函数&#34;&gt;3.4 关于输入/输出函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;输入、输出是通过 C 语言调用 printf() scanf() 函数实现的；&lt;/li&gt;
&lt;li&gt;格式符是决定数值以怎样的方式展现出来；&lt;/li&gt;
&lt;li&gt;在scanf()函数的&amp;quot; &amp;quot;中，&lt;strong&gt;除了写格式符之外，不要写任何其它东西，&lt;/strong&gt;&amp;quot;%d%s%c&amp;quot;写成这样就好了；&lt;/li&gt;
&lt;/ul&gt;
">（C语言）数据类型及运算符</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/c-yu-yan-jie-gou-ti-gong-tong-ti-dong-tai-cun-chu-fen-pei/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%85%B1%E7%94%A8%E4%BD%93&#34;&gt;一、结构体与共用体&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%E7%BB%93%E6%9E%84%E4%BD%93&#34;&gt;1.1 结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%E5%85%B1%E7%94%A8%E4%BD%93&#34;&gt;1.2 共用体&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B&#34;&gt;二、宏定义与用户自定义类型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%E5%AE%8F%E5%AE%9A%E4%B9%89&#34;&gt;2.1 宏定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B&#34;&gt;2.2 用户自定义类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D&#34;&gt;三、动态存储分配&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D&#34;&gt;3.1 静态存储分配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D&#34;&gt;3.2 动态存储分配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33-%E4%B8%BE-2-%E4%B8%AA%E4%BE%8B%E5%AD%90&#34;&gt;3.3 举 2 个例子&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#331-%E6%A1%88%E4%BE%8B-1&#34;&gt;3.3.1 案例 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#332-%E6%A1%88%E4%BE%8B-2&#34;&gt;3.3.2 案例 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E8%AF%B4%E6%98%8E&#34;&gt;四、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一-结构体与共用体&#34;&gt;一、结构体与共用体&lt;/h2&gt;
&lt;h3 id=&#34;11-结构体&#34;&gt;1.1 结构体&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;学生成绩，对于每一个学生，需要考察的一些信息，这就是现实问题
char Id[9];    //学号
char Name[15]; //姓名
int Age;      //年龄
double Score; //成绩
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要管理学生，每个学生要考虑的维度比较多，没有哪一种数据类型可以很好的刻画这种关系，此时就需要多个类型来共同定义，形成新的数据类型，也就是结构体！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct STUDENT_INFO { //结构体定义
    char Id[9];    
    char Name[15]; 
    int Age;      
    double Score; 
};

struct STUDENT_INFO a; //这个 a 就是结构体数据类型的一个实例，里面是包含那么几个变量的。
//结构体的长度是所有成员的长度之和
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结构体是 C 语言具有“自我扩充能力”的重要机制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C 语言的基本数据类型有七大类型，这些类型都是由 C 系统提前确定的；而结构体类型是由用户根据自身需要而定义的，是 C 系统本身不具备的，这是 C 语言革命性的一步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构体是对 C 语言数据类型的强力扩充！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：结构体的定义本身仅仅是“设计、蓝图”，并不占内存空间，当将其实例化后，这个实例才真正的占用存储空间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;. 运算符，结构体实例取其成员的运算符；&lt;/li&gt;
&lt;li&gt;-&amp;gt; 运算符，指向结构体实例的指针取其成员的运算符；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义结构体时，赋初值的初值顺序，必须保证与结构体中成员数据类型是一致的；&lt;strong&gt;两个完全一模一样的结构体实例，之间是可以进行赋值操作的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;12-共用体&#34;&gt;1.2 共用体&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;union TEST {
    int a;
    char b;
    double c;
}

union TEST a, *p = &amp;amp;a;
a.a  &amp;lt;==&amp;gt;  p-&amp;gt;a
a.b  &amp;lt;==&amp;gt;  p-&amp;gt;b
a.c  &amp;lt;==&amp;gt;  p-&amp;gt;c
//两边表达的是一个意思，就是取共用体成员的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;共用体的诸成员共同使用同一起始地址空间。&lt;/p&gt;
&lt;p&gt;共用体内存映像图：&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_jpg/iaumSdLKJXtTwZB8LiaRYnjhTUmBtEfnWeyTsxxOGM3WuAMNxJnWrHLKsib3PlicQiaCS9unF5UqPtibJ00TvkZhN39A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39;&gt;&lt;/div&gt;
&lt;p align=center&gt;(共用体内存映像图)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共用体空间大小取决于共用体中，长度最长的成员的长度。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;sizeof(union TEST)  -&amp;gt; 8B
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二-宏定义与用户自定义类型&#34;&gt;二、宏定义与用户自定义类型&lt;/h2&gt;
&lt;h3 id=&#34;21-宏定义&#34;&gt;2.1 宏定义&lt;/h3&gt;
&lt;p&gt;#define 标识符，被替换的信息（&lt;strong&gt;这里不能随便出现分号&lt;/strong&gt;）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define  PI  3.1415926
...
    a = PI * r * r; &amp;lt;=&amp;gt; a = 3.1415926 * r * r;

#define NUM 3+4
...
    a = NUM * 3 / NUM; &amp;lt;=&amp;gt; a = 3+4 * 3 / 3+4

//深入理解：只替换，不计算
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;宏替换不能改变运算量，就是简简单单的完全替换就好。&lt;/p&gt;
&lt;p&gt;宏替换被广泛使用的关键在于以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;提高程序的可维护性&lt;/strong&gt;：就是针对同一个数字，可能在代码中多次出现，为了方便修改，上面用个宏替换，可以达到只修改一处，其他的地方都被修改的好处。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高程序的可读性&lt;/strong&gt;：用宏替换，便于理解每一个数字所代表的人文化含义，可以知道代表的是什么意思。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;神仙数字&lt;/strong&gt;：是指在程序中出现的常量数值，尤其是整型常量数值，一看根本不知道是啥意思，没有任何代表含义的数字。&lt;/p&gt;
&lt;h3 id=&#34;22-用户自定义类型&#34;&gt;2.2 用户自定义类型&lt;/h3&gt;
&lt;p&gt;typedef 是关键字；&lt;/p&gt;
&lt;p&gt;格式：typedef  已有类型  新类型;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef int a, b, c;
//上述语句将产生 3 个新的数据类型，分别为：a, b, c
int n;  &amp;lt;=&amp;gt;  a n;  //此时 a 就代表 int 数据类型

#define DI int *
typedef int * TI; //这条语句所产生的新类型是 TI，其对应的数据类型是 int *
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实用define、typedef 声明新的数据类型，两者在碰到指针、数组、以及结构体时，所体现的情况均不一样，一定要小心分析这些情况，尽量用 typedef 声明你想要的新数据类型，具体的在 C 语言进阶中写。&lt;/p&gt;
&lt;h2 id=&#34;三-动态存储分配&#34;&gt;三、动态存储分配&lt;/h2&gt;
&lt;h3 id=&#34;31-静态存储分配&#34;&gt;3.1 静态存储分配&lt;/h3&gt;
&lt;p&gt;以前所定义的变量，数组统统属于静态存储分配方式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a, b[50];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在源程序级别，用静态存储分配定义的变量和数组，其空间大小一经定义，终生不变！所以说是“静态”的，这使得程序的适应性受到了极大的限制。&lt;/p&gt;
&lt;p&gt;我此时希望代码在运行的过程中，根据我们临时需要，“动态”地申请存储空间。&lt;/p&gt;
&lt;h3 id=&#34;32-动态存储分配&#34;&gt;3.2 动态存储分配&lt;/h3&gt;
&lt;p&gt;动态存储分配是通过两个函数完成的：malloc() 和 free()，前者用来申请空间，后者用来释放空间。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;malloc.h&amp;gt;

int *p;
p = (int *)malloc(1000); //申请了 1000B 空间，也就是 250 个 int 元素的数组
//到了这里，C 语言的数组彻底失去它存在的意义！
free(首地址);  //释放以 p 的值为首地址的空间。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;33-举-2-个例子&#34;&gt;3.3 举 2 个例子&lt;/h3&gt;
&lt;h4 id=&#34;331-案例-1&#34;&gt;3.3.1 案例 1&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;malloc.h&amp;gt;
  
int *p; i;
for (i = 0; i &amp;lt; 3; i++) {
    p = (int *)malloc(sizeof(int) * 30);
}
...

for (i = 0; i &amp;lt; 3; i++) {
    free(p);  //释放以 p 的值为首地址的空间
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多次申请空间，将所得到的空间的首地址赋值给 p 变量；由于赋值的特点是覆盖，因此，最终 p 变量中仅保持了最后一次申请得到的空间的首地址，以前所申请空间的首地址被覆盖了（遗失了）；使得那些空间不但不能再使用，甚至还不能释放！这称为“内存泄露”！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;free(p) 进行了多次对同一首地址空间的释放操作，这是致命的运行时错误！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;332-案例-2&#34;&gt;3.3.2 案例 2&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;malloc.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
 
int *fun() {
    int a[20];  //动态存储分配将不会出现以下的问题

    return a;
}

int main (void) {
    int *p1;

    p1 = fun();
    free(p1);
}
&lt;/code&gt;&lt;/pre&gt;
">（C语言）结构体、共同体、动态存储分配</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/c-yu-yan-jie-gou-hua-cheng-xu-she-ji/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E4%B8%89%E7%A7%8D%E7%BB%93%E6%9E%84&#34;&gt;一、三种结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84&#34;&gt;1.1 顺序结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84&#34;&gt;1.2 选择结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84&#34;&gt;1.3 循环结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#131-while-%E5%BE%AA%E7%8E%AF&#34;&gt;1.3.1 while 循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#132-dowhile&#34;&gt;1.3.2 do...while&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#133-for-%E5%BE%AA%E7%8E%AF&#34;&gt;1.3.3 for 循环&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E4%B8%89%E6%AD%A5%E8%B5%B0%E6%88%98%E7%95%A5&#34;&gt;二、三步走战略&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%E7%AC%AC%E4%B8%80%E6%AD%A5&#34;&gt;2.1 第一步&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%E7%AC%AC%E4%BA%8C%E6%AD%A5&#34;&gt;2.2 第二步&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5&#34;&gt;三、编程实践&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%E4%B8%80%E4%B8%AA%E6%95%B0%E5%88%86%E8%A7%A3%E4%B8%BA%E5%85%B6%E8%B4%A8%E5%9B%A0%E5%AD%90%E4%B9%8B%E7%A7%AF%E7%9A%84%E5%BD%A2%E5%BC%8F&#34;&gt;3.1 一个数分解为其质因子之积的形式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%E7%94%A8-c-%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%8F%B1%E5%BD%A2%E5%9B%BE%E6%A1%88&#34;&gt;3.2 用 C 语言代码实现菱形图案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33-%E7%94%A8%E5%AE%9A%E7%A7%AF%E5%88%86%E6%9E%81%E9%99%90%E5%AE%9A%E4%B9%89%E8%AE%A1%E7%AE%97-0-%E5%88%B0-180-%E5%BA%A6%E4%B9%8B%E9%97%B4sinx-%E4%B8%8E%E6%A8%AA%E8%BD%B4%E6%89%80%E5%9B%B4%E6%88%90%E7%9A%84%E9%9D%A2%E7%A7%AF&#34;&gt;3.3 用定积分极限定义计算 0 到 180 度之间，sin(x) 与横轴所围成的面积&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E5%BC%BA%E8%B0%83%E5%87%A0%E7%82%B9&#34;&gt;四、强调几点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94%E8%AF%B4%E6%98%8E&#34;&gt;五、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;连着写了好几篇的非技术文章了，今天写写技术文章，两者穿插着写，&lt;strong&gt;三步走战略、五大能力体系、思维、打法&lt;/strong&gt;，在每一篇文章中都会体现，重在思考、理解，C 语言真的值得每一个程序员去学学，重在编程思想与编程哲学。&lt;/p&gt;
&lt;p&gt;不是我技术文章更新较慢，而是一些能力、思维的提升比较重要，这种是大的战略方向，意识必须给到位，而且关于这方面还有许多要写的。&lt;/p&gt;
&lt;h2 id=&#34;一-三种结构&#34;&gt;一、三种结构&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用工程化思想，指导程序设计的过程。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;很重要的一个思想：&lt;strong&gt;模块化；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;模块化程序的特点：&lt;strong&gt;单入口、单出口；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模块与模块之间的三种关系（必须非常熟练的掌握、理解）：顺序结构、分支结构（选择结构）、循环结构，这三种结构基本上构成了模块的框架。&lt;/p&gt;
&lt;h3 id=&#34;11-顺序结构&#34;&gt;1.1 顺序结构&lt;/h3&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_jpg/iaumSdLKJXtSCialDqcncib9nPFgPh6RsGDNsgB2owJbfiboxzFfyDZE8UgOYdBXCgVuzE26ho7b9cu4lBELr7dznQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39;&gt;&lt;/div&gt;
&lt;p align=center&gt;(顺序结构)&lt;/p&gt;
&lt;p&gt;从上往下执行每一条代码，机器严格的按照指令走，没有选择、没有循环，是最简单的结构。&lt;/p&gt;
&lt;h3 id=&#34;12-选择结构&#34;&gt;1.2 选择结构&lt;/h3&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_jpg/iaumSdLKJXtSCialDqcncib9nPFgPh6RsGDUB4qbRqsqEQKRacGg8TS4aRJ5Ild2w7y5d2HAXGnl2UjoWSBcbeQPA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39;&gt;&lt;/div&gt;
&lt;p align=center&gt;(选择结构)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if(条件表达式)
    语句 1 
else
    语句 2

if(条件表达式)
    语句 1

if ... else ...   或者 if ... 语句，也是必须掌握的，很简单的。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if 后面的 ()，坚决不能丢；&lt;/li&gt;
&lt;li&gt;if 和 else，只控制其后的一条语句；若需要控制多条语句，则必须用 {} 将这些语句括起来，称为一条 “复合语句”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-循环结构&#34;&gt;1.3 循环结构&lt;/h3&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_jpg/iaumSdLKJXtSCialDqcncib9nPFgPh6RsGDlNmX13ichMSuELiamzWxibdsQIcye5ZKTX0E7Oe44enAWoQKHzoJqhVYQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39;&gt;&lt;/div&gt;
&lt;p align=center&gt;(循环结构)&lt;/p&gt;
&lt;h4 id=&#34;131-while-循环&#34;&gt;1.3.1 while 循环&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;while(条件表达式){
    循环体;
    步长;
}

循环体最少执行 0 次，最多执行无数次。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;132-dowhile&#34;&gt;1.3.2 do...while&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;do 
    循环体;
while(条表);  

do ... while... 这个循环一般不使用。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;133-for-循环&#34;&gt;1.3.3 for 循环&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for(初值; 条表; 步长){
    循环体;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;while、for 循环用的比较多，三要素：&lt;strong&gt;初值、条件、步长&lt;/strong&gt;，必须明确。&lt;/p&gt;
&lt;p&gt;这三种结构，只要掌握了 C 的，对于其他语言都是类似的，&lt;strong&gt;一定要以技术的深度为主，熟练的掌握一门，编程思想到位了，其他都不是问题，再将技术进行横向的扩展，由易入难，由深入广的打法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个核心观点：我们写的程序，通过指令，转换为机器能识别的是 0 和 1，机器是严格的按照指令执行，最终实现我们预期的任务。&lt;/p&gt;
&lt;h2 id=&#34;二-三步走战略&#34;&gt;二、三步走战略&lt;/h2&gt;
&lt;h3 id=&#34;21-第一步&#34;&gt;2.1 第一步&lt;/h3&gt;
&lt;p&gt;当我们面对一个编程问题，不要急于动手去敲，三步走：&lt;strong&gt;输入 + 处理 + 输出；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入是什么？中间怎么处理？最终的输出结果又是什么？&lt;/p&gt;
&lt;p&gt;想清楚了，再动手去实现，那就很简单了。&lt;/p&gt;
&lt;h3 id=&#34;22-第二步&#34;&gt;2.2 第二步&lt;/h3&gt;
&lt;p&gt;三步走：&lt;strong&gt;分而治之  + 变量跟踪 + 换位思考；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分而治之&lt;/strong&gt;：问题再大，也要学会需求拆解，细化，能否把问题拆的足够好，充分的反映了一个人编程经验以及技术能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量跟踪&lt;/strong&gt;：在编写程序到某一模块，必须把自己当成机器，去一步一步的追踪各个变量的值的变化过程，从而得出程序的功能！查找程序错误也是这样做的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;换位思考&lt;/strong&gt;：在编程的过程中，需要不停的在 “开发者” 和 “程序的使用者(用户)”之间的角色转换，以决定程序的编写方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;明确了三步走的打法，以及编程前的准备，再动手去敲，去思考，养成良好的编程习惯是受益终生的，这种思维不仅仅在编程、在其他领域都是受益的，因为能力的提升才是你的资本。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要学的是怎么思考，怎么分析，怎么去实现，把这些能力提升起来。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;三-编程实践&#34;&gt;三、编程实践&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;说的再多，分析的再清楚，你不去一行一行、一个字母一个字母敲出来，是不起任何作用的&lt;/strong&gt;，我当年初学编程的时候，是一个字母一个字母的敲，没用什么代码补全工具，这个很锻炼我的编码能力与代码的认知感觉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动手追踪：对于要实现的相关程序，必须自己动手，通过手工实现一些例子；再手工实现的过程中，去寻找、概况、总结在这过程中的一般性规律，而程序就是对这个规律的精准描述。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动手追踪的能力一定要培养起来，要勤快起来，不能偷懒的光看，脑子要多想，多动手画、敲。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面通过代码实现三个 C 语言的例子，加深学习和理解。&lt;/p&gt;
&lt;h3 id=&#34;31-一个数分解为其质因子之积的形式&#34;&gt;3.1 一个数分解为其质因子之积的形式&lt;/h3&gt;
&lt;p&gt;手工的在纸上画一下，怎么分解，找出规律，用代码实现即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include&amp;lt;stdio.h&amp;gt;

void main(void)
{
    int num;
    int i;
    int n;

    printf(&amp;quot;请输入一个数：&amp;quot;);
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;num);
    n = num;

    printf(&amp;quot;%d = &amp;quot;, num);
    for(i = 2; n &amp;gt; 1;)
      if(n%i == 0)
      {
        printf(&amp;quot;%d&amp;quot;, i);
        if(n != i)
          printf(&amp;quot;*&amp;quot;);
        n /= i;
      }
      else
        i++;

    printf(&amp;quot;\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gcc test.c -o test&lt;/li&gt;
&lt;li&gt;./test&lt;/li&gt;
&lt;/ul&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_jpg/iaumSdLKJXtSCialDqcncib9nPFgPh6RsGDdnU5dyPk0AyujuFX7ic3kLdeKJ5SzmBc46x40uQ6zJwCx0aQfk8HuUg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39;&gt;&lt;/div&gt;
&lt;p align=center&gt;(运行结果)&lt;/p&gt;
&lt;h3 id=&#34;32-用-c-语言代码实现菱形图案&#34;&gt;3.2 用 C 语言代码实现菱形图案&lt;/h3&gt;
&lt;p&gt;要观察这些星星的个数是怎么变化的，用笔在纸上画，找出规律。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;math.h&amp;gt;
 
void main(void)
{
    int n, i, j;
 
    printf(&amp;quot;请输入行数（奇数）:&amp;quot;); //因为是菱形，所以必须为奇数行
    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);

    for(i = 0; i &amp;lt; n; i++)
    {
      for(j = 0; j &amp;lt; abs(n/2 - i); j++)
        printf(&amp;quot; &amp;quot;);
      for(j = 0; j &amp;lt; 2 * (n/2 - abs(n/2 -i)) + 1; j++)
        printf(&amp;quot;*&amp;quot;);
      printf(&amp;quot;\n&amp;quot;);
    }

    printf(&amp;quot;\n&amp;quot;); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gcc test.c -o test&lt;/li&gt;
&lt;li&gt;./test&lt;/li&gt;
&lt;/ul&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_jpg/iaumSdLKJXtSCialDqcncib9nPFgPh6RsGD1EZSozAibgseJLOzM6pfoxvCpc7T3HVLcEfIE4tagIbRtnRMVuTHwvw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39;&gt;&lt;/div&gt;
&lt;p align=center&gt;(运行结果)&lt;/p&gt;
&lt;h3 id=&#34;33-用定积分极限定义计算-0-到-180-度之间sinx-与横轴所围成的面积&#34;&gt;3.3 用定积分极限定义计算 0 到 180 度之间，sin(x) 与横轴所围成的面积&lt;/h3&gt;
&lt;p&gt;分析：很多人咋一看，很难啊，没思路，实现不了，你先自己想想，看看能不能用代码实现这个问题。&lt;/p&gt;
&lt;p&gt;其实，这个特别简单，C 语言入门级别，会点高数求极限，知道这个公式就可以了，遇到问题，认真的分析分析，这些都是最简单、最基础的，下面的图很清晰的表示了。&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_jpg/iaumSdLKJXtSCialDqcncib9nPFgPh6RsGDn6rBV1xO8etqEXMy0vZwWKMerdOjicakqs1eT5gpMLBrZAiamOhqBGhA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39;&gt;&lt;/div&gt;
&lt;p align=center&gt;(sin图形)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;math.h&amp;gt;
 
void main(void)
{
    double x, dx, s = 0;
 
    printf(&amp;quot;请输入Δx:&amp;quot;);
    scanf(&amp;quot;%lf&amp;quot;, &amp;amp;dx);

    for(x = 0; x &amp;lt;= 3.1415926; x += dx) //这块的3.1415926可以使用宏定义define
      s += sin(x) * dx;

    printf(&amp;quot;面积是：%lf\n&amp;quot;, s);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gcc test.c -o test&lt;/li&gt;
&lt;li&gt;./test&lt;/li&gt;
&lt;/ul&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_jpg/iaumSdLKJXtSCialDqcncib9nPFgPh6RsGDNvC2iaIU2N6FTzjUJu1ickekicUwgwVicmrukWoUDsGe7pJaYYSjZWcw9A/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39;&gt;&lt;/div&gt;
&lt;p align=center&gt;(运行结果)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学过高数的应该都懂，dx越小，求的极限越接近于真实面积，而极限本身就是这些小面积的求和，大学阶段：高数、概率论、线性代数、离散数学极为重要，对于搞算法的我们来说，非线性拟合问题，拟合函数，低阶高阶特征组合，各参数梯度计算，各个参数求偏导、等都是必备的，没有扎实的数学功底，如何能成为一个优秀的程序员呢？&lt;/strong&gt;&lt;/p&gt;
">（C语言）结构化程序设计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/c-yu-yan-han-shu/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&#34;&gt;一、基本概念&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB&#34;&gt;1.1 函数的分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E6%AD%A5%E9%AA%A4&#34;&gt;1.2 函数的产生和使用过程（步骤）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#121-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E&#34;&gt;1.2.1 函数声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#122-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89&#34;&gt;1.2.2 函数定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#123-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8&#34;&gt;1.2.3 函数调用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82&#34;&gt;二、形参与实参&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82%E7%9A%84%E5%AE%9A%E4%B9%89&#34;&gt;2.1 形参与实参的定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB&#34;&gt;2.2 形参与实参之间的关系&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#221-4-%E4%B8%AA%E5%85%B3%E7%B3%BB&#34;&gt;2.2.1 4 个关系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#222-%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F&#34;&gt;2.2.2 私有变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#223-%E5%BD%A2%E5%8F%82%E4%B8%8D%E8%83%BD%E4%BF%AE%E6%94%B9%E5%AE%9E%E5%8F%82%E7%9A%84%E5%80%BC&#34;&gt;2.2.3 形参不能修改实参的值&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E5%87%BD%E6%95%B0%E7%89%B9%E7%82%B9&#34;&gt;三、函数特点&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-c-%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%A6%81%E7%89%B9%E7%82%B9&#34;&gt;3.1 C 语言函数的重要特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%E6%8C%87%E9%92%88%E7%9A%84%E7%94%B1%E6%9D%A5&#34;&gt;3.2 指针的由来&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E5%8F%98%E9%87%8F%E7%94%9F%E5%91%BD%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F&#34;&gt;四、变量生命域与作用域&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F&#34;&gt;4.1 全局变量与局部变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42-%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B&#34;&gt;4.2 变量存储类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94%E5%87%BD%E6%95%B0%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98&#34;&gt;五、函数遗留问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AD%E8%AF%B4%E6%98%8E&#34;&gt;六、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一-基本概念&#34;&gt;一、基本概念&lt;/h2&gt;
&lt;p&gt;C 语言是一个函数语言，函数相当于”工厂“，具有”来料加工“的能力。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;sqrt(2.0);
//sqrt()函数，接收 2.0 这个来料，并把它加工成 1.414...这样的结果；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;11-函数的分类&#34;&gt;1.1 函数的分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;按 main() 和其它函数：主函数、其它函数&lt;/li&gt;
&lt;li&gt;按作者分：系统函数（库函数）、用户自定义函数（我们自己写的）；无论是库函数，还是用户自定义函数，其产生过程和调用，都应遵循相同的编程原则；&lt;/li&gt;
&lt;li&gt;按函数调用关系分：主调函数、被调函数；&lt;/li&gt;
&lt;li&gt;函数按参数个数划分：定参函数、不定参函数；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定参函数，参数个数固定；不定参函数，参数个数不确定；定参函数又分为有参函数和无参函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&amp;quot;%d%d%d&amp;quot;, a, b, c);  //4 个参数
printf(&amp;quot;Hello\n&amp;quot;);  //1 个参数
//所以 printf() 是一个不定参函数
//若函数无参，则可以用 void 加以明确声明
void main(void){}  //名称为 main 的函数，无返回值，无参数
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-函数的产生和使用过程步骤&#34;&gt;1.2 函数的产生和使用过程（步骤）&lt;/h3&gt;
&lt;p&gt;函数声明 + 函数定义 + 函数调用三个方面来展开描述。&lt;/p&gt;
&lt;h4 id=&#34;121-函数声明&#34;&gt;1.2.1 函数声明&lt;/h4&gt;
&lt;p&gt;(1)、确定的函数名称，函数名称是用以区分其它函数的标志，是这个函数的”入口“地址常量。&lt;/p&gt;
&lt;p&gt;(2)、返回值类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;说明函数的返回值类型，sqrt(2.0) 的计算结果为 1.414，这个 1.414 就是所谓的返回值；&lt;/li&gt;
&lt;li&gt;函数可以没有返回值，此时该函数返回值类型必须明确的写成：void；&lt;/li&gt;
&lt;li&gt;返回值是由被调函数返回给主调函数的数值；函数若有返回值，最多只能有一个返回值；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(3)、说明函数的参数，参数个数以及每个参数的数据类型；函数在声明时，可以只说明参数类型，而缺省相关变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int fun(int n);
int fun(int);
//以上函数声明都是正确的；
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;122-函数定义&#34;&gt;1.2.2 函数定义&lt;/h4&gt;
&lt;p&gt;就是函数的编程，实现函数的功能，主要包含函数首部和函数体；函数首部包括：函数返回值类型、函数名称、以及形参。&lt;/p&gt;
&lt;p&gt;函数体是由 {} 括起来的语句组成。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int fun(int m){}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;(1)、void：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若函数明确声明不是 void，则该函数必须以 {return 表达式;} 语句结束，并且，表达式类型必须与函数的返回值类型完全一致！&lt;/li&gt;
&lt;li&gt;若函数返回值为 void，则可以写 return; 语句结束，也可以缺省这条语句。&lt;/li&gt;
&lt;li&gt;特别强调：return (表达式); 这样的写法，在概念上是一种坏习惯，在 C 语言中，xxx() 出现，代表的是对 xxx() 函数的调用，上面的写法好像就是在说 return 是函数名称，而实际上，return 是关键字！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(2)、关于 return&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它是函数运行结束的语句，在这条语句后出现的任何其它语句，是绝对不会运行到的。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if (条件) {
    return ;
}
语句1;
//明显，只有条件不成立，才能执行语句1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所谓的函数运行结束的 return(返回)，是“返回”到调用它的函数的下一条语句继续执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所谓的 return 表达式; 意思是，返回到主调函数，并用“表达式”的值，替代主调函数中，关于这个函数的调用部分内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;123-函数调用&#34;&gt;1.2.3 函数调用&lt;/h4&gt;
&lt;p&gt;看一个函数调用的代码示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
 
int add (int a, int b);   //函数声明
int add (int a, int b) {  //函数定义
    return a + b;
}
int main (void) {
    int a;
    int b;
    int sum;

    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
    sum = add(a, b);  //函数调用

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二-形参与实参&#34;&gt;二、形参与实参&lt;/h2&gt;
&lt;h3 id=&#34;21-形参与实参的定义&#34;&gt;2.1 形参与实参的定义&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;形参出现在函数定义的“函数首部”的括号中；&lt;/li&gt;
&lt;li&gt;实参出现在函数调用的括号中；&lt;/li&gt;
&lt;li&gt;实参有三种形式：常量、变量、表达式；&lt;/li&gt;
&lt;li&gt;形参只有一种形式：变量；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int fun (int num);
int fun (int num) {  //这个 num 就是形参   这块是函数定义
    ...
}
 
int main (void) {
    int a;

    a = fun(5);  //这个 5 就是实参   这块是函数调用
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;形参只有变量这一种形式，不可能出现常量，甚至不可能出现数组！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;22-形参与实参之间的关系&#34;&gt;2.2 形参与实参之间的关系&lt;/h3&gt;
&lt;h4 id=&#34;221-4-个关系&#34;&gt;2.2.1 4 个关系&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;个数一致；&lt;/li&gt;
&lt;li&gt;按位置关系必须对应；&lt;/li&gt;
&lt;li&gt;数据类型必须一致；&lt;/li&gt;
&lt;li&gt;之间是值进行传递；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;将实参表达式的值，复制一份，赋值给形参变量！&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;222-私有变量&#34;&gt;2.2.2 私有变量&lt;/h4&gt;
&lt;p&gt;在一个函数的函数体中定义的变量，以及该函数的所有形参变量，都是这个函数的私有变量。&lt;/p&gt;
&lt;p&gt;一个函数只能使用、调用这个函数的私有变量和“公有变量”，绝对不能直接使用其它函数的私有变量（包括数组）。&lt;/p&gt;
&lt;p&gt;私有变量是在定义这个变量的函数被调用时，才申请存储空间；私有变量（尤其是形参变量）的空间，与其它函数的私有变量的空间，是没有任何关系的，即，其空间是独立申请的。&lt;/p&gt;
&lt;p&gt;私有变量将随着定义它的函数的运行结束，而释放其空间。&lt;/p&gt;
&lt;h4 id=&#34;223-形参不能修改实参的值&#34;&gt;2.2.3 形参不能修改实参的值&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;被调函数对形参变量所进行的任何修改，绝对不会更改与其对应的实参的值，这就是“值传递”的必然结果！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对形参变量所进行的任何修改，绝对不会更改实参表达式的值 ！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C 语言中，“指针”存在的理由：最核心的原因是 C 语言是一个函数语言，没有过程这个概念，就需要指针传变量的地址，才能对变量进行修改！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;三-函数特点&#34;&gt;三、函数特点&lt;/h2&gt;
&lt;h3 id=&#34;31-c-语言函数的重要特点&#34;&gt;3.1 C 语言函数的重要特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;高度的独立性：任何函数只能引用属于自己的私有变量和全局变量，绝对不能直接引用其它函数的私有变量；这意味着，不能在被调函数中，直接修改主调函数的私有变量的值；&lt;/li&gt;
&lt;li&gt;函数返回值最多只有一个，若需要通过被调函数同时得到多个结果，那是行不通的；&lt;/li&gt;
&lt;li&gt;函数的参数（实参与形参）的关系，在 C 语言函数中，只有一种：值传递（传递的是值，只不过这个值可能是普通的值，也可能是地址值），且这种传递方式所产生的必然结果是：对被调函数的形参变量所进行的任何更改，绝对不会影响主调函数的实参的值！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述三个特点，将对 C 语言函数的功能产生巨大的束缚：在上述情况存在的前提下，C 函数是无法实现：“同时更改主调函数中多个私有变量的值”的功能！&lt;/p&gt;
&lt;h3 id=&#34;32-指针的由来&#34;&gt;3.2 指针的由来&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;指针的概念，就是为了解决上述 C 语言“致命”问题而提出来的！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指针解决上述问题的具体方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将需要更改的变量(空间)的首地址作为实参；&lt;/li&gt;
&lt;li&gt;被调函数对应的形参变量必须是上述变量的指针类型进行接收，这将使被调函数的形参变量“指向”主调函数中，需要更改的那个变量；&lt;/li&gt;
&lt;li&gt;在被调函数中，通过 * （指向）运算，间接地修改主调函数相关变量的值；&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void fun (int *);
void fun (int *num) {
    *num = 5;  //通过指针修改 a 空间的值，进行了指向运算 
}

int main (void) {
    int a = 6;

    fun(&amp;amp;a);  //传的是 a 空间的地址
    printf(&amp;quot;%d\n&amp;quot;, a)  //输出的结果是 5
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四-变量生命域与作用域&#34;&gt;四、变量生命域与作用域&lt;/h2&gt;
&lt;h3 id=&#34;41-全局变量与局部变量&#34;&gt;4.1 全局变量与局部变量&lt;/h3&gt;
&lt;p&gt;(1)、全局变量的定义是在 {} 之外进行的；在 {} 之内定义的变量和所有的形参变量都是局部变量；&lt;/p&gt;
&lt;p&gt;(2)、全局变量能被那些在书写顺序上，其后定义的函数所引用；局部变量只能被定义它的函数所引用；&lt;/p&gt;
&lt;p&gt;(3)、全局变量的空间是在主函数运行之前申请的，且在主函数运行结束后（即，整个程序运行完毕后）才释放空间的；局部变量是在定义它的函数被调用时才申请空间，且随着函数运行结束而释放空间；&lt;/p&gt;
&lt;p&gt;(4)、全局变量在定义后赋值前，其值由 C 语言强制赋值为 0；局部变量在定义后赋值前，其值为垃圾；&lt;/p&gt;
&lt;p&gt;(5)、全局变量的使用，可使程序设计变得方便，但这种方便会带来函数之间“耦合”程度的增加，不利于大中型软件开发，不利于团队开发，也不利于软件的维护；全局变量的使用必须谨慎，这是《软件工程》思想所推荐的。&lt;/p&gt;
&lt;h3 id=&#34;42-变量存储类型&#34;&gt;4.2 变量存储类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;自动存储类：auto （可缺省）int a; &amp;lt;=&amp;gt; auto signed int&lt;/li&gt;
&lt;li&gt;静态存储类：static&lt;/li&gt;
&lt;li&gt;寄存器存储类：register&lt;/li&gt;
&lt;li&gt;外部存储类：extern&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(1)、自动存储类变量和静态存储类变量的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a;
static int b;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2)、静态存储类变量是在主函数运行前申请空间，且在整个程序运行结束后释放；自动存储类变量是在定义它的函数被调用时才申请空间，且在定义它的函数运行结束后，释放其空间；&lt;/p&gt;
&lt;p&gt;(3)、静态存储类变量在定义后未赋值前，其值被 C 语言强行赋值为 0;自动存储类变量在定义后未赋值前，其值为垃圾值；&lt;/p&gt;
&lt;p&gt;(4)、静态存储类变量，如果是局部变量，则只能被定义它的函数所引用；&lt;/p&gt;
&lt;p&gt;(5)、若某函数被多次调用，且该函数定义有静态存储类变量；则，在调用该函数结束后，它所定义的自动存储类变量的空间都被释放，而静态存储类变量的空间是不释放的；在下一次该函数被调用时，静态存储类空间的值是在上一次调用结束的基础上进行再一次引用的，因此，静态存储类变量具有“累加”效应。&lt;/p&gt;
&lt;h2 id=&#34;五-函数遗留问题&#34;&gt;五、函数遗留问题&lt;/h2&gt;
&lt;p&gt;一维数组名称作为实参、二维数组名称作为实参，形参该以何种数据类型接收的呢？又怎么使用呢？&lt;/p&gt;
&lt;p&gt;函数的递归调用，也就是常见的递归算法有哪些条件呢？递归又该如何实现？有哪些应该的场景需要递归呢？&lt;/p&gt;
&lt;p&gt;在操作系统底层源码中好多写法就是函数指针，指向函数的指针，那么指针函数和函数指针又该怎么理解呢？怎么使用呢？&lt;/p&gt;
&lt;p&gt;针对这些遗留问题，有兴趣的可以自己先去思考、去学习，去研究，我在写 C 进阶之旅的时候，都会写到。&lt;/p&gt;
&lt;p&gt;本篇文章仅仅是把 C 语言的函数带入门，以及说明了为什么要有指针，指针的出现就是为了函数中的传参，学习 C 语言之旅，路还很长，琢磨透彻，在敲代码实现，总会有进步的！&lt;/p&gt;
">（C语言）函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/c-yu-yan-chang-liang-he-bian-liang/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E5%B8%B8%E9%87%8F&#34;&gt;一、常量&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%E6%95%B4%E5%9E%8Bintshortlong&#34;&gt;1.1 整型（int、short、long）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%E6%B5%AE%E7%82%B9%E5%9E%8Bfloatdouble&#34;&gt;1.2 浮点型（float、double）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F&#34;&gt;1.3 字符常量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F&#34;&gt;1.4 字符串常量&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8Cascii%E7%A0%81%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A&#34;&gt;二、ASCII码知识普及&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E5%8F%98%E9%87%8F&#34;&gt;三、变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E8%AF%B4%E6%98%8E&#34;&gt;四、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一-常量&#34;&gt;一、常量&lt;/h2&gt;
&lt;p&gt;常量：写 C 程序的时候，在源程序文件中表达不变的量的各种 “合法” 的书写方式。&lt;/p&gt;
&lt;h3 id=&#34;11-整型int-short-long&#34;&gt;1.1 整型（int、short、long）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;十进制：是以数字 0-9 组成的整数，eg：123、5、0、-23 等；&lt;/li&gt;
&lt;li&gt;八进制：是以数字 0-7 组成，并且是以 0 开头的整数，eg：014、-012；&lt;/li&gt;
&lt;li&gt;十六进制：是以 0-9 和 a-f/A-F 组成，以 0x 或者 0X 开头额整数，eg：0x41、0XAc；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-浮点型float-double&#34;&gt;1.2 浮点型（float、double）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在 32 位系统下，默认浮点类型为：float；&lt;/li&gt;
&lt;li&gt;在 64 位系统下，默认浮点类型为：double；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;科学计数法：aeb，其中 a 必须是整型或者小数，b 必须是整型，e 可以用 E，eg：3e-2 的意思是：3 * 10^-2 = 0.03。&lt;/p&gt;
&lt;h3 id=&#34;13-字符常量&#34;&gt;1.3 字符常量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可以写字符：&#39;A&#39;、&#39;0&#39;、&#39;a&#39;；&lt;/li&gt;
&lt;li&gt;可以直接描述其ASCII码：65、32、97 （下面普及 ASCII 码）；&lt;/li&gt;
&lt;li&gt;八进制、十六进制均可以表示字符常量，分别为：&#39;\ &#39;、&#39;\x&#39;；&lt;/li&gt;
&lt;li&gt;转义字符：就是针对有歧义的字符，避免出现二义性，C 语言引入了一个机制：在 \ 的后面， 写一个字符，就可以表达特定的字符本身含义；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg：&#39; &amp;lt;&lt;mark&gt;&amp;gt; &#39;&#39;&#39; ，这样才能表示出是一个单引号的意思；\ &amp;lt;&lt;/mark&gt;&amp;gt; &#39;\&#39;，这样才能表示出一个 \ 的意思。&lt;/p&gt;
&lt;h3 id=&#34;14-字符串常量&#34;&gt;1.4 字符串常量&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在&amp;quot; &amp;quot;里所表达的都是字符串常量，叫做字符串常量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;quot;ABC&amp;quot;、&amp;quot;\x41\x42\x43&amp;quot; (十六进制的字符串常量，其实只有 3 个字符)；&lt;/li&gt;
&lt;li&gt;字符串长度：不包括 &amp;quot; ，只数字符个数；&lt;/li&gt;
&lt;li&gt;&amp;quot;&amp;quot;：长度为 0 的字符串叫做，空串；&lt;/li&gt;
&lt;li&gt;&amp;quot; &amp;quot;：长度为 1 的空格串；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二-ascii码知识普及&#34;&gt;二、ASCII码知识普及&lt;/h2&gt;
&lt;p&gt;在计算机中，像汉字、字符是不可能存储的，计算机只认识 0 和 1，对于字符，计算机是通过点阵矩阵进行存储（一个英文字符将对应一个点阵信息），保存一个英文字符的点阵信息，需要 2 字节的存储空间。&lt;/p&gt;
&lt;p&gt;在计算机中，对字符的管理，是通过编号进行的，编号的三个原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;从 0 开始编号；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连续编号；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用二进制编号；&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对英文字符的点阵信息使用一个字节的低 7 位进行编号，这个编号就叫做：ASCII 码。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&#39; &#39; (32)：空格的 ASCII 码是 32&lt;/li&gt;
&lt;li&gt;&#39;0&#39; (48)：字符 0 的 ASCII 码是48&lt;/li&gt;
&lt;li&gt;&#39;A&#39; (65)：字符 A 的 ASCII 码是65&lt;/li&gt;
&lt;li&gt;&#39;a&#39; (97)：字符 a 的 ASCII 码是97&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ASCII 码 就是字符所对应的编号，看到 ASCII 码就等价于这个编号（数字），字符即数字。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符零：&#39;0&#39; ==&amp;gt; 48；&lt;/li&gt;
&lt;li&gt;零：0 ==&amp;gt; 0 ==&amp;gt;&#39;\0&#39;，这个是真正的 0；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于字符的大小比较，或者是字符串的大小比较，其实都是对其 ASCII 码进行比较，换为相应的编号，做减法即可。&lt;/p&gt;
&lt;p&gt;关于全角和半角：全角实质上就是中文点阵，占 2 字节，半角就是英文点阵，也就是 ASCII 码，占 1 字节，&lt;strong&gt;在 C 语言程序设计中，只能使用英文的标点，不得使用中文标点。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;三-变量&#34;&gt;三、变量&lt;/h2&gt;
&lt;p&gt;本质：内存中一段连续的存储空间，&lt;strong&gt;空间即变量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机表达信息的最小物理单位：一个二进制位（比特 bit）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1B = 8bit&lt;/li&gt;
&lt;li&gt;1KB = 1024B = 2^10B&lt;/li&gt;
&lt;li&gt;1MB = 1024KB = 2^20B&lt;/li&gt;
&lt;li&gt;1GB = 1024MB = 2^30B&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于内存的理解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;内存是由多个字节组成的一维、线性、连续存储空间；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;字节是内存分配存储空间的基本单位；&lt;/li&gt;
&lt;li&gt;对于内存中的多个字节，通过对字节(也就是内存空间 1B)进行唯一性的编号来管理；&lt;/li&gt;
&lt;li&gt;参与字节编号的二进制位数，将决定这个计算机所能管理的内存大小；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;变量的三个要素：&lt;/p&gt;
&lt;p&gt;变量名称：每个变量都必须起一个英文名，&lt;strong&gt;变量名称要能很清晰的代表其所表达的意思&lt;/strong&gt;，eg：成绩，用变量名：score。&lt;/p&gt;
&lt;p&gt;命名原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须以字母或者下划线(_)开头；&lt;/li&gt;
&lt;li&gt;只能由字母、数字、下划线字符组成；&lt;/li&gt;
&lt;li&gt;不能使用 &amp;quot;关键字&amp;quot; / 起名；&lt;/li&gt;
&lt;li&gt;C 语言区分大小写；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;变量类型：决定了该变量在内存中的大小（字节数）。&lt;/p&gt;
&lt;p&gt;变量的值：对该变量空间中进行一系列运算后，所得到的结果。&lt;/p&gt;
&lt;p&gt;定义变量的本质：&lt;strong&gt;申请存储空间&lt;/strong&gt;，变量的类型在定义时被确定，其终生不会改变，在标准 C 下面，变量必须先定义，后使用，&lt;strong&gt;定义变量的语句必须在所有的有效语句之前&lt;/strong&gt;，且定义变量不赋值，默认为垃圾值。&lt;/p&gt;
&lt;p&gt;int a = 0; 定义了一个 4 字节的存储空间，且初始值为 0，在内存角度，这 4 个字节紧挨着，也就是每个字节空间都为0x00，其十六进制为：0x00000000，数据类型和表达式下篇见。。。&lt;/p&gt;
&lt;p&gt;注意：常量和变量所占的内存空间是不一样的，一般常量在常量区，变量分配的空间在栈上，具体的内存四区有时间可以写。&lt;/p&gt;
">（C语言）常量和变量</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/yan-jiu-fang-ddos-gong-ji/"" data-c="
          &lt;h3 id=&#34;待更新&#34;&gt;待更新&lt;/h3&gt;
">（研究）防DDoS攻击</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/linuxri-zhi-ji-hua-ren-wu-zhu-ji-ming-xi-tong-shi-jian/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E6%97%A5%E5%BF%97&#34;&gt;一、日志&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1rsyslog%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6&#34;&gt;1、rsyslog日志文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB&#34;&gt;2、日志级别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E6%9F%A5%E7%9C%8Bsystemd%E6%97%A5%E5%BF%97&#34;&gt;3、查看systemd日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%E4%BF%9D%E5%AD%98systemd%E6%97%A5%E5%BF%97&#34;&gt;4、保存systemd日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8Cred-hat7%E4%B8%AD%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4&#34;&gt;二、Red Hat7中查看系统时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1&#34;&gt;三、计划任务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E4%B8%BB%E6%9C%BA%E5%90%8D&#34;&gt;四、主机名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94%E8%AF%B4%E6%98%8E&#34;&gt;五、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一-日志&#34;&gt;一、日志&lt;/h2&gt;
&lt;p&gt;进程和操作系统内核需要能够为发生的事情记录日志，这些日志可用于系统审核和问题的故障排除。按照管理，这些日志永久存储在/var/log。&lt;/p&gt;
&lt;p&gt;在Red Hat7版本中，有两个日志服务，分别是rsyslog和systemd-journal。&lt;/p&gt;
&lt;p&gt;systemd-journal是一种改进型的日志管理服务，可以收集来自内核、启动过程的早期阶段、标准输出、系统日志，以及守护进程启动和运行期间错误的消息。它将这些消息写入到一个结构化事件中，默认情况向下并不会持久化保存日志，每次重启之后，之前的日志都会丢失。另外，一些rsyslog无法收集的日志也会被写入systemd-journal。&lt;/p&gt;
&lt;h3 id=&#34;1-rsyslog日志文件&#34;&gt;1、rsyslog日志文件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;rsyslog把收集到的日志都记录在/var/log目录下的各个日志文件中。&lt;/strong&gt;&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbsehyp13PialMAOgiaKUKF6RdUng6OTcxHNgOL8xFJ0YUvawaWa3Yb6um0Y4UWT2Q6paZ2e8taun5WA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(常见的日志文件)&lt;/p&gt;
&lt;p&gt;systemctl status rsyslog   查看rsyalog服务是否运行；其配置文件在  /etc/rsyslog.conf，每一个日志类型，记录某一类的日志到某个文件中。&lt;/p&gt;
&lt;h3 id=&#34;2-日志级别&#34;&gt;2、日志级别&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;编号&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;优先级&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;严重性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;emerg&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;系统不可用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;alert&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;必须立即采取措施&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;crit&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;严重状况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;err&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;非常严重的错误状况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;warning&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;警告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;notice&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;正常但重要的事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;info&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;信息性事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;debug&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;调试级别消息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;查看rsyslog配置文件：vim /etc/rsyslog.conf。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;凡是修改过配置文件的，都必须重启。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-查看systemd日志&#34;&gt;3、查看systemd日志&lt;/h3&gt;
&lt;p&gt;查看systemd日志条目  专门的命令 journalctl。&lt;/p&gt;
&lt;p&gt;journalctl 用来查看所有的日志&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbsehyp13PialMAOgiaKUKF6RdAD4AGeGgpku7bau1PymSPLJn3Gxric2WFoIpvgu5vo9Fb3CLXmJD4ibQ/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(查看所有日志)&lt;/p&gt;
&lt;p&gt;journalctl -n [NUM] 默认显示最后10个日志条目&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbsehyp13PialMAOgiaKUKF6Rd3q4b8ZqwaZf13jUgR3DNDJRcMPUHqAAuO7kkWCutNeNyWZNYU9rItQ/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(查看最后10条日志)&lt;/p&gt;
&lt;p&gt;journalctl -p err  过滤日志级别输出&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbsehyp13PialMAOgiaKUKF6RdRiaWl4FF0WOx5lUxicoBMqRjXlCdSpZMQfuxyXStDwKVsdqeFvzibDRgg/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(日志级别过滤输出)&lt;/p&gt;
&lt;p&gt;还可以输出具体时间范围，两个选项-since和-until，接受的时间格式为YYY-MM-DD hh:mm:ss,如果省略日期，则命令会假定为当天的日期；如果省略时间，则假定为00:00:00，除了具体的日期时间外，这两个选项还接受yesterday，today，tomorrow。&lt;/p&gt;
&lt;h3 id=&#34;4-保存systemd日志&#34;&gt;4、保存systemd日志&lt;/h3&gt;
&lt;p&gt;一般情况下保存在/etc/log/journal,这样就可以实现持久化systemd日志，但是默认情况下只会保存一个月的日志信息，可在配置文件/etc/systemd/journald.conf中调节。&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbsehyp13PialMAOgiaKUKF6RdcZXI8USfnFxTPGWQaN1DAic0pIRLibW8lVp8mcfCbTFZlnOEt7Zibz19g/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(默认保存一个月)&lt;/p&gt;
&lt;h2 id=&#34;二-red-hat7中查看系统时间&#34;&gt;二、Red Hat7中查看系统时间&lt;/h2&gt;
&lt;p&gt;配置文件在/etc/chrony.confz中。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;timedatectl&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查看系统时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;timedatectl list-timezones&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;列出时区信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;timedatectl set-timezone Asia/Shanghai&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置时区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;timedatectl set-time 22:19:00[YYY-MM-DD hh:mm:ss]&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置时间日期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;timedatectl set-ntp[true&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;false]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;三-计划任务&#34;&gt;三、计划任务&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在未来的某个时间点执行一次某任务，相关命令：at  比较简单，不再多说。&lt;/li&gt;
&lt;li&gt;周期性的执行某任务
&lt;ul&gt;
&lt;li&gt;cron: 自身是一个不间断运行的服务；&lt;/li&gt;
&lt;li&gt;对cron任务来说，分两类：系统cron任务，与用户无关，是系统周期性的维护，格式：分钟 小时 日 月 周 用户 任务；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用户cron任务：通常定义在/var/spool/cron/USERNAME目录下，格式：分钟 小时 日 月 周 任务。&lt;/p&gt;
&lt;p&gt;时间的有效值：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分钟   0-59&lt;/p&gt;
&lt;p&gt;小时   0-23&lt;/p&gt;
&lt;p&gt;日    1-31&lt;/p&gt;
&lt;p&gt;月    1-12&lt;/p&gt;
&lt;p&gt;周    0-7 :0和7都表示周日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;时间通配符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;*   对应的所有有效值&lt;/li&gt;
&lt;li&gt;\，  离散时间点取值&lt;/li&gt;
&lt;li&gt;-   连续的时间点&lt;/li&gt;
&lt;li&gt;/   对应取值范围内每多久一次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用户cron任务的管理，crontab该命令可以实现对语法的检测：&lt;/p&gt;
&lt;p&gt;选项|解释&lt;br&gt;
-l|列出当前用户的cron任务&lt;br&gt;
-e|编辑当前用户的cron任务&lt;br&gt;
-r|移除所有的cron任务&lt;br&gt;
-u USERNAME|管理其他用户的cron,只有root可用&lt;/p&gt;
&lt;h2 id=&#34;四-主机名&#34;&gt;四、主机名&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;hostname   查看主机名；&lt;/li&gt;
&lt;li&gt;hostname &amp;quot;HOSTNAME&amp;quot;   临时修改主机名；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;静态主机名保存在/etc/hostname文件中，hostnamectl可以修改此文件。&lt;/p&gt;
&lt;p&gt;hostnamectl set-hostname HOSTNAME   永久修改主机名；&lt;/p&gt;
&lt;p&gt;有个名称解析：用于将主机名转换为IP地址，反之亦可。&lt;/p&gt;
">（Linux）日志、计划任务、主机名、系统时间</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/linuxyong-hu-huan-jing/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3&#34;&gt;一、核心思想&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E5%87%A0%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5&#34;&gt;1、几个核心概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6&#34;&gt;2、目录与文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&#34;&gt;3、常用命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E8%AF%B4%E6%98%8E&#34;&gt;二、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;书籍推荐：《鸟哥的Linux私房菜》&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一-核心思想&#34;&gt;一、核心思想&lt;/h2&gt;
&lt;h3 id=&#34;1-几个核心概念&#34;&gt;1、几个核心概念&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&amp;quot;一切皆文件&amp;quot;&lt;/li&gt;
&lt;li&gt;Linux下是不区分扩展名的，Linux下扩展名是给人看的，其扩展名随便给，无关紧要；但为了自己好区分，还是最好写清楚。&lt;/li&gt;
&lt;li&gt;Linux下是对大小写很敏感的，严格区分大小写。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;内核(Kernel)Shell、终端模拟器、X Window系统，以下就是交互的形式了&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbvwQbcQjRgH7JfiahUSLQt7z9exe6gydBkFVPCpFU8qoz56O8dLq3SCtwGpH3xW9bnU8nTGibaemGWg/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(linux内核交互)&lt;/p&gt;
&lt;p&gt;用户进程和内核通过shell进行交互，内核再跟硬件交互。&lt;/p&gt;
&lt;h3 id=&#34;2-目录与文件&#34;&gt;2、目录与文件&lt;/h3&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbvwQbcQjRgH7JfiahUSLQt7ziaBfq1ltZUCdXYAAoEp494jZUEIHrmYiann2KK8zcKLPKjyvk1SLqYiaA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(命令行解释)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;目录也是文件，Linux 下面一切皆文件&lt;/li&gt;
&lt;li&gt;相对路径：从当前目录出发；绝对路径：总是从根(/)目录下出发。&lt;/li&gt;
&lt;li&gt;文件：是数据存放的载体。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-常用命令&#34;&gt;3、常用命令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;基本格式：命令名 [选项] [参数]&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;帮助手册：指令 --help  man 指令  info 指令&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ls：列出当前目录下的列表信息 、-l 长格式  ls -l = ll、-a 隐藏文件、-i inode编号&lt;/li&gt;
&lt;li&gt;cd：转换路径&lt;/li&gt;
&lt;li&gt;cp: 拷贝文件   -r: 递归拷贝(目录)  ./*:拷贝其下的文件，当前的目录不拷贝。&lt;/li&gt;
&lt;li&gt;mv: 移动或从命名&lt;/li&gt;
&lt;li&gt;touch: 创建文件或更新文件时间&lt;/li&gt;
&lt;li&gt;mkdir: 创建新目录&lt;/li&gt;
&lt;li&gt;rmdir: 删除空目录&lt;/li&gt;
&lt;li&gt;rm: 删除目录或文件 -r(递归目录) -f(强制删除)&lt;/li&gt;
&lt;li&gt;pwd: 查看当前完整路径&lt;/li&gt;
&lt;li&gt;cat、more、less: 查看文件的内容&lt;/li&gt;
&lt;li&gt;date: 显示当前时间&lt;/li&gt;
&lt;li&gt;cal: 显示月历&lt;/li&gt;
&lt;li&gt;df: 显示磁盘用量  -h  字节方式&lt;/li&gt;
&lt;li&gt;du: 计算目录下文件占磁盘的大小  -h  字节方式&lt;/li&gt;
&lt;li&gt;head: 显示文件开头部分内容   -n 数字&lt;/li&gt;
&lt;li&gt;tail: 显示文件结尾部分内容  -n  数字&lt;/li&gt;
&lt;li&gt;file: 检查文件类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;离开系统命令：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重启：reboot、shutdown -r now、init 6&lt;/li&gt;
&lt;li&gt;关机：halt、shutdown -h now、poweroff、init 0&lt;/li&gt;
&lt;/ul&gt;
">（Linux）用户环境</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/linuxshou-hu-jin-cheng-he-yuan-cheng-deng-lu-fu-wu-qi/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80systemd&#34;&gt;一、systemd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4&#34;&gt;二、常见命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E9%85%8D%E7%BD%AE%E5%92%8C%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8&#34;&gt;三、配置和远程登录服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9Bscp-rsync&#34;&gt;四、scp rsync&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94%E8%AF%B4%E6%98%8E&#34;&gt;五、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一-systemd&#34;&gt;一、systemd&lt;/h2&gt;
&lt;p&gt;在Red Hat7版本中，系统启动和服务器进程由systemd进行管理；systemctl命令用于管理各种类型的systemd对象，它们称为单元。&lt;/p&gt;
&lt;p&gt;systemctl -t help 显示可用单元类型列表。一些常见的单元类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务单元具有.service扩展名&lt;/li&gt;
&lt;li&gt;套接字单元具有.socket扩展名&lt;/li&gt;
&lt;li&gt;路径单元具有.path扩展名&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二-常见命令&#34;&gt;二、常见命令&lt;/h2&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbtibue6vNKYstPLGSnVLvf5T7ZTeQ06gDa5Ug7RR6EewfDRUMNOfq9qyTRDicubIFOqay63icibIgAzpg/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(查看服务的状态)&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbtibue6vNKYstPLGSnVLvf5T17pIibZ0frelsUNysic6EZcqwPqcUMew1PWw2UT7dGK0vPMdiataZb6cw/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(查看是否开机启动)&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbtibue6vNKYstPLGSnVLvf5TVZsIkhs2iaQhkxiatKnfuFCzrhO2KAwcOCf6iaeEpnqmulzA63k0ujicRQ/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(列出服务的启动顺序)&lt;/p&gt;
&lt;p&gt;常见的systemctl控制命令：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;systemctl stop UNIT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;停止一项服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;systemctl start UNIT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;启动一项服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;systemctl restart UNIT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重启服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;systemctl reload unit&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重新加载服务的配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;systemctl mask UNIT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;禁用服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;systemctl unmask UNIT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务变为可用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;systemctl enable UNIT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;开机自动启动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;systemctl disable UNIT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;禁止服务开机自启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;systemctl list-dependencies UNIT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;列出指定单元的依赖关系&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;三-配置和远程登录服务器&#34;&gt;三、配置和远程登录服务器&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;w -f 显示当前登录到计算机的用户列表。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于秘钥的登录：ssh 用户名@IP，ssh-keygen   ：生成私钥对，私钥文件：~/.ssh/idrsa  公钥文件：~/.ssh/idrsa。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub 用户名@IP  :将公钥复制到远程服务器上，公钥信息将保存到远程服务器上相应用户的 ~/.ssh/authorized_keys文件中。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过以上三步，下次ssh 用户名@IP 就可以不用输入密码，进行基于密钥的登录。&lt;/p&gt;
&lt;p&gt;自定义SSH服务配置：SSHD的配置文件：/etc/ssh/sshd_config。&lt;/p&gt;
&lt;p&gt;可以设置只允许root用户登录ssh，也可以设置只允许root基于秘钥登录等……，但是设置完后必须重启：systemctl restart sshd。&lt;/p&gt;
&lt;h2 id=&#34;四-scp-rsync&#34;&gt;四、scp rsync&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;scp 命令 ：本地文件拷贝到远程/远程文件传输本地；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;scp 本地文件所在路径 用户名@IP：要存放的路径；&lt;/p&gt;
&lt;p&gt;scp 用户名@IP：文件路径 本机要存放的文件路径；&lt;/p&gt;
&lt;p&gt;注意：整个目录拷贝的话：-r 递归拷贝。&lt;/p&gt;
&lt;p&gt;了解：sftp 使用ssh加密文件传输，安全 sftp 用户@IP。&lt;/p&gt;
&lt;p&gt;rsync远程同步文件：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;选项&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-r&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同步整个目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-l&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;同步符号链接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-p&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;保留文件权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-t&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;保留文件时间戳信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-g&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;保留文件组所有权&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-o&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;保留文件所有者&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">（Linux）守护进程和远程登陆服务器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/linuxwen-jian-he-yong-hu-zu/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80linux-%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6&#34;&gt;一、Linux 系统文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90&#34;&gt;二、修改权限&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E5%A2%9E%E5%8A%A0%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84&#34;&gt;三、增加用户和用户组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E8%A1%A5%E5%85%85%E5%87%A0%E4%B8%AA%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4&#34;&gt;四、补充几个使用命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94%E8%AF%B4%E6%98%8E&#34;&gt;五、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一-linux-系统文件&#34;&gt;一、Linux 系统文件&lt;/h2&gt;
&lt;p&gt;Linux 下文件的属性与内容是分开存放的，文件属性有 inode 编号，内容在block 块中&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbvP1jvjicPEIaicEpQ27Jxa0KOUdQDyTxf816YRpobcQwGhQib5icJtr2M6NBOZhh4thOIDGQE3kmkaxw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;80%&#34; height=&#34;80%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(Linux文件属性)&lt;/p&gt;
&lt;p&gt;10 个中的第一个字母表示文件类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-：一般文件&lt;/li&gt;
&lt;li&gt;d: 目录文件&lt;/li&gt;
&lt;li&gt;b: 块设备文件&lt;/li&gt;
&lt;li&gt;c: 字符设备文件&lt;/li&gt;
&lt;li&gt;l: 链接文件&lt;/li&gt;
&lt;li&gt;p: 管道文件（临时文件）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Linux 多用户多任务，只有一个 root 管理者，具有无限权限！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;r 读 4、w 写 2、x 执行 1，其后依次 3 个字母一组，分别表示: 文件所有者权限u，文件所属用户组权限g，其他用户文件 o。&lt;/p&gt;
&lt;h2 id=&#34;二-修改权限&#34;&gt;二、修改权限&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;chown：(修改所有者，也可修改组)&lt;/li&gt;
&lt;li&gt;chgrp：(修改组)&lt;/li&gt;
&lt;li&gt;chmod：(修改权限), 数字和字母两种修改方法，字母(u/g/o)+(r/w/x)，表示增加此权限，字母(u/g/o)-(r/w/x)，表示去掉此权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-增加用户和用户组&#34;&gt;三、增加用户和用户组&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;useradd -g(修改默认组) -G(修改扩展组/附加组)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;userdel&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;usergroup&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;usermod&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;passwd&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;id 用户： 查看所属组，扩展组等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户的信息在: /etc/passwd、/etc/group、etc/shadow下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四-补充几个使用命令&#34;&gt;四、补充几个使用命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Ctrl + d：退出登录&lt;/li&gt;
&lt;li&gt;Ctrl + c：结束执行&lt;/li&gt;
&lt;li&gt;Tab：自动补齐&lt;/li&gt;
&lt;li&gt;Shift + ctrl + &amp;quot;+&amp;quot;：放大字体&lt;/li&gt;
&lt;li&gt;Ctrl + -：缩小字体&lt;/li&gt;
&lt;li&gt;man指令的退出：q&lt;/li&gt;
&lt;/ul&gt;
">（Linux）文件和用户组</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/linux-wang-luo-pei-zhi/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80ip&#34;&gt;一、ip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8Cnmcli&#34;&gt;二、nmcli&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89nmcli%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E8%BF%9E%E6%8E%A5&#34;&gt;三、nmcli创建新的连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E8%AF%B4%E6%98%8E&#34;&gt;四、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux 网络简单配置是 Linux 基础之一。&lt;/p&gt;
&lt;p&gt;TCP/IP四层模型、IPV4地址、IPV4路由、网络接口名称；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Red Hat7之前的系统以eth0, eth1等名字来命名网卡，在rhel7系统中开始使用新的命名规范：基于固件、设备结构、设备类型。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一-ip&#34;&gt;一、ip&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ip 命令可用于显示设备和地址信息&lt;/li&gt;
&lt;li&gt;ip命令也可用于显示关于网络性能的统计信息&lt;/li&gt;
&lt;li&gt;ip route 显示路由信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二-nmcli&#34;&gt;二、nmcli&lt;/h2&gt;
&lt;p&gt;使用nmcli配置网络，一些常见的命令：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;name&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;连接的名称&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;UUID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;连接的UUID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TYPE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;连接的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DEVIDE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;连接绑定的设备&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbvcm6SGotmhLI7NG9e3h8QdA1FR7XQ6iaOQO6MERnG1Fby30nSppIBOBhxqYehTSuBF9bicEIk3LABw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(仅显示活动的连接)&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbvcm6SGotmhLI7NG9e3h8QdDL57f7FsKxtcQLuXmVA6Qfia9GanOGgYHbmribfwiag9wy5icKG7ZNv3bg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(某特定连接)&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbvcm6SGotmhLI7NG9e3h8QdS5ibR553iaGn7os2NoF1jiaC7PyVHsSzicicHibIof5sCqB7srgZCVjNOqcA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(特定连接的详细信息)&lt;/p&gt;
&lt;h2 id=&#34;三-nmcli创建新的连接&#34;&gt;三、nmcli创建新的连接&lt;/h2&gt;
&lt;p&gt;使用nmcli创建新的连接，连接其实就是给一个物理网卡创建一个配置信息。&lt;/p&gt;
&lt;p&gt;定义一个名字为default的连接，该连接会通过DHCP自动获取IP地址等信息。&lt;/p&gt;
&lt;p&gt;命令：nmcli con add con-name &amp;quot;default&amp;quot; type ethernet ifname eth0&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbvcm6SGotmhLI7NG9e3h8QdQViaHWAHD9ibk0QtyG5eVX3b1dmf8iaSAbblo8DpTpIY42DFo2vsGMkKA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbvcm6SGotmhLI7NG9e3h8QdibiavK244I2O61IJicCd4ib9FqhEgwL2GUKJKrUL4TU947uwibxlTc16UFA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbvcm6SGotmhLI7NG9e3h8Qdv0k6jibsbvib6rQMljKgSz9OdknAicc2ichlKEWW2WZib9mC2RV8CNzklSg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbvcm6SGotmhLI7NG9e3h8QdnOcxjONmNtJpVBn9L6YzVVfZZkBSH55nOEpYF6ByOmic3yy9A9MicNMQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;通过nmcli修改网络接口，可以通过nmcli con mod 参数修改现有的连接。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关闭static的自动连接功能：nmcli con mod &amp;quot;static&amp;quot; connection.autoconnect no&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbvcm6SGotmhLI7NG9e3h8QdhBhhXNkw5O815ed196JicHRK6hWIJSRicoIg1ZibicSUrUwtbPic41yOPuw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(关闭static的自动连接功能)&lt;/p&gt;
&lt;p&gt;其他命令：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;nmcli con del &amp;quot;&amp;quot;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;删除一个连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;nmcli net off&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关闭所有接口的连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;nmcli dev dis&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关闭某个接口，并临时禁用自动连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;nmcli con down &amp;quot;&amp;quot;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;断开某个连接&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;图形界面配置网络：nm-connection-editor&lt;/p&gt;
">（Linux）网络配置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/linux-jin-cheng/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E8%BF%9B%E7%A8%8B&#34;&gt;一、进程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8Clinux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81&#34;&gt;二、Linux进程状态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E8%BF%9B%E7%A8%8B%E5%91%BD%E4%BB%A4&#34;&gt;三、进程命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8B%E6%B4%BB%E5%8A%A8&#34;&gt;四、监控进程活动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94%E8%AF%B4%E6%98%8E&#34;&gt;五、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 Linux 系统而言，掌握进程知识，才有可能学好网络编程，解决实际问题。&lt;/p&gt;
&lt;h2 id=&#34;一-进程&#34;&gt;一、进程&lt;/h2&gt;
&lt;p&gt;一个可执行的程序在被执行之后的实例。&lt;/p&gt;
&lt;p&gt;每个进程都有一个唯一的 ID--PID，也有一个父进程 ID--PPID，所有进程都是第一个进程的后代，在 Red Hat7 中为 systemd。&lt;/p&gt;
&lt;p&gt;进程的生命周期有：就绪态，执行状态，等待，消亡状态。&lt;/p&gt;
&lt;h2 id=&#34;二-linux进程状态&#34;&gt;二、Linux进程状态&lt;/h2&gt;
&lt;p&gt;用 man 7 signal 查看。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R ：可运行状态&lt;/li&gt;
&lt;li&gt;S : 可中断睡眠状态(当某个时间或信号满足条件时，该进程会被唤醒)&lt;/li&gt;
&lt;li&gt;D ：不可中断睡眠状态(其唤醒的资源完全无法预料)&lt;/li&gt;
&lt;li&gt;K ：可通过信号强行停止&lt;/li&gt;
&lt;li&gt;Z：僵尸进程&lt;/li&gt;
&lt;li&gt;X：进程成功退出&lt;/li&gt;
&lt;li&gt;T：进程被停止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;列出进程的命令：ps aux, ps -ef  (-e 列出所有进程，-f 列出进程的详细信息)&lt;/p&gt;
&lt;h2 id=&#34;三-进程命令&#34;&gt;三、进程命令&lt;/h2&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbukM2xCss1iazdBjVpD0JJUuaYQd7fxQrIBMNuftcvsEVxeJbESO3XwJfjWvHxQ56ibI7rVmYaFa3NA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(调出火狐浏览器)&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbukM2xCss1iazdBjVpD0JJUuBjPialbMuOlmtJg6beBHiaqrryGh0ssyJKYL0x0oibANWeLbkVQHiazOeA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(火狐浏览器放置后台运行)&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbukM2xCss1iazdBjVpD0JJUub0B4uhL9ibvtPL1WfA11nOtkXZ4CuX846qaGMbEaiaNwxCuXCvF47Qvg/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(查看后台进程)&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbukM2xCss1iazdBjVpD0JJUu7tSJoDWPahRjgbIDibUu91A4zyFwWgvLCag5YmNK6cOzGXLOWTPapIA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(后台进程转为前台进程)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + z 将进程放到后台并暂停&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + c 将进程强制结束&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bg %jobid 将前台进程转到后台&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbukM2xCss1iazdBjVpD0JJUukAAyWtcBpvqib7LvBMDm438tuib3QPcg2nEiccyjLOQ8K0ujbqszLlUGg/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(列出所支持的信号)&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbukM2xCss1iazdBjVpD0JJUuuXbJF4bCKtwDmMzsWWibWDoV3GQ0cvyggzPcicJvUUfKkuxKKN1aQjLQ/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(杀死进程)&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbukM2xCss1iazdBjVpD0JJUuVZamDVtic25eHvuv3Ek0JsPmuWbOD7Iov7Ulo7KlOFVQR21iakF2ePOg/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(列出进程目录树)&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbukM2xCss1iazdBjVpD0JJUu68CEAzicq0ddwyO6hvo3vjS2MibocKQlW8cb2Kk8xoLS5VVmUSsNaAJg/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(杀死sleep的所有进程)&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbukM2xCss1iazdBjVpD0JJUu9Xiaib3a80amVusJofUlhcz3nZTyic5ibNYqjfl4gPyicPAytzqbywd0IuA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(pkill的使用)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;格式：kill signal PID 只能杀死一个进程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;格式：killall 进程名字&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;killall -signal 进程名字&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;killall -signal -u username 进程名字&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pkill 类似 killall，但命令可以模糊匹配。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四-监控进程活动&#34;&gt;四、监控进程活动&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;系统负载的计算和意义：进程以及子进程和线程产生的计算指令都会让CPU执行，这些进程组成“运行队列”，等待CPU执行，这个队列就是系统负载。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个CPU拥有独立的请求队列。可看/proc/cpuinfo。&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_png/cu0TUlMDjbukM2xCss1iazdBjVpD0JJUuy69KKfJpufOUIVqltOSYP6icxvgegHoBicMvVpXCnsibHDafCBe9vkzcA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39; width=&#34;50%&#34; height=&#34;50%&#34;&gt;&lt;/div&gt;
&lt;p align=center&gt;(查看cpu信息)&lt;/p&gt;
&lt;p&gt;top 命令实时监控进程状态。&lt;/p&gt;
">（Linux）进程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/linux-targrep-ming-ling/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80tar%E5%91%BD%E4%BB%A4&#34;&gt;一、tar命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8Cgrep%E5%91%BD%E4%BB%A4&#34;&gt;二、grep命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&#34;&gt;三、正则表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E8%AF%B4%E6%98%8E&#34;&gt;四、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一-tar命令&#34;&gt;一、tar命令&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;-c&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;打包，创建压缩包&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-x&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;对打包的文件解包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-t&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查看压缩包的详细信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-v&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;打包或解包过程的详细信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-f&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;对应打包名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-z&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用gzip压缩归档文件（.tar.gz）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-j&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用bzip2压缩归档文件（.tar.bz2）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-C&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;解包/打包路径omeiy&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;没有解包/打包路径的话，就在当前目录。&lt;/p&gt;
&lt;h2 id=&#34;二-grep命令&#34;&gt;二、grep命令&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;-i&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;忽略字符大小写&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-v&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示没匹配到的行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-n&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示行号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-A num&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示到匹配之后的行数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-B num&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示到匹配之前的行数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;三-正则表达式&#34;&gt;三、正则表达式&lt;/h2&gt;
&lt;p&gt;Regular Expression，规则表达式，正则表达式用于进行字符串的匹配，传统的字符串匹配中，需要匹配的内容是固定的，显然这种匹配方式的应用场景是有限的。就需要通过一种手段描述匹配内容是一类字符串，而不是一个固定的字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正则表达式处理字符串匹配的本质在于：用一个表达式描述一类字符串。代表一类字符串的技术已经拥有一个：通配符。例如：l*e，l??e等等。但是通配符的应用场景依然是非常有限的（例如：用通配符就无法表示只由数字组成的字符串）。&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;元字符&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;匹配任意单个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;*&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;匹配前一个字符(0-n)次&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;.*&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;匹配任意长度的任意字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;?&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;匹配前一个字符0或1次，用\转义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;{m, n}&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;匹配m到n次()用来转义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[]&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;匹配任意单个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;[^]&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;匹配指定范围外的任意单个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;^&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;定死行首  ^abc&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;定死行尾  abc$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;^$&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;空白行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;lt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;词首   精确匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;词尾   精确匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;^ $&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;一个空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;分组，当做整体看待&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;注意：因为花括号，小括号，竖杠(|)，在 shell 中是非常特殊的字符，因此在 grep 命令中使用时要在其前增加 \ 进行转义！&lt;/strong&gt;&lt;/p&gt;
">（Linux）tar/grep命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/linux-ruan-ying-lian-jie-ji-chong-ding-xiang/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80find%E5%91%BD%E4%BB%A4&#34;&gt;一、find命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8Csuid-sgid-sbit&#34;&gt;二、、SUID SGID SBIT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5ln&#34;&gt;三、软，硬链接：ln&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E9%87%8D%E5%AE%9A%E5%90%91&#34;&gt;四、重定向&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94%E8%AF%B4%E6%98%8E&#34;&gt;五、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一-find命令&#34;&gt;一、find命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基本格式：find 路径 选项 参数&lt;/li&gt;
&lt;li&gt;-name  : 根据文件名字查找&lt;/li&gt;
&lt;li&gt;-size  ：根据文件大小查找（+:比这个大 -:比这个小）&lt;/li&gt;
&lt;li&gt;-type  ：根据文件类型查找    - 普通文件 -d 目录 -l 链接文件 -c 字符设备文件 -b 块设备文件 -p 管道文件&lt;/li&gt;
&lt;li&gt;-uid   : 根据用户的UID查&lt;/li&gt;
&lt;li&gt;-gid   ：根据用户所属组查询&lt;/li&gt;
&lt;li&gt;-nouser ：查询没有所属用户的&lt;/li&gt;
&lt;li&gt;-nogroup：查询没有所属组的&lt;/li&gt;
&lt;li&gt;-perm  ：根据权限查找&lt;/li&gt;
&lt;li&gt;最后可以-exec 命令 {} ;进行一些所需的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二-suid-sgid-sbit&#34;&gt;二、、SUID SGID SBIT&lt;/h2&gt;
&lt;p&gt;SUID 是针对文件的，在所有者的x(可执行位上)x-&amp;gt;s/_-&amp;gt;S，u+s即可设置/4也可，代表着拥有文件所有者的权限。&lt;/p&gt;
&lt;p&gt;SGID 是对文件、目录均可，主要针对的是目录，在所属组的x(可执行位上)x-&amp;gt;s/_-&amp;gt;S，g+s即可设置/2也可，代表着在这个目录下创建的文件与此目录有相同的组。&lt;/p&gt;
&lt;p&gt;SBIT 是针对目录的，在其他用户的x(可执行位上)x-&amp;gt;t/_-&amp;gt;T，o+t即可设置/1也可，代表着其他用户只能对该目录下的文件读，不能修改和删除，只有自己创建的才可进行读，写，修改，删除等操作&lt;/p&gt;
&lt;h2 id=&#34;三-软硬链接ln&#34;&gt;三、软，硬链接：ln&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;硬链接&lt;/strong&gt;：同一文件的不同分身，inode只有一个，相当于只有一个文件，都是通过指针的指向，一改全改，只能对同一目录下的进行，不能是目录的其他文件系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;格式 ：ln 原文件名 硬链接名。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软连接&lt;/strong&gt;：两个不同的文件，软连接文件中存放的是那个连接文件的路径，原文件删除，则软连接文件无法查看，软连接可以是目录、文件、和不同的文件系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;格式 ：ln -s 原文件名 软链接名。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;inode编号&lt;/strong&gt;：Linux文件系统中所有的文件和目录都拥有一个唯一的编号。硬链接文件指的是存放于文件系统中不同路径下的有相同inode编号的文件.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;硬链接文件的本质&lt;/strong&gt;：虽然存放在文件系统中的不同位置，但是是同一个文件。相当于一个文件在文件系统中的若干个分身，这些分身之间不存在直接的依赖关系。但是操作其中一个文件，就相当于操作了不同位置的同一个文件。只有当所有的硬链接文件统统都被rm掉了，这个文件才真正的被删除。&lt;/p&gt;
&lt;h2 id=&#34;四-重定向&#34;&gt;四、重定向&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;重定向&lt;/strong&gt;：重新将标准输入(stdin)/标准输出(stdout)/标准错误(stderr)指定方向，无论是标准输入，标准输出/标准错误中的哪一个，都是数据的流动，而数据的流动都是有方向性的（从哪儿到哪儿）。&lt;/p&gt;
&lt;p&gt;标准输出是有默认的数据流目的地的（默认是标准输出设备），标准输出设备在Linux上指的是/dev。&lt;/p&gt;
&lt;p&gt;目录下的一个设备文件（字符设备文件）。任何一个可执行程序所产生的标准输出数据都是写入到这些设备文件之中的：stdin(0)、stdout(1)、stderr(2)；&lt;/p&gt;
&lt;p&gt;重定向标准输出：将标准输出的目的地改为任意可能的文件（重定向了标准输出的目的地）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;重定向符号&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;相关解释&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;使用形式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;对应讲解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重定向标准输出(覆盖特性)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;命令 &amp;gt; 文件的路径&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;文件对应路径如果不存在，则创建该文件，如果存在，有内容的话则首先清空文件内容，在将标准输出写入文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重定向标准输出(追加特性)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;命令 &amp;gt;&amp;gt; 文件的路径&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;文件对应路径如果不存在，则创建该文件，如果存在，有内容的话则不会清空文件内容，将标准输出追加至文件末尾。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;标准输入是由默认的数据来源（默认是标准输入设备），标准输入设在Linux上指的是/dev目录下得一个设备文件（字符设备文件）。任何一个可执行程序执行时有可能需要从标准输入设备读入数据，其实就是读取标准输入设备文件中的内容。&lt;/p&gt;
&lt;p&gt;重定向标准输入：将标准输入的来源改为任意可能的文件（重定向了标准输入的来源）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;重定向符号&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;相关解释&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;使用形式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;对应讲解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;lt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重定向标准输入&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;命令 &amp;lt; 文件路径&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;&amp;lt;&amp;lt;&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重定向标准输入，可以使用伪终端&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;命令 &amp;lt;&amp;lt; ! 若干文件内容&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;!表示伪终端开启和关闭。在中间可以书写任意内容，这些内容将成为命令的标准输入内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;合理的使用重定向，重定向输出：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将命令的标准输出保存到文件&lt;/li&gt;
&lt;li&gt;重定向符产生多个中间文件，使得多个命令可以协同运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;重定向内部的实现：主要使用了两个函数（但需要理解三个），实现的主要原理是文件描述符复制技术。使用的函数是：dup、dup2、fcntl（这个函数可以替代dup和dup2）。与&amp;amp;结合在一起，可以联合将标准错误和标准输出到同一文件中。&lt;/strong&gt;&lt;/p&gt;
">（Linux）软硬链接及重定向</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/lesslesssuan-fa-dao-lun-greatergreater-yan-du/"" data-c="
          &lt;h3 id=&#34;算法基础&#34;&gt;算法基础&lt;/h3&gt;
">《算法导论》研读</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/ge-ren-bo-ke-xue-xi-yu-shi-jian/"" data-c="
          &lt;h2 id=&#34;创建&#34;&gt;创建&lt;/h2&gt;
&lt;p&gt;1、github paper + gridea（主题）&lt;br&gt;
2、域名解析（阿里云）：两步，一是www+仓库，二是@+仓库地址(ping)&lt;/p&gt;
&lt;h2 id=&#34;cdn&#34;&gt;cdn&lt;/h2&gt;
&lt;p&gt;cloudflare&lt;/p&gt;
&lt;h2 id=&#34;安全性学习&#34;&gt;安全性学习&lt;/h2&gt;
&lt;h3 id=&#34;ssltls&#34;&gt;SSL/TLS&lt;/h3&gt;
&lt;h3 id=&#34;托管规则&#34;&gt;托管规则&lt;/h3&gt;
&lt;h3 id=&#34;page-shield&#34;&gt;page shield&lt;/h3&gt;
&lt;h3 id=&#34;自动程序&#34;&gt;自动程序&lt;/h3&gt;
&lt;h3 id=&#34;ddos&#34;&gt;DDoS&lt;/h3&gt;
&lt;h3 id=&#34;accessvpn&#34;&gt;Access(vpn)&lt;/h3&gt;
&lt;h3 id=&#34;grpc&#34;&gt;gRPC&lt;/h3&gt;
&lt;p&gt;gRPC 协议是 Google 于 2015 年开发的，目的是使用较小的有效负载构建高效的 API，以减少带宽使用量，降低延迟并加快实施速度。&lt;br&gt;
要求：gRPC 端点必须侦听端口 443、gRPC 端点必须支持 TLS 和 HTTP/2、HTTP/2 必须通过 ALPN 播发&lt;/p&gt;
">个人博客学习与实践</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/cloudflare-xue-xi/"" data-c="
          &lt;p&gt;1&lt;/p&gt;
">cloudflare学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/a-li-yun-ji-zhu-xue-xi/"" data-c="
          &lt;p&gt;1&lt;/p&gt;
">阿里云技术学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/linux-chang-yong-ming-ling/"" data-c="
          &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86&#34;&gt;一.文件管理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BEfind&#34;&gt;1.文件查找：find&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9Dcp&#34;&gt;2.文件拷贝：cp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E6%89%93%E5%8C%85%E8%A7%A3%E5%8C%85tar&#34;&gt;3.打包解包：tar&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86&#34;&gt;二.文本处理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6nl&#34;&gt;1.(显示行号)查看文件：nl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E6%96%87%E6%9C%AC%E6%9F%A5%E6%89%BEgrep&#34;&gt;2.文本查找：grep&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E6%8E%92%E5%BA%8Fsort&#34;&gt;3.排序：sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%E8%BD%AC%E6%8D%A2tr&#34;&gt;4.转换：tr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5%E5%88%87%E5%88%86%E6%96%87%E6%9C%ACcut&#34;&gt;5.切分文本：cut&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6%E6%8B%BC%E6%8E%A5%E6%96%87%E6%9C%ACpaste&#34;&gt;6.拼接文本：paste&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7%E7%BB%9F%E8%AE%A1wc&#34;&gt;7.统计：wc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86sed&#34;&gt;8.数据处理：sed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86awk&#34;&gt;9.数据处理：awk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90&#34;&gt;三.性能分析&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E8%BF%9B%E7%A8%8B%E6%9F%A5%E8%AF%A2ps&#34;&gt;1.进程查询：ps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8E%A7top&#34;&gt;2.进程监控：top&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%9F%A5%E8%AF%A2lsof&#34;&gt;3.打开文件查询：lsof&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%87%8Ffree&#34;&gt;4.内存使用量：free&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5shell%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6ulimit&#34;&gt;5.shell进程的资源限制：ulimit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7&#34;&gt;四.网络工具&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AEifconfig&#34;&gt;1.网卡配置：ifconfig&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5netstat&#34;&gt;2.查看当前网络连接：netstat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E6%9F%A5%E7%9C%8B%E8%B7%AF%E7%94%B1%E8%A1%A8route&#34;&gt;3.查看路由表：route&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%E6%A3%80%E6%9F%A5%E7%BD%91%E7%BB%9C%E8%BF%9E%E9%80%9A%E6%80%A7ping&#34;&gt;4.检查网络连通性：ping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5%E8%BD%AC%E5%8F%91%E8%B7%AF%E5%BE%84traceroute&#34;&gt;5.转发路径：traceroute&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6%E7%BD%91%E7%BB%9Cdebug%E5%88%86%E6%9E%90nc&#34;&gt;6.网络Debug分析：nc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8A%93%E5%8C%85tcpdump&#34;&gt;7.命令行抓包：tcpdump&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7dig&#34;&gt;8.域名解析工具：dig&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82curl&#34;&gt;9.网络请求：curl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94%E5%BC%80%E5%8F%91%E5%8F%8A%E8%B0%83%E8%AF%95&#34;&gt;五.开发及调试&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E7%BC%96%E8%BE%91%E5%99%A8vim&#34;&gt;1.编辑器：vim&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E7%BC%96%E8%AF%91%E5%99%A8gcc%E5%92%8Cg++&#34;&gt;2.编译器：gcc和g++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7gdb&#34;&gt;3.调试工具：gdb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%E6%9F%A5%E7%9C%8B%E4%BE%9D%E8%B5%96%E5%BA%93ldd&#34;&gt;4.查看依赖库：ldd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90objdump&#34;&gt;5.二进制文件分析：objdump&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90readelf&#34;&gt;6.ELF文件格式分析：readelf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7%E8%B7%9F%E8%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8strace&#34;&gt;7.跟踪进程中系统调用：strace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8%E8%B7%9F%E8%B8%AA%E8%BF%9B%E7%A8%8B%E6%A0%88pstack&#34;&gt;8.跟踪进程栈：pstack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84pmap&#34;&gt;9.进程内存映射：pmap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AD%E5%85%B6%E4%BB%96&#34;&gt;六.其他&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8Bkill&#34;&gt;1.终止进程：kill&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90chmod&#34;&gt;2.修改文件权限：chmod&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E5%88%9B%E5%BB%BA%E9%93%BE%E6%8E%A5ln&#34;&gt;3.创建链接：ln&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%B0%BEtail&#34;&gt;4.显示文件尾：tail&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git&#34;&gt;5.版本控制：git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8Dalias&#34;&gt;6.设置别名：alias&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- GFM-TOC --&gt;
&lt;br&gt;
&lt;h1 id=&#34;一文件管理&#34;&gt;一.文件管理&lt;/h1&gt;
&lt;h2 id=&#34;1文件查找find&#34;&gt;1.文件查找：find&lt;/h2&gt;
&lt;h4 id=&#34;使用方法&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;find [查找目录] [查找条件]

查找目录：
    .：在当前目录及子目录下查找（默认）
    A：在目录A及A的子目录下查找
查找条件：
    -name：根据文件名查找
    -regex：使用正则表达式匹配
    -type：按类型查找（f:文件，d:目录，l:链接...）
    -atime：按访问时间查找（n:n天前的一天内，+n:n天前(不含n天本身)，-n:n天内(不含n天)）
    -mtime：按修改时间查找（n:n天前的一天内，+n:n天前(不含n天本身)，-n:n天内(不含n天)）
    -size：按大小查找（单位k，+nk:&amp;quot;比nk更大&amp;quot;，-nk:&amp;quot;比nk更小&amp;quot;）
    -perm：按权限查找（644：权限等于644的文件）
    -user/-nouser：用户名等于/用户名不等于
    -group/-nogroup：组名等于/组名不等于
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#1.在当前目录及子目录下查找后缀为cpp的文件
find . -name *.cpp

#2.使用正则表达式查找
find -regex &amp;quot;.*.cpp$&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2文件拷贝cp&#34;&gt;2.文件拷贝：cp&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-2&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp [选项] 源路径 目的路径

选项：
    -a：将所有属性一起复制（包括拥有者、时间等信息）
    -i：目标文件存在时，进行询问
    -r：递归复制
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3打包解包tar&#34;&gt;3.打包解包：tar&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-3&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tar [-j|-z] [cv] [-f 压缩包名] 目录
tar [-j|-z] [xv] [-f 解压包名] [-C 解压路径]

选项：
    -c/-x：打包/解包
    -j/-z：bzip2格式/gzip格式
    -v：显示过程
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二文本处理&#34;&gt;二.文本处理&lt;/h1&gt;
&lt;h2 id=&#34;1显示行号查看文件nl&#34;&gt;1.(显示行号)查看文件：nl&lt;/h2&gt;
&lt;p&gt;行号计算不包括空行&lt;/p&gt;
&lt;h2 id=&#34;2文本查找grep&#34;&gt;2.文本查找：grep&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-4&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep [选项] 模式串 文件
输出 | grep [选项] 模式串

选项
    -e：使用多个模式串
    -i：忽略大小写
    -n：打印行号
    -c：统计次数（一行算一次）
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例-2&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#1.在test.c中搜索包含字符串”printf“或”count“的行
grep -e &amp;quot;printf&amp;quot; -e &amp;quot;count&amp;quot; test.c
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3排序sort&#34;&gt;3.排序：sort&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-5&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sort [选项] 文件
输出 | sort [选项]

选项
    -d：按字典序排序（默认）
    -n：按数字排序
    -k：&amp;quot;-k n&amp;quot;表示按各行第n列进行排序
    -r：反序
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4转换tr&#34;&gt;4.转换：tr&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-6&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#set1、set2为字符集，可以是单个字符，也可以是字符串
输出 | tr [选项] set1 set2

选项：
    -d：删除字符
    -s：字符压缩
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例-3&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#1.删除字符&#39;:&#39;
cat /etc/passwd | tr -d &#39;:&#39;

#2.将小写字母替换成大写字母
last | tr &#39;[a-z]&#39; &#39;A-Z&#39;

#3.将&#39;a&#39;、&#39;b&#39;、&#39;c&#39;替换成&#39;z&#39;
cat test | tr “abc” &#39;z&#39;

#4.将连续的&#39;a&#39;压缩成&#39;b&#39;（单个或连续出现的多个‘a’会压缩成一个‘b’）
cat test | tr -s &#39;a&#39; &#39;b&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5切分文本cut&#34;&gt;5.切分文本：cut&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-7&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cut [选项] 文件
输出 | cut [选项]

选项：
    -d：分隔符（-d &#39;:&#39; 以’:‘为分隔符）
    -f：选择域（-f 1,2 输出分隔后第1列和第2列）
    -c：字符范围（-c n-m 输出第n到m个字符。如果没有m，输出到末尾）
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例-4&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#1.按’:‘分隔$PATH，输出第3个和第5个
echo $PATH | cut -d &#39;:&#39; -f 3,5

#2.输出export运行结果每行的第12-20个字符
export | cut -c 12-20
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6拼接文本paste&#34;&gt;6.拼接文本：paste&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-8&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;paste [选项] file1 file2

选项：
    -d：指定拼接时使用的分隔符（默认使用tab作为分隔符）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7统计wc&#34;&gt;7.统计：wc&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-9&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wc [选项] 文件
输出 | wc [选项]

选项：
    -c：统计字符数
    -w：统计单词数
    -l：统计行数
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8数据处理sed&#34;&gt;8.数据处理：sed&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;sed常用于一整行的处理。如果有一个100万行的文件，要在第100行加某些文字，此时由于文件太大，不适合用vim处理。因此使用sed是个很好的选择&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;使用方法-10&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sed [选项] &#39;[动作]&#39; 文件
输入 | sed [选项] &#39;[动作]&#39;

选项：
    -n：安静模式，只输出sed处理过的行（否则未处理行也会输出）
    -i：结果直接作用到文件（没指定时不会修改文件）
    -e：在命令行模式上输入动作
    -f：从文件中读取动作

动作：[n1[,n2]] function
function:
    a/i：在后插入/在前插入
    d：删除
    p：打印
    s：替换
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例-5&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#1.插入
nl /etc/passwd | sed &#39;2a drink tea&#39; #在第2行后插入一行：&amp;quot;drink tea&amp;quot;
nl /etc/passwd | sed &#39;2a aaa \
&amp;gt; bbb&#39; #在第2行后插入两行：&amp;quot;aaa&amp;quot;和&amp;quot;bbb&amp;quot;

#2.删除
nl /etc/passwd | sed &#39;2,5d&#39; #删除2~5行
sed &#39;/^$/d&#39; ip #将ip文件中的空行删除

#3.打印2~5行（安静模式，不使用安静模式2~5行会打印2次）
nl /etc/passwd | sed -n &#39;2,5p&#39;

#4.替换
nl /etc/passwd | sed &#39;2s/daemon/root/g&#39; #将第二行的daemon替换成root
ifconfig | grep &#39;inet addr&#39; | sed &#39;s/^.*addr://g&#39; #将所有开头的“inet addr:”删除
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9数据处理awk&#34;&gt;9.数据处理：awk&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;相比于sed常用于一整行的处理，awk则比较倾向于将一行分成数个“字段”来处理。因此，相当适合小型的数据处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;awk处理步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读入第一行，并将第一行的数据填入$0,$1,$2等变量当中&lt;/li&gt;
&lt;li&gt;依据条件类型的限制，判断是否需要进行后面的动作&lt;/li&gt;
&lt;li&gt;做完所有的动作与条件类型&lt;/li&gt;
&lt;li&gt;若还有后续的“行”的数据，则重复1~3步，直到所有的数据都读完为止&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;使用方法-11&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;awk &#39;条件类型1{动作1} 条件类型2{动作2} ...&#39; filename
输出 | awk &#39;条件类型1{动作1} 条件类型2{动作2} ...&#39;

变量：
    $0：整行
    $1：按分隔符分隔后的第1列
    $2：按分隔符分隔后的第2列
    $k：按分隔符分隔后的第k列
    NF：每一行拥有的字段数
    NR：目前所处理的行数
    FS：目前的分隔字符（默认是空格或tab）
条件判断：&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=、==、!=
命令分隔：使用&#39;;&#39;或Enter
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例-6&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#1.打印last -n 5结果中每行经过分隔符(默认情况下为空格或tab)分隔后的第1列和第3列
last -n 5 | awk &#39;{print $1 &amp;quot;\t&amp;quot; $3}&#39;

#2.以&#39;:&#39;作为分隔符，打印第3列小于10的所有行的第1列和第3列
cat /etc/passwd | awk &#39;{FS=&amp;quot;:&amp;quot;} $3&amp;lt;10{print $1 &amp;quot;\t&amp;quot; $3}&#39;      #（第一行不会处理）
cat /etc/passwd | awk &#39;BEGIN{FS=&amp;quot;:&amp;quot;} $3&amp;lt;10{print $1 &amp;quot;\t&amp;quot; $3}&#39; #（第一行会处理）

#3.假设test文件由3列数字组成，以空格分隔。该命令会计算每行的和然后打印
awk &#39;{total=$1+$2+$3;printf &amp;quot;%10d %10d %10d %10.2f\n&amp;quot;,$1,$2,$3,total}&#39; test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意上面的示例2，awk首先是读取一行，分隔后的数据填入$0,$1,$2等变量中才开始进行条件判断和执行动作。因此第一条命令在按空格或tab分隔后才将分隔符换成&#39;:&#39;，所以第一行显示结果不对&lt;/p&gt;
&lt;h1 id=&#34;三性能分析&#34;&gt;三.性能分析&lt;/h1&gt;
&lt;h2 id=&#34;1进程查询ps&#34;&gt;1.进程查询：ps&lt;/h2&gt;
&lt;p&gt;man ps手册非常庞大，不是很好查阅，因此主要记住几个命令&lt;/p&gt;
&lt;h4 id=&#34;示例-7&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#1.列出仅与自身环境有关的进程，最上层的父进程是允许该ps命令的bash而没有扩展到init进程中去
ps -l

#2.列出系统所有进程的信息
ps aux
ps -ef    #aux会截断COMMAND列，-ef不会。aux是BSD风格，-ef是System V风格
ps axjf   #以&amp;quot;进程树&amp;quot;的方式显示所有进程
ps -lA    #输出格式同ps -l
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;../pic/linux-ps-1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;F&lt;/strong&gt;：进程标志，说明进程的权限
&lt;ul&gt;
&lt;li&gt;4：root权限&lt;/li&gt;
&lt;li&gt;1：仅能fork而不能exec&lt;/li&gt;
&lt;li&gt;0：既非4也非1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;S&lt;/strong&gt;：进程的状态
&lt;ul&gt;
&lt;li&gt;R(running)：正在运行&lt;/li&gt;
&lt;li&gt;S(Sleep)：可被唤醒的睡眠&lt;/li&gt;
&lt;li&gt;D：不可被唤醒的睡眠（通常可能在等待I/O）&lt;/li&gt;
&lt;li&gt;T：停止，可能是在后台暂停&lt;/li&gt;
&lt;li&gt;Z(Zombie)：僵尸进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;：CPU使用率&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PRI/NI&lt;/strong&gt;：Priority/Nice的缩写，CPU优先级(越小越高)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ADDR/SZ/WCHAN&lt;/strong&gt;：内存相关，ADDR指出进程在内存的哪个部分，running进程一般显示&#39;-&#39;。SZ为进程使用的内存。WCHAN表示进程当前是否运行中&#39;-&#39;，当进程睡眠时，指出进程等待的事件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TTY&lt;/strong&gt;：进程运行的终端机&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TIME&lt;/strong&gt;：进程用掉的CPU时间&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;../pic/linux-ps-2.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;USER&lt;/strong&gt;：进程所属用户&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%CPU/%MEM&lt;/strong&gt;：进程消耗的CPU百分比和内存百分比&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VSZ&lt;/strong&gt;：进程用掉的虚拟内存(KB)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RSS&lt;/strong&gt;：进程占用的固定内存(KB)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TTY&lt;/strong&gt;：进程运行的终端机，与终端机无关则显示&#39;?&#39;。tty1~tty6是本机的登陆者程序，pts/0等表示由网络连接进主机的进程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;STAT&lt;/strong&gt;：进程目前的状态，与&lt;code&gt;ps -l&lt;/code&gt;结果中的&lt;strong&gt;S&lt;/strong&gt;等同&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;START&lt;/strong&gt;：进程启动的时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TIME&lt;/strong&gt;：进程实际使用的CPU运行时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2进程监控top&#34;&gt;2.进程监控：top&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-12&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;top [选项]

选项：
    -d：跟秒数指定更新间隔
    -n：与-b搭配，指定需要进行几次top输出，重定向时常用
    -p：指定PID，监控特定进程
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;top模式下的命令&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;?&lt;/strong&gt;：显示可用的命令&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P&lt;/strong&gt;：以CPU使用情况排序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;M&lt;/strong&gt;：以内存使用情况排序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;N&lt;/strong&gt;：以PID排序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;q&lt;/strong&gt;：退出&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1&lt;/strong&gt;：多核情况下切换CPU&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;%Cpu(s)后面的“wa”表示I/O wait，过高说明长时间等待I/O，I/O存在瓶颈&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3打开文件查询lsof&#34;&gt;3.打开文件查询：lsof&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-13&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;lsof [选项]

选项：
    -i：-i:端口号查看端口被占用的情况
    -u：后跟用户名查看具体用户打开的文件
    -p：后跟PID查看指定进程打开的文件
    +d：后跟目录查看指定目录下被进程打开的文件，&amp;quot;+D&amp;quot;递归
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4内存使用量free&#34;&gt;4.内存使用量：free&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-14&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;free [选项]

选项：
    -b|-k|-m|-g：单位
    -t：列出物理内存与swap的汇总情况    
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;../pic/linux-free-1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;buffers&lt;/strong&gt;：主要缓存dentry和inode等元数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cached&lt;/strong&gt;：主要缓存文件内容，即page cache&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;- buffers/cache&lt;/strong&gt;：实际使用的内存。used-buffers-cached&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;+ buffers/cache&lt;/strong&gt;：可用内存。free+buffers+cached（在内存紧张时，buffers和cached可以回收）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://fixatom.com/linux-free-cmd-buffers-and-cached/&#34;&gt;详细结果说明&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;5shell进程的资源限制ulimit&#34;&gt;5.shell进程的资源限制：ulimit&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-15&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ulimit [选项]       #查看
ulimit [选项] 新值  #修改

选项：
    -a：列出shell进程的所有资源限制情况（-a命令会列出查看某一资源限制的选项参数）
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;ulimit&lt;/code&gt;修改资源限制只会对当前终端环境有效，如果想永久生效，可以修改文件&lt;code&gt;/etc/security/limits.conf&lt;/code&gt;，该文件的内容如下；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# /etc/security/limits.conf
#
#Each line describes a limit for a user in the form:
#
#&amp;lt;domain&amp;gt;        &amp;lt;type&amp;gt;  &amp;lt;item&amp;gt;  &amp;lt;value&amp;gt;
#
#Where:
#&amp;lt;domain&amp;gt; can be:
#        - a user name
#        - a group name, with @group syntax
#        - the wildcard *, for default entry
#        - the wildcard %, can be also used with %group syntax,
#                 for maxlogin limit
#        - NOTE: group and wildcard limits are not applied to root.
#          To apply a limit to the root user, &amp;lt;domain&amp;gt; must be
#          the literal username root.
#
#&amp;lt;type&amp;gt; can have the two values:
#        - &amp;quot;soft&amp;quot; for enforcing the soft limits
#        - &amp;quot;hard&amp;quot; for enforcing hard limits
#
#&amp;lt;item&amp;gt; can be one of the following:
#        - core - limits the core file size (KB)
#        - data - max data size (KB)
#        - fsize - maximum filesize (KB)
#        - memlock - max locked-in-memory address space (KB)
#        - nofile - max number of open files
#        - rss - max resident set size (KB)
#        - stack - max stack size (KB)
#        - cpu - max CPU time (MIN)
#        - nproc - max number of processes
#        - as - address space limit (KB)
#        - maxlogins - max number of logins for this user
#        - maxsyslogins - max number of logins on the system
#        - priority - the priority to run user process with
#        - locks - max number of file locks the user can hold
#        - sigpending - max number of pending signals
#        - msgqueue - max memory used by POSIX message queues (bytes)
#        - nice - max nice priority allowed to raise to values: [-20, 19]
#        - rtprio - max realtime priority
#        - chroot - change root to directory (Debian-specific)
#
#&amp;lt;domain&amp;gt;      &amp;lt;type&amp;gt;  &amp;lt;item&amp;gt;         &amp;lt;value&amp;gt;
#

#*               soft    core            0
#root            hard    core            100000
#*               hard    rss             10000
#@student        hard    nproc           20
#@faculty        soft    nproc           20
#@faculty        hard    nproc           50
#ftp             hard    nproc           0
#ftp             -       chroot          /ftp
#@student        -       maxlogins       4

# End of file
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例-8&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@068ca8da6d06:/# ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7863
max locked memory       (kbytes, -l) 82000
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1048576
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) unlimited
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四网络工具&#34;&gt;四.网络工具&lt;/h1&gt;
&lt;h2 id=&#34;1网卡配置ifconfig&#34;&gt;1.网卡配置：ifconfig&lt;/h2&gt;
&lt;h2 id=&#34;2查看当前网络连接netstat&#34;&gt;2.查看当前网络连接：netstat&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;netstat [选项]

选项：
    -a：将所有的连接、监听、Socket数据都列出来（如，默认情况下，不会列出监听状态的连接）
    -t：列出tcp连接
    -u：列出udp连接
    -n：将连接的进程服务名称以端口号显示（如下图中Local Address会换成10.0.2.15:22）
    -l：列出处于监听状态的连接
    -p：添加一列，显示网络服务进程的PID（需要root权限）
    -i：显示网络接口列表，可以配合ifconfig一起分析
    -s：打印网络统计数据，包括某个协议下的收发包数量
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;../pic/linux-netstat-1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Active Internet connections（w/o servers）：网络相关的连接&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Recv-Q&lt;/strong&gt;：接收队列(已接收还未递交给应用)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Send-Q&lt;/strong&gt;：发送队列(接收方未确认的数据)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Local Address&lt;/strong&gt;：本地IP(主机):端口(服务名)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Foreign Address&lt;/strong&gt;：远端IP:端口&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;Recv-Q和Send-Q通常应该为0，如果长时间不为0可能存在问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Active UNIX domain sockets（w/o servers）：本地相关的套接字&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RefCnt&lt;/strong&gt;：连接到此socket的进程数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flags&lt;/strong&gt;：连接标识&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Type&lt;/strong&gt;：socket访问的类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Path&lt;/strong&gt;：连接到此socket的相关程序的路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://linux.cn/article-2434-1.html&#34;&gt;netstat的10个基本用法&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;3查看路由表route&#34;&gt;3.查看路由表：route&lt;/h2&gt;
&lt;h2 id=&#34;4检查网络连通性ping&#34;&gt;4.检查网络连通性：ping&lt;/h2&gt;
&lt;h2 id=&#34;5转发路径traceroute&#34;&gt;5.转发路径：traceroute&lt;/h2&gt;
&lt;h2 id=&#34;6网络debug分析nc&#34;&gt;6.网络Debug分析：nc&lt;/h2&gt;
&lt;h2 id=&#34;7命令行抓包tcpdump&#34;&gt;7.命令行抓包：tcpdump&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-16&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo tcpdump [选项] ...

选项：
    -D/-i：查看/指定网卡
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例-9&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#抓取本地9877号端口的TCP数据包
sudo tcpdump -i lo tcp port 9877
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下图为tcp回射服务器，客户端分别键入&amp;quot;hello&amp;quot;和“world”时，使用tcpdump抓取到的数据包&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt; &lt;img src=&#34;../pic/linux-tcpdump-1.png&#34;/&gt; &lt;/div&gt;
&lt;h2 id=&#34;8域名解析工具dig&#34;&gt;8.域名解析工具：dig&lt;/h2&gt;
&lt;h2 id=&#34;9网络请求curl&#34;&gt;9.网络请求：curl&lt;/h2&gt;
&lt;h1 id=&#34;五开发及调试&#34;&gt;五.开发及调试&lt;/h1&gt;
&lt;h2 id=&#34;1编辑器vim&#34;&gt;1.编辑器：vim&lt;/h2&gt;
&lt;h2 id=&#34;2编译器gcc和g&#34;&gt;2.编译器：gcc和g++&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/CarpenterLee/p/5994681.html&#34;&gt;C程序的编译过程&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;使用方法-17&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc/g++ [选项] 源文件

选项：
    -E：让编译器在预处理之后停止，不进行后续编译过程，得到.i文件
    -S：让编译器在编译之后停止 ，不进行后续过程，得到.s文件
    -c：生成机器码即二进制.o文件
    -o：指定目标文件名
    -g：在编译的时候生成调试信息
    -Wall：生成所有警告信息
    -I 目录：指定头文件的查找目录
    生成动态链接库：
        1. gcc/g++ -c -fPIC 源文件 -o 目标文件名
        2. gcc -shared 目标文件名 -o 动态链接库名.so
    生成静态链接库：
        1. gcc/g++ -c 源文件 -o 目标文件名
        2. ar -crv 静态链接库名.a 目标文件名
    -l库名 -L 目录：引入链接库，-L指定查找该库的目录。如-lm表示引入libm.so
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3调试工具gdb&#34;&gt;3.调试工具：gdb&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-18&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#第一步：得到可执行文件
gcc/g++ -o 可执行文件 -g 源文件

#第二步：启动gdb
gdb #启动gdb

#第三步：执行gdb命令进行调试
(gdb) gdb命令

gdb命令：
    file 可执行文件：导入需要调试的文件
    r：运行程序
    q：退出gdb
    b：设置断点
        b 行号
        b 函数名称
        b *函数名
        b *代码地址
        b 编号
    c：继续执行，直到下一断点或程序结束
    s：执行一行代码，如果此行代码有函数调用则进入函数
    n：执行一行代码，如果此行代码有函数调用，不进入函数，直接执行函数
    i(info) 子命令：查看某些信息（只输入info或i可以查看有哪些子命令）
        info thread：查看进程的所有线程，会显示每个线程的序号（1~n）
    thread 线程序号：切换到相应的线程（线程序号可以由info thread得到）
    f(frame) 函数栈帧号：切换到相应的函数栈帧（函数栈帧号可以由where等命令得到）
    list：查看源码
        list 行号：查看指定行号附近的源码
        list 函数：查看指定函数附近的源码
        list 文件:行号：查看指定文件中指定行附近的代码
    where：查看当前位置
    p(print) /格式 表达式
        格式：
            x：按十六进制格式显示变量
            d：按十进制格式显示变量
            u：按十六进制格式显示无符号整形
            o：按八进制格式显示变量
            t：按二进制格式显示变量
            a：按十六进制格式显示变量
            c：按字符格式显示变量
            f：按浮点数格式显示变量
        表达式中可用的操作符：
            @：一个和数组有关的操作符，左边是起始地址，右边是长度（p *arr@3）
            ::：指定一个在文件或是函数中的变量（p &#39;f2.c&#39;::x）
            {&amp;lt;type&amp;gt;}&amp;lt;addr&amp;gt;：一个指向内存&amp;lt;addr&amp;gt;的类型为type的一个对象
    x(examine) &amp;lt;n/f/u&amp;gt; &amp;lt;addr&amp;gt;：查看内存
        n：正整数，表示需要显示的内存单元个数
        f：显示的格式（格式字母同上面的print）
        u：每个单元的字节数
            b：1字节
            h：2字节
            w：4字节（默认）
            g：8字节
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4查看依赖库ldd&#34;&gt;4.查看依赖库：ldd&lt;/h2&gt;
&lt;h2 id=&#34;5二进制文件分析objdump&#34;&gt;5.二进制文件分析：objdump&lt;/h2&gt;
&lt;h2 id=&#34;6elf文件格式分析readelf&#34;&gt;6.ELF文件格式分析：readelf&lt;/h2&gt;
&lt;h2 id=&#34;7跟踪进程中系统调用strace&#34;&gt;7.跟踪进程中系统调用：strace&lt;/h2&gt;
&lt;h2 id=&#34;8跟踪进程栈pstack&#34;&gt;8.跟踪进程栈：pstack&lt;/h2&gt;
&lt;h2 id=&#34;9进程内存映射pmap&#34;&gt;9.进程内存映射：pmap&lt;/h2&gt;
&lt;h1 id=&#34;六其他&#34;&gt;六.其他&lt;/h1&gt;
&lt;h2 id=&#34;1终止进程kill&#34;&gt;1.终止进程：kill&lt;/h2&gt;
&lt;h2 id=&#34;2修改文件权限chmod&#34;&gt;2.修改文件权限：chmod&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;w权限不具有删除文件的能力&lt;/li&gt;
&lt;li&gt;目录的x权限表示能否进入目录&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;使用方法-19&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;chmod [选项] [u|g|o|a][+|-][r|w|x] 文件或目录
chmod [选项] 权限的数字表示 文件或目录

选项：
    -R：递归式的修改
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3创建链接ln&#34;&gt;3.创建链接：ln&lt;/h2&gt;
&lt;h2 id=&#34;4显示文件尾tail&#34;&gt;4.显示文件尾：tail&lt;/h2&gt;
&lt;h2 id=&#34;5版本控制git&#34;&gt;5.版本控制：git&lt;/h2&gt;
&lt;h2 id=&#34;6设置别名alias&#34;&gt;6.设置别名：alias&lt;/h2&gt;
">Linux常用命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/zhi-mian-shi-bu-zhao-ren/"" data-c="
          &lt;h3 id=&#34;只面试不招人&#34;&gt;只面试不招人&lt;/h3&gt;
&lt;h4 id=&#34;1-面试地点诡异的&#34;&gt;1、面试地点诡异的&lt;/h4&gt;
&lt;p&gt;一般的正规公司，不是写字楼就是在商业场所，除去近几年新兴的创业园，工作室确实会在商住一体，或是居民楼内，大部分还是会有相对正规的，商业办公地址。写着面试地点比较偏僻，或者是某酒店的，建议查询下其工商注册信息，不符的，不建议贸然尝试。&lt;/p&gt;
&lt;p&gt;如果真的要去，可以在楼下和保安打个招呼，提前询问几零几是否是XX公司，自己约了去面试，如果半小时没有下来，请对方上门查看，甚至有紧急情况，代为报警。&lt;/p&gt;
&lt;h4 id=&#34;2-面试场所诡异的&#34;&gt;2、面试场所诡异的&lt;/h4&gt;
&lt;p&gt;面试地点没有异常，如约而至，坐在办公场所。那么一般会被安置在会议室或者接待区，在等待的时候请别闲着，可以环顾四周，看看是否有和异常，前台的状态，员工的状态，出现大量的空置，那么多半是有问题的，除了初创阶段，正常的公司不可能大量的空置。如果员工状态懒散，那么多半是公司制度不完善，效益不好，甚至是有不良的劳动用工，恶意欠薪的隐患。这种情况，也不建议继续面试下去。&lt;/p&gt;
&lt;h4 id=&#34;3-面试邀约诡异的&#34;&gt;3、面试邀约诡异的&lt;/h4&gt;
&lt;p&gt;非正常工作时段打电话邀约的，邀约的时候语气特别殷切的，需要特别注意。非上班时间还在电话邀约，那么至少说明在加班，经常加班。语气特别殷切，说明招人难，为什么招人难？大多是公司不咋地。&lt;/p&gt;
&lt;h4 id=&#34;4-要收取费用的&#34;&gt;4、要收取费用的&lt;/h4&gt;
&lt;p&gt;如果是在网上投递简历，通知你面试，然后在面试过程中交押金培训费等各种费用时，这些可能都是骗人的。如果到人才市场去找工作，也要找正规的人才市场，就比如：深圳兴达人才市场就是正规的，应聘者可以到兴达人才市场找工作。&lt;/p&gt;
&lt;h4 id=&#34;5-一次性招聘很多人&#34;&gt;5、一次性招聘很多人&lt;/h4&gt;
&lt;p&gt;如果一个公司招聘很多人，从高层到底层，除非这家公司是新建的公司，否则就是骗人的。求职者们在找工作时一定要注意不要被虚假的招聘信息给欺骗了，一定要到正规的网站投递简历，或者是到正规的人才市场找工作。&lt;/p&gt;
&lt;h3 id=&#34;保护个人-亲人-前雇主情报&#34;&gt;保护个人、亲人、前雇主情报&lt;/h3&gt;
&lt;h4 id=&#34;来源&#34;&gt;来源&lt;/h4&gt;
&lt;p&gt;作者：简秀才&lt;br&gt;
链接：https://www.zhihu.com/question/301031210/answer/1356127992&lt;br&gt;
来源：知乎&lt;br&gt;
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h4 id=&#34;1不是真的招人而是打广告或者应对考核&#34;&gt;1.不是真的招人，而是打广告或者应对考核&lt;/h4&gt;
&lt;p&gt;企业通过这个招聘的借口想表达一个消息，比如这个岗位缺人，让上级领导知道其他员工工作量饱满而不是混日子。比如领导在暗示一些人可以走动走动得到这个岗位。或者想通过这件事传达出某些信息，这个信息可能不是为了招聘，可能只有小范围内部的员工才知道实情，不是真的招人，就是打打广告等等。对很多公司的HR来说，在他们的KPI考核指标中都有很关键的一点就是人员稳定性和人员招聘指标的考核。于是一些HR为了完成招人的需求，他们就会定期的发一些招聘广告来收集一些简历，定期的邀请一些人来他们公司面试。但是对这些公司来说，他们一般都是只邀请人过来走个过场，做做样子，或者从求职者那边得到当前求职市场状况，以及竞争对手情况，还有行业水平等，其实他们公司在那段时间是根本没有招人需求的。这样做或许对公司来说是有一些好处，但是对求职者来说，这可苦了那些从大老远过来面试的人。这时候你可以试想一下，你从大老远过来面试，你不仅需要自掏交通费，路途遥远你过来还要吃一顿饭，最后这么一折腾或许一天就过去了，最终公司给你回复一句：您的情况我们已经了解了，下来有需要我们会通知你。你还在真切等待对方给你的回复，也发邮件催了，但是或许他们永远都不会通知你。对此，当知道真相的你会不会感到很崩溃？&lt;/p&gt;
&lt;h4 id=&#34;2收集同行业情报&#34;&gt;2.收集同行业情报&lt;/h4&gt;
&lt;p&gt;有时候公司想了解竞争对手情况或者同业情况，最好的办法就是放出相应的岗位，然后在面试候选人的时候提问，获取相应信息。由于公司考虑业务扩张或者转型涉及新领域，对涉足新领域的行情不太了解，邀候选人来其实就是通过面试了解更好业内信息，探底，实际未必招人。假招聘真收集情报。他们收到简历后只让竞争对手公司员工进入面试环节，面试时问题大多数敏感的，如你们公司销售额是多少?你的绩效考核有哪些?top客户情况等。可以发现面试官不停的在记录，这就是典型的搜集情报式招聘。很多公司的中低层员工不但没有保护雇主秘密的意识，甚至面试时为讨好面试官反而会和盘托出……&lt;/p&gt;
&lt;h4 id=&#34;3增加&#34;&gt;3，增加&lt;/h4&gt;
&lt;p&gt;面试只透露个人技能，荣誉，反对一切需要父母，学校，朋友，兄弟等信息的收集。保护雇主信息，用不着讨好HR，反正也不录取你。拒绝不问你详细情况，直接开口就面试的公司。&lt;br&gt;
大企业不不会不招，但是招得特别少；校招主要是企业宣传，让你感觉这个企业文化很好，信任他们的产品/服务，培养潜在消费者；社招算是储备简历库&lt;/p&gt;
&lt;h3 id=&#34;因果&#34;&gt;因果&lt;/h3&gt;
&lt;p&gt;公司的人事部细分为很多岗位，每个岗位的考核标准不同。通过打电话让求职者过来面试的，就是招聘专员的主要职责，只负责电话邀约，面试是人事专员或经理负责。如果邀约的面试未完成，那么招聘专员的绩效就有影响，进一步影响工资。因此，招聘专员为了完成自己那部分的KPI就要想尽办法让人过来面试销售岗比较难招到人，如果正常挂出职位，那么对求职者缺乏吸引力，甚至没有人投简历。&lt;br&gt;
因此公司会采用“挂羊头卖狗肉”的方法用其他岗位来吸引求职者面试。面试成功后会告诉求职者挂出的这个岗位不确认，建议求职者考虑销售岗，之后就是一个洗脑的过程。也有可能是面试者能力不行，所以婉拒说“岗位不招人”，这个就需要求职者自己判断了有的公司是利用招聘平台打广告，所以岗位会一直挂着不下架。到这种公司面试之前一定要先自己查明情况，比如通过招聘网站看看发布的日期之类的&lt;/p&gt;
&lt;h3 id=&#34;招聘的评判标准就是一句话说你行你就行不行也行说不行就不行行也不行&#34;&gt;招聘的评判标准就是一句话：“说你行你就行，不行也行！说不行就不行，行也不行。”&lt;/h3&gt;
&lt;p&gt;从应聘者的角度讲：&lt;/p&gt;
&lt;p&gt;1.招聘方对于招聘需求不明晰&lt;br&gt;
很多企业的HR都是拿到了需求部门的招聘需求之后，在网站上搜索相应职位的需求和岗位描述，而不是从需求部门那里了解到来自一线的岗位职责和需求。这样一来就出现了，HR看到合适的简历，可是到了企业面试层面却不符合企业一线的用工需求。&lt;/p&gt;
&lt;p&gt;2.HR对于应聘者的简历要求虚高&lt;br&gt;
很多企业的HR是按照有一说一的工作方式去筛选应聘者简历的。比如需求部门要求会PS、会AE等技术，但是如果应聘者写的是熟练使用Adobe平面、视频软件，就会被过滤掉。当然，如果应聘者写photoshop软件，有很大概率也会被Pass掉。&lt;/p&gt;
&lt;p&gt;3.招聘方打着招聘的旗号干别的事&lt;br&gt;
这一点是从18年以后开始大行其道的。很多企业纷纷打着招聘的旗号，以企业现有的项目问题、管理问题、运营问题等问题作为面试的“测试”，来让应聘者解答。美其名曰检验应聘者的实际能力，其实却是拿应聘当做行业调研或者免费的企业咨询。当然了，更有甚者，拿着应聘者提交上来的面试测试题回复（有的企业是跟应聘者要项目策划案或者某个项目的执行案），直接用在了企业自己的项目上，省去了把业务外包的烦恼。&lt;/p&gt;
&lt;p&gt;4.招聘方对于企业现有状态的保护&lt;br&gt;
这一点就相对比较隐晦了，说白了就是招聘方的人能力不足，面对高能力值的应聘者捉襟见肘。在面试的时候就露出了招聘方人员对于业务的不熟悉或者不了解。无法回答应聘者关于应聘职位的相关问题。对于招聘方来说，这样的“刺儿头”硬茬子肯定不能招啊，如果应聘者进入企业，对于招聘他的人来说就是“自己打造一把随时可能杀死自己的利刃啊！”所谓的死海现象大抵如此了。&lt;/p&gt;
&lt;p&gt;5.招聘方企业对于招聘的岗位规划不足&lt;br&gt;
有些企业，尤其是有些线上或者线下有些成就的企业，在扩展现有业务的时候，比如线下扩展到线上，或者线上落地到线下的时候，对于新的招聘岗位没有相关深入的了解，甚至只是人云亦云的了解了一些皮毛。用半瓶子的水平去面试行业内有相关经验的应聘者，结局可想而知。如果幸运的他们找对了大咖可以入职，因为企业对于业务的不了解，大咖不能按照原有的行业经验进行落实执行，比如申请费用、扩充团队、标定业务方向等，每走一步都要想外行的领导进行汇报申请。这种外行不懂，还要硬指导的情况使得双方都觉得难做。企业觉得应聘者的能力言过其实，应聘者觉得企业在画饼。于是就开始了恶性循环。&lt;/p&gt;
">（经验积累）只面试不招人</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/markdown-xue-xi-bi-ji/"" data-c="
          &lt;p&gt;&lt;strong&gt;一、标题：&lt;/strong&gt;&lt;br&gt;
1、markdown标题用=和-表示一级和二级标题&lt;br&gt;
2、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;二、段落格式：&lt;/strong&gt;&lt;br&gt;
Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。&lt;br&gt;
字体：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*斜体文本*
_斜体文本_
**粗体文本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;三、分隔线&lt;/strong&gt;&lt;br&gt;
你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;***
* * *
*****
- - -
----------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;四、删除线&lt;/strong&gt;&lt;br&gt;
如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RUNOOB.COM
GOOGLE.COM
~~BAIDU.COM~~
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下划线&lt;/p&gt;
">markdown学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/git-xue-xi-bi-ji/"" data-c="
          &lt;p&gt;学习git之前，我们需要先明白一个概念：版本控制！&lt;/p&gt;
&lt;h1 id=&#34;版本控制&#34;&gt;版本控制&lt;/h1&gt;
&lt;p&gt;版本控制：版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现跨区域多人协同开发&lt;/li&gt;
&lt;li&gt;追踪和记载一个或者多个文件的历史记录&lt;/li&gt;
&lt;li&gt;组织和保护你的源代码和文档&lt;/li&gt;
&lt;li&gt;统计工作量&lt;/li&gt;
&lt;li&gt;并行开发、提高开发效率&lt;/li&gt;
&lt;li&gt;跟踪记录整个软件的开发过程&lt;/li&gt;
&lt;li&gt;减轻开发人员的负担，节省时间，同时降低人为错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单说就是用于管理多人协同开发项目的技术。&lt;/p&gt;
&lt;p&gt;没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。&lt;/p&gt;
&lt;p&gt;无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！&lt;br&gt;
多人开发就必须要使用版本控制！&lt;/p&gt;
&lt;h1 id=&#34;常见的版本控制工具&#34;&gt;常见的版本控制工具&lt;/h1&gt;
&lt;p&gt;我们学习的东西，一定是当下最流行的！&lt;/p&gt;
&lt;p&gt;主流的版本控制器有如下这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;li&gt;SVN（Subversion）&lt;/li&gt;
&lt;li&gt;CVS（Concurrent Versions System）&lt;/li&gt;
&lt;li&gt;VSS（Micorosoft Visual SourceSafe）&lt;/li&gt;
&lt;li&gt;TFS（Team Foundation Server）&lt;/li&gt;
&lt;li&gt;Visual Studio Online&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN&lt;/p&gt;
&lt;h1 id=&#34;版本控制分类&#34;&gt;版本控制分类&lt;/h1&gt;
&lt;h2 id=&#34;1-本地版本控制&#34;&gt;1、本地版本控制&lt;/h2&gt;
&lt;p&gt;记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。&lt;/p&gt;
&lt;h2 id=&#34;2-集中版本控制-svn&#34;&gt;2、集中版本控制  SVN&lt;/h2&gt;
&lt;p&gt;所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改&lt;br&gt;
所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS&lt;/p&gt;
&lt;h2 id=&#34;3-分布式版本控制-git&#34;&gt;3、分布式版本控制 	Git&lt;/h2&gt;
&lt;p&gt;每个人都拥有全部的代码！安全隐患！&lt;/p&gt;
&lt;p&gt;所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。&lt;/p&gt;
&lt;p&gt;不会因为服务器损坏或者网络问题，造成不能工作的情况！&lt;/p&gt;
&lt;p&gt;Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！&lt;/p&gt;
&lt;h1 id=&#34;git与svn的主要区别&#34;&gt;Git与SVN的主要区别&lt;/h1&gt;
&lt;p&gt;SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。&lt;br&gt;
Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！&lt;br&gt;
Git是目前世界上最先进的分布式版本控制系统。&lt;/p&gt;
&lt;h1 id=&#34;聊聊git的历史&#34;&gt;聊聊Git的历史&lt;/h1&gt;
&lt;p&gt;同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。&lt;/p&gt;
&lt;p&gt;Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。&lt;/p&gt;
&lt;p&gt;Linux社区中存在很多的大佬！破解研究 BitKeeper ！&lt;/p&gt;
&lt;p&gt;到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！&lt;/p&gt;
&lt;p&gt;Git是目前世界上最先进的分布式版本控制系统。&lt;/p&gt;
&lt;p&gt;Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！&lt;/p&gt;
&lt;h1 id=&#34;常用的linux命令&#34;&gt;常用的Linux命令&lt;/h1&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;cd : 改变目录。&lt;/li&gt;
&lt;li&gt;cd . . 回退到上一个目录，直接cd进入默认目录&lt;/li&gt;
&lt;li&gt;pwd : 显示当前所在的目录路径。&lt;/li&gt;
&lt;li&gt;ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。&lt;/li&gt;
&lt;li&gt;touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。&lt;/li&gt;
&lt;li&gt;rm:  删除一个文件, rm index.js 就会把index.js文件删除。&lt;/li&gt;
&lt;li&gt;mkdir:  新建一个目录,就是新建一个文件夹。&lt;/li&gt;
&lt;li&gt;rm -r :  删除一个文件夹, rm -r src 删除src目录&lt;/li&gt;
&lt;li&gt;rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！&lt;/li&gt;
&lt;li&gt;mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;reset 重新初始化终端/清屏。&lt;/li&gt;
&lt;li&gt;clear 清屏。&lt;/li&gt;
&lt;li&gt;history 查看命令历史。&lt;/li&gt;
&lt;li&gt;help 帮助。&lt;/li&gt;
&lt;li&gt;exit 退出。&lt;/li&gt;
&lt;li&gt;#表示注释&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;git配置&#34;&gt;Git配置&lt;/h1&gt;
&lt;p&gt;所有的配置文件，其实都保存在本地！&lt;br&gt;
查看配置 git config -l&lt;br&gt;
查看不同级别的配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#查看系统config
git config --system --list
　　
#查看当前用户（global）配置
git config --global  --list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Git相关的配置文件：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Git\etc\gitconfig  ：Git 安装目录下的 gitconfig     --system 系统级&lt;/li&gt;
&lt;li&gt;C:\Users\Administrator\ .gitconfig    只适用于当前登录用户的配置  --global 全局&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;设置用户名与邮箱用户标识必要&#34;&gt;设置用户名与邮箱（用户标识，必要）&lt;/h1&gt;
&lt;p&gt;当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name &amp;quot;kuangshen&amp;quot;  #名称
git config --global user.email 24736743@qq.com   #邮箱
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只需要做一次这个设置，如果你传递了--global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要--global选项。总之--global为全局配置，不加为某个项目的特定配置。&lt;/p&gt;
&lt;h1 id=&#34;git基本理论重要&#34;&gt;Git基本理论（重要）&lt;/h1&gt;
&lt;h2 id=&#34;三个区域&#34;&gt;三个区域&lt;/h2&gt;
&lt;p&gt;Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Workspace：工作区，就是你平时存放项目代码的地方&lt;/li&gt;
&lt;li&gt;Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息&lt;/li&gt;
&lt;li&gt;Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本&lt;/li&gt;
&lt;li&gt;Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;本地的三个区域确切的说应该是git仓库中HEAD指向的版本：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;+Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。&lt;br&gt;
+WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。&lt;br&gt;
+.git：存放Git管理信息的目录，初始化仓库的时候自动创建。&lt;br&gt;
+Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。&lt;br&gt;
+Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。&lt;br&gt;
+Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;工作流程&#34;&gt;工作流程&lt;/h2&gt;
&lt;p&gt;git的工作流程一般是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;１、在工作目录中添加、修改文件；&lt;/li&gt;
&lt;li&gt;２、将需要进行版本管理的文件放入暂存区域；&lt;/li&gt;
&lt;li&gt;３、将暂存区域的文件提交到git仓库。&lt;br&gt;
因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;git项目搭建&#34;&gt;Git项目搭建&lt;/h1&gt;
&lt;h2 id=&#34;创建工作目录与常用指令&#34;&gt;创建工作目录与常用指令&lt;/h2&gt;
&lt;p&gt;工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。&lt;/p&gt;
&lt;h2 id=&#34;本地仓库搭建&#34;&gt;本地仓库搭建&lt;/h2&gt;
&lt;p&gt;创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。&lt;br&gt;
1、创建全新的仓库，需要用GIT管理的项目的根目录执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 在当前目录新建一个Git代码库
$ git init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。&lt;/p&gt;
&lt;h2 id=&#34;克隆远程仓库&#34;&gt;克隆远程仓库&lt;/h2&gt;
&lt;p&gt;1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 克隆一个项目和它的整个代码历史(版本信息)
$ git clone [url]  # https://gitee.com/kuangstudy/openclass.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;git文件操作&#34;&gt;Git文件操作&lt;/h1&gt;
&lt;h2 id=&#34;文件的四种状态&#34;&gt;文件的四种状态&lt;/h2&gt;
&lt;p&gt;版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.&lt;/li&gt;
&lt;li&gt;Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件&lt;/li&gt;
&lt;li&gt;Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !&lt;/li&gt;
&lt;li&gt;Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;查看文件状态&#34;&gt;查看文件状态&lt;/h2&gt;
&lt;p&gt;上面说文件有4种状态，通过如下命令可以查看到文件的状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#查看指定文件状态
git status [filename]

#查看所有文件状态
git status

# git add .                  添加所有文件到暂存区
# git commit -m &amp;quot;消息内容&amp;quot;    提交暂存区中的内容到本地仓库 -m 提交信息
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;忽略文件&#34;&gt;忽略文件&lt;/h2&gt;
&lt;p&gt;有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等&lt;br&gt;
在主目录下建立&amp;quot;.gitignore&amp;quot;文件，此文件有如下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;忽略文件中的空行或以井号（#）开始的行将会被忽略。&lt;/li&gt;
&lt;li&gt;可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,...}）代表可选的字符串等。&lt;/li&gt;
&lt;li&gt;如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。&lt;/li&gt;
&lt;li&gt;如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。&lt;/li&gt;
&lt;li&gt;如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;git分支&#34;&gt;GIT分支&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;# 列出所有本地分支
git branch

# 列出所有远程分支
git branch -r

# 新建一个分支，但依然停留在当前分支
git branch [branch-name]

# 新建一个分支，并切换到该分支
git checkout -b [branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
&lt;/code&gt;&lt;/pre&gt;
">git学习笔记</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>







</html>