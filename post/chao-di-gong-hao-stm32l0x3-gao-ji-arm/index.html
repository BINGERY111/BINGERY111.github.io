<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="向上攀爬之路不是比站在顶峰更让人热血澎湃吗">
<meta name="theme-color" content="#000">
<title>超低功耗 STM32L0x3 高级 ARM | 个人笔记</title>
<link rel="shortcut icon" href="/favicon.ico?v=1649723524097">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/default.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






  <meta name="description" content="超低功耗 STM32L0x3 高级 ARM" />
  <meta name="keywords" content="" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>个人笔记</span>
            </a>  
          
        </div>
        
          <p class="subtitle">精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友链
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">我是谁</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>笔记</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">13</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">0</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper  auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%BC%A9%E5%86%99%E8%AF%8D">寄存器缩写词</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E8%AF%8D%E6%B1%87">相关词汇</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84">系统架构</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://bingery111.github.io/post/chao-di-gong-hao-stm32l0x3-gao-ji-arm/"> 超低功耗 STM32L0x3 高级 ARM </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2022-03-08 20:57:30">2022-03-08</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >2<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >427<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <h4 id="寄存器缩写词">寄存器缩写词</h4>
<p>rw（读/写）：软件可以读写这些位<br>
只读 (r) ：软件只能读取这些位。<br>
只写 (w) ：软件只能写入该位。读取该位时将返回复位值。<br>
读取/清零(rc_w1)：软件可以读取该位，也可以通过写入 1 将该位清零。<br>
读取/清零(rc_w0)：软件可以读取该位，也可以通过写入 0 将该位清零。<br>
读取/读取清零(rc_r)：软件可以读取该位。读取该位时，将自动清零。<br>
读取/置位 (rs) ：软件可以读取该位，也可将其置 1。<br>
保留 (Res.) ：保留位，必须保持复位值。</p>
<h4 id="相关词汇">相关词汇</h4>
<p>扇区： 代码区域中的 32 页写保护数据块<br>
页： 32 个字表示代码和系统存储区， 1 个字表示数据、出厂选项和用户选项区<br>
字： 32 位数据。<br>
半字： 16 位数据。<br>
字节： 8 位数据。<br>
IAP（在应用中编程） ： IAP 是指可以在用户程序运行期间对微控制器的 Flash 进行重新<br>
编程。<br>
ICP（在线编程） ： ICP 是指可以在器件安装于用户应用电路板上时使用 JTAG 协议、<br>
SWD 协议或自举程序对微控制器的 Flash 进行编程。<br>
选项字节：存储于 Flash 中的产品配置位。<br>
OBL：选项字节加载器。<br>
AHB：高级高性能总线。<br>
NVM： 非易失性存储器。<br>
ECC：误码校正。<br>
DMA：直接存储器访问。<br>
MIF： NVM 接口。<br>
PCROP：专有代码读保护。</p>
<h4 id="系统架构">系统架构</h4>
<p>两个主器件：<br>
– Cortex®-M0+内核（AHB-lite 总线）<br>
– GP-DMA，通用微控制器</p>
<p>三个从器件：<br>
– 内部 SRAM<br>
– 内部非易失性存储器<br>
– AHB到APB，连接所有APB外设</p>

            </div>
            
              <div class="reward-btn">
                <div class="reward-btn-text">赞赏</div>
              </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      我是谁
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://bingery111.github.io/post/chao-di-gong-hao-stm32l0x3-gao-ji-arm/" title="超低功耗 STM32L0x3 高级 ARM">https://bingery111.github.io/post/chao-di-gong-hao-stm32l0x3-gao-ji-arm/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="单片机笔记-基于STM32" href="https://bingery111.github.io/post/dan-pian-ji-usart-chuan-kou-tong-xin-bi-ji/">单片机笔记-基于STM32</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="单片机笔记-基于STM32" href="https://bingery111.github.io/post/dan-pian-ji-usart-chuan-kou-tong-xin-bi-ji/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="SX1276/77/78/79" href="https://bingery111.github.io/post/sx1276777879/">SX1276/77/78/79</a>
        <a class="nav-mobile-next" title="SX1276/77/78/79" href="https://bingery111.github.io/post/sx1276777879/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
    
        <div class="gemini back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "false";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/kao-yan-ying-yu-li-ju/"" data-c="
          &lt;p&gt;The file has a fame ending.&lt;br&gt;
那电影的结局枯燥无味。&lt;/p&gt;
&lt;p&gt;I was born to fame you.&lt;br&gt;
我生来就是要驯服你。&lt;/p&gt;
&lt;p&gt;She spent hours trying to fame her unruly hair.&lt;br&gt;
她花了几个小时试图梳理她那难以平整的头发、&lt;/p&gt;
&lt;p&gt;A huge banner over the street said &amp;quot;Welcome home&amp;quot;.&lt;br&gt;
街道上的一条巨大横幅上写着“欢迎归来”。&lt;/p&gt;
&lt;p&gt;hold up a banner&lt;br&gt;
举起旗帜&lt;/p&gt;
&lt;p&gt;Can you read that banner from this distance?&lt;br&gt;
从这里你尅看到哪个横幅标语吗？&lt;/p&gt;
">考研英语例句</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/dan-pian-ji-usart-chuan-kou-tong-xin-bi-ji/"" data-c="
          &lt;h3 id=&#34;串口通信协议简介&#34;&gt;串口通信协议简介&lt;/h3&gt;
&lt;p&gt;芯片被分为内核层和片上外设，通信协议基本划分为物理层和协议层，物理层规定通信系统中的机械、电子功能部分的特性，确保原始数据在物理媒体中的传输。&lt;br&gt;
协议层规定通信逻辑，统一收发双方的数据打包，确保原始数据在物理媒体中的传输。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;物理层&#34;&gt;物理层&lt;/h4&gt;
&lt;h3 id=&#34;协议层&#34;&gt;协议层&lt;/h3&gt;
&lt;h3 id=&#34;stm32的usart简介&#34;&gt;STM32的USART简介&lt;/h3&gt;
&lt;h3 id=&#34;usart功能框图剖析&#34;&gt;USART功能框图剖析&lt;/h3&gt;
&lt;h3 id=&#34;usart初始化结构体详解&#34;&gt;USART初始化结构体详解&lt;/h3&gt;
&lt;h3 id=&#34;usart1接发通信实验&#34;&gt;USART1接发通信实验&lt;/h3&gt;
&lt;h3 id=&#34;硬件设计&#34;&gt;硬件设计&lt;/h3&gt;
&lt;h3 id=&#34;软件设计&#34;&gt;软件设计&lt;/h3&gt;
&lt;h3 id=&#34;下载验证&#34;&gt;下载验证&lt;/h3&gt;
&lt;h3 id=&#34;使用usart1指令控制rgb彩灯实验&#34;&gt;使用USART1指令控制RGB彩灯实验&lt;/h3&gt;
&lt;h4 id=&#34;硬件设计-2&#34;&gt;硬件设计&lt;/h4&gt;
&lt;h4 id=&#34;软件设计-2&#34;&gt;软件设计&lt;/h4&gt;
&lt;h4 id=&#34;下载验证-2&#34;&gt;下载验证&lt;/h4&gt;
">单片机笔记-基于STM32</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/chao-di-gong-hao-stm32l0x3-gao-ji-arm/"" data-c="
          &lt;h4 id=&#34;寄存器缩写词&#34;&gt;寄存器缩写词&lt;/h4&gt;
&lt;p&gt;rw（读/写）：软件可以读写这些位&lt;br&gt;
只读 (r) ：软件只能读取这些位。&lt;br&gt;
只写 (w) ：软件只能写入该位。读取该位时将返回复位值。&lt;br&gt;
读取/清零(rc_w1)：软件可以读取该位，也可以通过写入 1 将该位清零。&lt;br&gt;
读取/清零(rc_w0)：软件可以读取该位，也可以通过写入 0 将该位清零。&lt;br&gt;
读取/读取清零(rc_r)：软件可以读取该位。读取该位时，将自动清零。&lt;br&gt;
读取/置位 (rs) ：软件可以读取该位，也可将其置 1。&lt;br&gt;
保留 (Res.) ：保留位，必须保持复位值。&lt;/p&gt;
&lt;h4 id=&#34;相关词汇&#34;&gt;相关词汇&lt;/h4&gt;
&lt;p&gt;扇区： 代码区域中的 32 页写保护数据块&lt;br&gt;
页： 32 个字表示代码和系统存储区， 1 个字表示数据、出厂选项和用户选项区&lt;br&gt;
字： 32 位数据。&lt;br&gt;
半字： 16 位数据。&lt;br&gt;
字节： 8 位数据。&lt;br&gt;
IAP（在应用中编程） ： IAP 是指可以在用户程序运行期间对微控制器的 Flash 进行重新&lt;br&gt;
编程。&lt;br&gt;
ICP（在线编程） ： ICP 是指可以在器件安装于用户应用电路板上时使用 JTAG 协议、&lt;br&gt;
SWD 协议或自举程序对微控制器的 Flash 进行编程。&lt;br&gt;
选项字节：存储于 Flash 中的产品配置位。&lt;br&gt;
OBL：选项字节加载器。&lt;br&gt;
AHB：高级高性能总线。&lt;br&gt;
NVM： 非易失性存储器。&lt;br&gt;
ECC：误码校正。&lt;br&gt;
DMA：直接存储器访问。&lt;br&gt;
MIF： NVM 接口。&lt;br&gt;
PCROP：专有代码读保护。&lt;/p&gt;
&lt;h4 id=&#34;系统架构&#34;&gt;系统架构&lt;/h4&gt;
&lt;p&gt;两个主器件：&lt;br&gt;
– Cortex®-M0+内核（AHB-lite 总线）&lt;br&gt;
– GP-DMA，通用微控制器&lt;/p&gt;
&lt;p&gt;三个从器件：&lt;br&gt;
– 内部 SRAM&lt;br&gt;
– 内部非易失性存储器&lt;br&gt;
– AHB到APB，连接所有APB外设&lt;/p&gt;
">超低功耗 STM32L0x3 高级 ARM</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/sx1276777879/"" data-c="
          &lt;h3 id=&#34;特点&#34;&gt;特点&lt;/h3&gt;
&lt;p&gt;137HZ~1020MHZ低功耗远程收发器&lt;/p&gt;
&lt;h3 id=&#34;调制技术-lora&#34;&gt;调制技术-LoRa&lt;/h3&gt;
&lt;p&gt;与传统调制技术相比，LoRa在阻塞和选择性方面有很大优势，解决设计在范围、抗干扰性和能耗之间的折中问题&lt;/p&gt;
&lt;h3 id=&#34;主要产品特性&#34;&gt;主要产品特性&lt;/h3&gt;
&lt;p&gt;1、能够实现比现有基于 FSK 或 OOK 调制的系统更长的范围。用户可以决定扩频调制带宽 (BW)、扩频因子 (SF) 和纠错率 (CR)。 扩频调制的另一个好处是每个扩频因子都是正交的——因此&lt;strong&gt;多个传输信号可以占用同一信道而不会产生干扰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2、需要ESD防护&lt;br&gt;
3、温度、电压和RF的最大值，超过最大值会失去稳定性。&lt;/p&gt;
">SX1276/77/78/79</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/fm33g0xx/"" data-c="
          &lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;一-产品综述&#34;&gt;一、产品综述&lt;/h3&gt;
&lt;h4 id=&#34;1-性能指标&#34;&gt;1、性能指标&lt;/h4&gt;
&lt;p&gt;极限参数：电源电压，管脚电压、工作温度、存储温度、静放电（ESD）、人体放电（HBM）、Latch-up（闩锁效应）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;静电放电:&lt;/strong&gt;&lt;br&gt;
静电放电是造成所有电子元器件或集成电路系统造成过度电应力(EOS: Electrical Over Stress)破坏的主要元凶。因为静电通常瞬间电压非常高(&amp;gt;几千伏)，所以这种损伤是毁灭性和永久性的，会造成电路直接烧毁。所以预防静电损伤是所有IC设计和制造的头号难题。&lt;br&gt;
静电放电（ESD）抗扰度测试是重要的电磁兼容性（EMC）测试之一。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;ESD的标准以及测试方法：&lt;/strong&gt;&lt;br&gt;
根据静电的产生方式以及对电路的损伤模式不同通常分为&lt;strong&gt;四种测试&lt;/strong&gt;方式： 人体放电模式(HBM: Human-Body Model)、机器放电模式(Machine Model)、元件充电模式(CDM: Charge-Device Model)、电场感应模式(FIM: Field-Induced Model)，但是业界通常使用前两种模式来测试(HBM, MM)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1)  人体放电模式(HBM）&lt;/strong&gt;&lt;br&gt;
当然就是人体摩擦产生了电荷突然碰到芯片释放的电荷导致芯片烧毁击穿，秋天和别人触碰经常触电就是这个原因。业界对HBM的ESD标准也有迹可循(MIL- STD-883C method 3015.7，等效人体电容为100pF，等效人体电阻为1.5Kohm)，或者国际电子工业标准(EIA/JESD22-A114-A)也有规定，看你要follow哪一份了。&lt;/p&gt;
&lt;p&gt;如果是MIL-STD-883C method 3015.7，它规定小于&amp;lt;2kV的则为Class-1，在2kV&lt;sub&gt;4kV的为class-2，4kV&lt;/sub&gt;16kV的为class-3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2)  机器放电模式(MM)：&lt;/strong&gt;&lt;br&gt;
当然就是机器(如robot)移动产生的静电触碰芯片时由pin脚释放，次标准为EIAJ-IC-121 method 20(或者标准EIA/JESD22-A115-A)，等效机器电阻为0 (因为金属)，电容依旧为100pF。由于机器是金属且电阻为0，所以放电时间很短，几乎是ms或者us之间。但是更重要的问题是，由于等效电阻为0，所以电流很大，所以即使是200V的MM放电也比2kV的HBM放电的危害大。而且机器本身由于有很多导线互相会产生耦合作用，所以电流会随时间变化而干扰变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）组件充电模式 (Charged-Device Model, CDM)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此放电模式是指IC先&lt;strong&gt;因磨擦或其它因素而在IC内部累积了静电&lt;/strong&gt;，但在静电累积的过程中IC并未被损伤。此带有静电的IC在处理过程中，当其pin去碰触到接地面时，IC内 部的静电便会经由pin自IC内部流出来，而造成了放电的现象。&lt;br&gt;
　　此种模式的放电时间更短，仅约几毫微秒之内，而且放电现象更难以真实的被模拟。因为IC内部累积的静电会 因IC组件本身对地的等效电容而变，IC摆放的角度与位置 以及IC所用的包装型式都会造成不同的等效电容。由于具 有多项变化因素难定，因此，有关此模式放电的工业测试 标准仍在协议中，但已有此类测试机台在销售中。该组件 充电模式(CDM) ESD可能发生的原因及放电的情形显示于&lt;br&gt;
　　图2.3-1(a)与图2.3-1(b)中。该组件充电模式静电放电的等效 电路图显示于图2.3-2(a)中。IC在名种角度摆放下的等效电 容值显示于图2.3-2(b)中，此电容值会导致不同的静电电量 累积于IC内部。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;闩锁效应：&lt;/strong&gt;&lt;br&gt;
Latch-up原理&lt;/p&gt;
&lt;p&gt;Latch up 最易产生在易受外部干扰的I/O电路处, 也偶尔发生在内部电路。&lt;/p&gt;
&lt;p&gt;Latch up 是指cmos晶片中, 在电源power VDD和地线GND(VSS)之间由于寄生的PNP和NPN双极性BJT相互影响而产生的一低阻抗通路, 它的存在会使VDD和GND之间产生大电流。&lt;/p&gt;
&lt;p&gt;Latch-up发生的条件：&lt;br&gt;
(i)当两个BJT都导通，在VDD和GND之间产生低阻抗通路;&lt;br&gt;
(ii) 两个晶体管反馈回路（feedback loop）增益的乘积大于1&lt;br&gt;
&lt;img src=&#34;:/9ab75daaf1cd430ca3cea48f007d2ed4&#34; alt=&#34;ddeb9b2937bca9f07cf62afd75336dd7.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Latch-up产生机制和抑制方法：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;Latch-up产生机制&lt;/strong&gt;：&lt;br&gt;
(i)输入或输出电压（I/O的信号）高于VDD电压，芯片产生大电流，导致latch-up;&lt;br&gt;
(ii)ESD静电加压，可能会从保护电路中引入少量带电载流子到阱或衬底中，导致latch-up;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;source（拉电流）和sink（灌电流）详解&lt;br&gt;
  名词解释 —— 灌：注入、填充，由外向内、由虚而实。渴了，来一大杯鲜榨橙汁，一饮而尽，饱了，这叫 “ 灌 ” 。&lt;br&gt;
  灌电流（ sink current ）   ，对一个端口而言，如果电流方向是向其内部流动的则是 “ 灌电流 ” ，比如一个 IO 通过一个电阻和一个 LED 连接至 VCC ，当该IO输出为逻辑0时能不能点亮LED，去查该器件手册中sink current参数。&lt;br&gt;
  名词解释——拉：流出、排空，由内向外，由实而虚。一大杯鲜橙汁喝了，过会儿，憋的慌，赶紧找卫生间，一阵“大雨”，舒坦了，这叫“拉”。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;  拉电流（sourcing current），对一个端口而言，如果电流方向是向其外部流动的则是“拉电流”，比如一个IO通过一个电阻和一个LED连至GND，当该IO输出为逻辑1时能不能点亮LED，去查该器件手册中sourcing current参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拉电流与灌电流&lt;/strong&gt;&lt;br&gt;
概念&lt;br&gt;
  拉电流和灌电流是衡量电路输出驱动能力（注意：拉、灌都是对输出端而言的，所以是驱动能力）的参数，这种说法一般用在数字电路中。&lt;br&gt;
  这里首先要说明，芯片手册中的拉、灌电流是一个参数值，是芯片在实际电路中允许输出端拉、灌电流的上限值（允许最大值）。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;2-电源&#34;&gt;2、电源：&lt;/h4&gt;
&lt;p&gt;1、电源电压&lt;br&gt;
2、内核电源电压&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3-供电电流&#34;&gt;3、供电电流&lt;/h3&gt;
&lt;p&gt;sleep模式：Sleep 模式；BOR、 RCHF、 SVD、 LCD 显示关闭，32K 晶振运行， RTC 走时， CPU、RAM、外设数据保持；&lt;/p&gt;
&lt;p&gt;sleep2模式：Sleep 模式；BOR、 RCHF、 SVD 关闭， LCD 使能片内电阻模式， 32K 晶振运行， RTC走时， CPU、 RAM、外设数据保持；&lt;/p&gt;
&lt;p&gt;深度sleep模式：深度 Sleep 模式电流、DeepSleep 模式；BOR、 RCHF、 SVD、 LCD 显示关闭，&lt;br&gt;
32K 晶振运行， RTC 走时， CPU、RAM、外设数据保持；&lt;/p&gt;
&lt;p&gt;RTC Backup模式电流：RTCBKP模式； PDR使能，RTC运行RAM、CPU状态不保持，备份寄存器保持；&lt;/p&gt;
&lt;p&gt;LPRUN模式电流：LPRUN模式； BOR、RCHF、SVD、LCD关闭32K晶振运行，CPU以32KHz运行，从Flash取指&lt;/p&gt;
&lt;p&gt;正常模式VDD电流：正常工作模式， fmclk=16MHz（RCHF），从Flash中执行代码&lt;/p&gt;
&lt;p&gt;正常模式VDD电流：正常工作模式， fmclk-36MHz（RCHF从Flash中执行代码&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;欠压复位&lt;/strong&gt;&lt;br&gt;
欠压复位（以下称为BOR）是单片机可靠性的一项重要功能，通常用于解决电源问题，下面将介绍欠压复位的另一个问题。&lt;br&gt;
单片机的“电量不足”是电源电压不足或暂时降低，低于可靠运行所需的水平。许多单片机具有保护电路，该电路可检测电源电压何时低于此水平，并将设备置于复位状态，以确保在电源恢复时正确启动。此操作也称为“欠压复位”，英文缩写为“BOR”。&lt;/p&gt;
&lt;p&gt;类似的功能称为低电压检测（LVD），它更复杂，增加了对多个电压电平的检测，可以在触发复位之前产生中断。&lt;/p&gt;
&lt;h4 id=&#34;2-引脚和封装&#34;&gt;2、引脚和封装&lt;/h4&gt;
&lt;h4 id=&#34;3-焊接安装&#34;&gt;3、焊接安装&lt;/h4&gt;
">FM33G0xx</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/cbi-ji/"" data-c="
          &lt;p&gt;[!toc]&lt;/p&gt;
&lt;h1 id=&#34;第一章-预备知识&#34;&gt;第一章 预备知识&lt;/h1&gt;
&lt;p&gt;C++总览简介&lt;/p&gt;
&lt;p&gt;C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。&lt;br&gt;
C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。&lt;br&gt;
C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。&lt;br&gt;
C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。&lt;/p&gt;
&lt;p&gt;注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。&lt;/p&gt;
&lt;p&gt;面向对象程序设计&lt;/p&gt;
&lt;p&gt;C++最大的亮点就是面向对象程序设计理念的运用。包括面向对象开发的四大特性：&lt;br&gt;
封装&lt;br&gt;
抽象&lt;br&gt;
继承&lt;br&gt;
多态&lt;/p&gt;
&lt;p&gt;C++的组成部分&lt;/p&gt;
&lt;p&gt;标准的 C++ 由三个重要部分组成：&lt;br&gt;
核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。&lt;br&gt;
C++ 标准库，提供了大量的函数，用于操作文件、字符串等。&lt;br&gt;
标准模板库（STL），提供了大量的方法，用于操作数据结构等。&lt;/p&gt;
&lt;h1 id=&#34;第三章-处理数据&#34;&gt;第三章 处理数据&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;面向对象编程（OOP）的本质是设计并扩展自己的数据类型。设计自己的数据类型就是让类型与数据匹配。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内置的C++类型分两组：基本类型和复合类型。本章将介绍基本类型，即整数和浮点数。似乎只有两种类型，但C++知道，没有任何一种整型和浮点型能够满足所有的编程要求，因此对于这两种数据，它提供 了多种变体。&lt;/p&gt;
&lt;h2 id=&#34;31-简单变量&#34;&gt;3.1 简单变量&lt;/h2&gt;
&lt;p&gt;把信息存储在计算机中，程序必须记录3个基本属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信息将存储在哪里；&lt;/li&gt;
&lt;li&gt;要存储什么值；&lt;/li&gt;
&lt;li&gt;存储何种类型的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，程序将找到一块能够存储整数的内存，将该内存单元标记为braincount，并将5复制到该内存单元中；然 后，您可在程序中使用braincount来访问该内存单元。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以使用&amp;amp;运算符来检索braincount的内存地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;311-变量名&#34;&gt;3.1.1 变量名&lt;/h3&gt;
&lt;p&gt;C++ 提倡使用有一定含义的变量名，并遵循几 种简单的 C++ 命名规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在名称中只能使用字母字符、数字和下划线 ( _ )；&lt;/li&gt;
&lt;li&gt;名称的第一个字符不能是数字；&lt;/li&gt;
&lt;li&gt;区分大写字符与小写字符；&lt;/li&gt;
&lt;li&gt;不能将C++关键字用作名称；&lt;/li&gt;
&lt;li&gt;以&lt;em&gt;两个下划线&lt;/em&gt; 或 &lt;em&gt;下划线+大写字母&lt;/em&gt; 打头的名称被保留给实现（编译器及其使用的资源）使用；&lt;/li&gt;
&lt;li&gt;以 &lt;em&gt;一个下划线&lt;/em&gt; 开头的名称被保留给实现，用作全局标识符；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;倒数第二点与前面几点有些不同，因为使用像 __time_stop 或 _Donut 这样的名称不会导致编译器错误，而会导致行为的不确定性。换句话说，不知道结果将是什么。不出现编译器错误的原因是，这样的名称不 是非法的，但要留给实现使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719213322578.png&#34; alt=&#34;image-20210719213322578&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果想用两个或更多的单词组成一个名称，通常的做法是用下划线字符将单词分开，如 my_onions (&lt;strong&gt;用这类&lt;/strong&gt;)；或者从第二个单词开始将每个单词的第一个字母大写，如 myEyeTooth。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 C++ 所有主观的风格中，一致性和精度是最重要的&lt;/strong&gt;。请根据自己的需要、喜好和个人风格来使用变量名（或必要时，根据雇主的需要、喜好和个人风格来选择变量名）。&lt;/p&gt;
&lt;h3 id=&#34;312-整型&#34;&gt;3.1.2 整型&lt;/h3&gt;
&lt;p&gt;不同C++整型使用不同的内存量来存储整数。使用的内存量越大，可以表示的整数值范围也越大。&lt;/p&gt;
&lt;p&gt;C++的基本整型（按宽度递增的顺序排列）分别是char、short、int、long和C++11新增的long long，其中每种类型都有符号版本和无符号版本，因此总共有10种类型可供选择。&lt;/p&gt;
&lt;h3 id=&#34;313-整型short-int-long和long-long&#34;&gt;3.1.3 整型short、int、long和long long&lt;/h3&gt;
&lt;p&gt;C++ 的short、int、long和long long类型通过使用不同数目的位来存储值，最多能够表示4种不同的整数宽度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;short至少16位；&lt;/li&gt;
&lt;li&gt;int至少与short一样长；&lt;/li&gt;
&lt;li&gt;long 至少32位，且至少与int一样长；&lt;/li&gt;
&lt;li&gt;long long至少64位，且至少与long一样长。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这意味着可以把16位单元设置成65 536个不同的值，把 32位单元设置成4 294 672 296个不同的值，把64位单元设置为18 446 744 073 709 551 616个不同的值。作为比较，unsigned long存储不了地球上当前的人数和银河系的星星数，而long long 能够。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当前很多系统都使用最小长度，即short为16位，long为32位。这仍然为int提供了多种选择，其宽度可以是16位、24位或32位，同时又符合标准；甚至可以是64位，因为long和long long至少长64位。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;类型的宽度随实现而异，这可能在将C++程序从一种环境移到另一种环境（包括在同一个系统中使用不同编译器）时引发问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，sizeof运算符返回类型或变量的长度；其次，头文件climits（在老式实现中为limits.h）中包含了关于整型限制的信息。具体地说，它定义了表示各种限制的符号名称。例如，INT_MAX为int的最大取值，CHAR_BIT为字节的位数。&lt;/p&gt;
&lt;p&gt;在我的 Macbook Air 64位 OS 上，数据类型是这样的:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;int is 4 bytes.
short is 2 bytes.
long is 8 bytes.
long long is 8 bytes.

Maximum values:
int: 2147483647
short: 32767
long: 9223372036854775807
long long: 9223372036854775807

Minimum int value = -2147483648
Bits per byte = 8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719215348315.png&#34; alt=&#34;image-20210719215348315&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719215405073.png&#34; alt=&#34;image-20210719215405073&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;**赋值与声明合并在一起叫做初始化。**如果知道变量的初始值应该是什么，则应对它进行初始化。&lt;/p&gt;
&lt;p&gt;如果不对函数内部定义的变量进行初始化，该变量的值将是不确定的。这意味着该变量的值 将是它被创建之前，相应内存单元保存的值。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719215954131.png&#34; alt=&#34;image-20210719215954131&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;314-无符号类型&#34;&gt;3.1.4 无符号类型&lt;/h3&gt;
&lt;p&gt;要创建无符号版 本的基本整型，只需使用关键字 unsigned 来修改声明即可。注意，unsigned本身是unsigned int的缩写。&lt;/p&gt;
&lt;h3 id=&#34;315-选择整型类型&#34;&gt;3.1.5 选择整型类型&lt;/h3&gt;
&lt;p&gt;通常，int被设置为对 目标计算机而言最为“自然”的长度。自然长度（natural size）指的是计 算机处理起来效率最高的长度。如果没有非常有说服力的理由来选择其 他类型，则应使用int。&lt;/p&gt;
&lt;p&gt;如果知道变量可能表示的整数值大于16位整数的最大可能值，则使用long。即使系统上int为32位，也应这样做。这样，将程序移植到16位系统时，就不会突然无法正常工作（参见图3.2）。如果要存储的值超过20亿，可使用long long。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所以对于基因组数据上的位置信息，最好是 long 类型咯，即便 unsigned int 类型已经足够。（不过我可能还是希望用 unsigned int ）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719220858422.png&#34; alt=&#34;image-20210719220858422&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果short比int小，则使用short可以节省内存。通常，仅当有大型整 型数组时，才有必要使用short。如果只需要一个字节，可使用char。&lt;/p&gt;
&lt;h3 id=&#34;316-整型字面值&#34;&gt;3.1.6 整型字面值&lt;/h3&gt;
&lt;p&gt;整型字面值（常量）是显式地书写的常量，如212或1776。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;诸如cout&amp;lt;&amp;lt;hex;等代码不会在屏幕上显示任何内容，而只是修改 cout显示整数的方式。因此，控制符hex实际上是一条消息，告诉cout采 取何种行为。另外，由于标识符hex位于名称空间std中，而程序使用了 该名称空间，因此不能将hex用作变量名。然而，如果省略编译指令 using，而使用std::cout、std::endl、std::hex和std::oct，则可以将hex用作 变量名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;317-c如何确定常量的类型&#34;&gt;3.1.7 C++如何确定常量的类型&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719221757664.png&#34; alt=&#34;image-20210719221757664&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;318-char类型字符和小整数&#34;&gt;3.1.8 char类型：字符和小整数&lt;/h3&gt;
&lt;p&gt;char类型是专为存 储字符（如字母和数字）而设计的。&lt;/p&gt;
&lt;p&gt;char类型是另一种整型。实际上，很多系统支持的字符都不超过128个，因此用一个字节就可以表示所有的符号。因此，虽然char最常被用来处理字符，但也可以 将它用做比short更小的整型。&lt;/p&gt;
&lt;p&gt;C++对字符用单引号，对字符串使用双引号。 cout对象能够处理这两种情况，但正如第4章将讨论的，这两者有天壤之别）。&lt;/p&gt;
&lt;p&gt;与int不同的是，char在默认情况下既不是没有符号，也不是有符号。是否有符号由C++实现决定，这样编译器开发人员可以最大限度地将这种类型与硬件属性匹配起来。如果char有某种特定的行为对您来说 非常重要，则可以显式地将类型设置为signed char 或unsigned char。&lt;/p&gt;
&lt;p&gt;如果将char用作数值类型，则unsigned char和signed char之间的差异将非常重要。unsigned char类型的表示范围通常为0～255，而signed char 的表示范围为−128到127。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如，假设要使用一个char变量来存储像200这样大的值，则在某些系统上可以，而在另一些系统上可能不可以。但 使用unsigned char可以在任何系统上达到这种目的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果大型字符 集是实现的基本字符集(如中文日文系统)，则编译器厂商可以将char定义为一个16位的字节或更长的字节。其次，一种实现可以同时支持一个小型基本字符集和 一个较大的扩展字符集。8位char可以表示基本字符集，另一种类型 wchar_t（宽字符类型）可以表示扩展字符集。wchar_t类型是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集。这种类 型与另一种整型（底层（underlying）类型）的长度和符号属性相同。对底层类型的选择取决于实现，因此在一个系统中，它可能是unsigned short，而在另一个系统中，则可能是int。&lt;/p&gt;
&lt;h2 id=&#34;32-const-限定符&#34;&gt;3.2 const 限定符&lt;/h2&gt;
&lt;p&gt;C++有一种比 &lt;code&gt;#define&lt;/code&gt; 更好的处理符号常量的方法，这种方法就是使用 const 关键字来修改变量声明和初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;const int Months = 12;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常量（如Months）被初始化后，其值就被固定 了，编译器将不允许再修改该常量的值。如果您这样做，g++将指出程 序试图给一个只读变量赋值。关键字const叫做限定符，因为它限定了声 明的含义。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;#define 定义符号常量的方式应抛弃。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一种常见的做法是将名称的首字母大写，以提醒您Months是个常量。这决不是一种通用约定，但在阅读程序时有助于区分常量和变量。另一种约定是将整个名称大写，使用#define创建常量时通常使用这种约定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 如果在声明常量时没有提供值，则该常量的值将是不确定的，且无 法修改。&lt;/p&gt;
&lt;h2 id=&#34;33-浮点数&#34;&gt;3.3 浮点数&lt;/h2&gt;
&lt;p&gt;使用浮点类型可以表示诸如2.5、3.14159和122442.32这样的数字，即带小数部分的数字。计算机将这样的值分成两部分存储。一部分表示值，另一部分用于对值进行放大或缩小。下面打个比方。对于数字34.1245和34124.5，它们除了小数点的位置不同外，其他都是相同的。 可以把第一个数表示为0.341245（基准值）和100（缩放因子），而将第二个数表示为0.341245（基准值相同）和10000（缩放因子更大）。缩放因子的作用是移动小数点的位置，术语浮点因此而得名。C++内部表示浮点数的方法与此相同，只不过它基于的是二进制数，因此缩放因 子是2的幂，不是10的幂。&lt;/p&gt;
&lt;h3 id=&#34;331-书写浮点数&#34;&gt;3.3.1 书写浮点数&lt;/h3&gt;
&lt;p&gt;C++有两种书写浮点数的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种是使用常用的标准小数点表示法；&lt;/li&gt;
&lt;li&gt;第二种表示浮点值的方法叫做E表示法，其外观是像这样的： 3.45E6，这指的是3.45与1000000相乘的结果；E6指的是10的6次方，即 1后面6个0。因此，3.45E6表示的是3450000，6被称为指数，3.45被称为 尾数。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719225234354.png&#34; alt=&#34;image-20210719225234354&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;E表示法确保数字以浮点格式存储，即使没有小数点。注意，既可 以使用E也可以使用e，指数可以是正数也可以是负数，不要有空格。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719224852195.png&#34; alt=&#34;image-20210719224852195&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;电子的质量是 9.11e-31 kg 表示 0.000000000000000000000000000000911 kg， 而美国报警电话 911 竟然很巧合地与此相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;332-浮点类型&#34;&gt;3.3.2 浮点类型&lt;/h3&gt;
&lt;p&gt;C++也有3种浮点类型：float、double 和 long double。&lt;/p&gt;
&lt;p&gt;事实上，C和C++对于有效位数的要求是，float至少32位，double至少48位，且不少于float，long double至少和double一样多。这三种类型的有效位数可以一样多。然而，通常，float为32位，double为64位， long double为80、96或128位。另外，这3种类型的指数范围至少是−37到37。可以从头文件cfloat或float.h中找到系统的限制。&lt;/p&gt;
&lt;h3 id=&#34;333-浮点常量&#34;&gt;3.3.3 浮点常量&lt;/h3&gt;
&lt;p&gt;在默认情况下，像8.24和2.4E8这样的浮点常量都属于double类型。如果希望常量为float类型，请使用f或F后缀。对于long double类型，可使用l或L后缀（由于l看起来像数字1，因此L是更好的选择）。&lt;/p&gt;
&lt;h3 id=&#34;334-浮点数的优缺点&#34;&gt;3.3.4 浮点数的优缺点&lt;/h3&gt;
&lt;p&gt;与整数相比，浮点数有两大优点。首先，可以表示整数之间的 值。其次，由于有缩放因子，它们可以表示的范围大得多。另一方面， &lt;strong&gt;浮点运算的速度通常比整数运算慢，且精度将降低&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如: 2.34E+22是一个小数点左边有23位的数字。加上1，就 是在第23位加1。但float类型只能表示数字中的前6位或前7位，因此修改第23位对这个值不会有任何影响。&lt;/p&gt;
&lt;h2 id=&#34;34-c算术运算符&#34;&gt;3.4 C++算术运算符&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719230134697.png&#34; alt=&#34;image-20210719230134697&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;11.17 + 50.25&lt;/code&gt; 应等于61.42，但是输出的却是61.419998。这不是运算问题，而是由于float类型表示有效位数的能力有限。记住，对于float，C++只保证6位有效位。如果将 61.419998四舍五入成6位，将得到61.4200，这是在保证精度下的正确值，如果用double 则精度足够，所以直接可以获得 61.42 的值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通常来说 double 都比 float 更精准，应尽量使用 double。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;341-运算符优先级和结合性&#34;&gt;3.4.1 运算符优先级和结合性&lt;/h3&gt;
&lt;p&gt;算术运算符遵 循通常的代数优先级，先乘除，后加减。&lt;/p&gt;
&lt;h3 id=&#34;342-除法分支&#34;&gt;3.4.2 除法分支&lt;/h3&gt;
&lt;p&gt;除法运算符（/）的行为取决于操作数的类型。如果两个操作数都 是整数，则C++将执行整数除法。这意味着结果的小数部分将被丢弃， 使得最后的结果是一个整数。&lt;strong&gt;如果其中有一个（或两个）操作数是浮点 值，则小数部分将保留，结果为浮点数&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719230953958.png&#34; alt=&#34;image-20210719230953958&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;浮点常量在默认情况下为 double类型。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;343-求模运算符&#34;&gt;3.4.3 求模运算符&lt;/h3&gt;
&lt;p&gt;求模运算符返回整数除法的余数。它与整数除 法相结合，尤其适用于解决要求将一个量分成不同的整数单元的问题。&lt;/p&gt;
&lt;h3 id=&#34;344-类型转换&#34;&gt;3.4.4 类型转换&lt;/h3&gt;
&lt;p&gt;由于有11种整型和3种浮点类型，因此计算机需 要处理大量不同的情况，C++自动执行很多类型转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进 行转换；&lt;/li&gt;
&lt;li&gt;表达式中包含不同的类型时，C++将对值进行转换；&lt;/li&gt;
&lt;li&gt;将参数传递给函数时，C++将对值进行转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++允许将一种类型的值赋给另一种类型的变量。这样做时，值将 被转换为接收变量的类型。例如，假设so_long的类型为long，thirty的类 型为short。&lt;/p&gt;
&lt;p&gt;将一个值赋给值取值范围更大的类型通常不会导致什么问题。如，将short值赋给long变量并不会改变这个值，只是占用的字节更多而 已。然而，将一个很大的long值（如2111222333）赋给float变量将降低 精度。因为float只有6位有效数字，因此这个值将被四舍五入为 2.11122E9。因此，有些转换是安全的，有些则会带来麻烦。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719232005071.png&#34; alt=&#34;image-20210719232005071&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如下的报错是一个可能:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719232233106.png&#34; alt=&#34;image-20210719232233106&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;将0赋给bool变量时，将被转换为false；而非零值将被转换为true。&lt;/p&gt;
&lt;p&gt;当同一个表达式中包含两种不同的算术类型时，将出现什么情况 呢？在这种情况下，C++将执行两种自动转换：首先，一些类型在出现 时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时 将被转换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在计算表达式时，C++将bool、char、unsigned char、signed char和short值转换为int。具体地说，true被转换为1，false 被转换为0。这些转换被称为整型提升（integral promotion）。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719232513015.png&#34; alt=&#34;image-20210719232513015&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;int 是一种最自然的类型，运算速度也最快，要主用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同样，wchar_t被提升成为下列类型中第一个宽度足够存储wchar_t 取值范围的类型：int、unsigned int、long或unsigned long。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将不同类型进行算术运算时，也会进行一些转换，例如将int和float 相加时。&lt;strong&gt;当运算涉及两种类型时，较小的类型将被转换为较大的类型。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719232833549.png&#34; alt=&#34;image-20210719232833549&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;传递参数时的类型转换通常由C++函数原型控制。&lt;/li&gt;
&lt;li&gt;C++还允许通过强制类型转换机制显式地进行类型转换。强制类型转换 的格式有两种。如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719233243273.png&#34; alt=&#34;image-20210719233243273&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719233319788.png&#34; alt=&#34;image-20210719233319788&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;新格式的想法 是，要让强制类型转换就像是函数调用。这样对内置类型的强制类型转换就像是为用户定义的类设计的类型转换。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更安全的转换方式是使用 &lt;code&gt;static_cast&amp;lt;typeName&amp;gt; (value)&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;Stroustrup认为，C语言式的强制类型转换由于有过多的可能性而极 其危险，这将在第15章更深入地讨论。运算符 &lt;code&gt;static_cast&amp;lt;&amp;gt;&lt;/code&gt; 比传统强制 类型转换更严格。&lt;/p&gt;
&lt;h3 id=&#34;345-c11中的auto声明&#34;&gt;3.4.5 C++11中的auto声明&lt;/h3&gt;
&lt;p&gt;在初始化声明中，如果 使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成 与初始值相同。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719234008239.png&#34; alt=&#34;image-20210719234008239&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210719234059088.png&#34; alt=&#34;image-20210719234059088&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;35-总结&#34;&gt;3.5 总结&lt;/h2&gt;
&lt;p&gt;C++的基本类型分为两组：一组由存储为整数的值组成，另一组由存储为浮点格式的值组成。整型之间通过存储值时使用的内存量及有无符号来区分。整型从最小到最大依次是：bool、char、signed char、 unsigned char、short、unsigned short、int、unsigned int、long、unsigned long以及C++11新增的long long和unsigned long long。还有一种wchar_t 类型，它在这个序列中的位置取决于实现。C++11新增了类型char16_t 和char32_t，它们的宽度足以分别存储16和32位的字符编码。C++确保了char足够大，能够存储系统基本字符集中的任何成员，而wchar_t则可以存储系统扩展字符集中的任意成员，short至少为16位，而int至少与short一样长，long至少为32位，且至少和int一样长。确切的长度取决于 实现。&lt;/p&gt;
&lt;p&gt;浮点类型可以表示小数值以及比整型能够表示的值大得多的值。3种浮点类型分别是float、double和long double。C++确保float不比double 长，而double不比long double长。通常，float使用32位内存，double使用 64位，long double使用80到128位。&lt;/p&gt;
&lt;p&gt;对变量赋值、在运算中使用不同类型、使用强制类型转换时，C++将把值从一种类型转换为另一种类型。&lt;/p&gt;
&lt;h1 id=&#34;第四章-复合类型&#34;&gt;第四章 复合类型&lt;/h1&gt;
&lt;p&gt;本章很重要（特别是指针部分），需要掌握的内容为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建和使用数组；&lt;/li&gt;
&lt;li&gt;创建和使用C-风格字符串；&lt;/li&gt;
&lt;li&gt;创建和使用 string 类字符串；&lt;/li&gt;
&lt;li&gt;使用方法 getline() 和 get() 读取字符串；&lt;/li&gt;
&lt;li&gt;混合输入字符串和数字；&lt;/li&gt;
&lt;li&gt;创建和使用结构体；&lt;/li&gt;
&lt;li&gt;创建和使用共用体；&lt;/li&gt;
&lt;li&gt;创建和使用枚举类型；&lt;/li&gt;
&lt;li&gt;创建和使用指针；&lt;/li&gt;
&lt;li&gt;使用 new 和 delete 管理动态内存；&lt;/li&gt;
&lt;li&gt;创建动态数组；&lt;/li&gt;
&lt;li&gt;创建动态结构；&lt;/li&gt;
&lt;li&gt;自动存储、静态存储和动态存储；&lt;/li&gt;
&lt;li&gt;vector 和 array 类简介。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;41-数组&#34;&gt;4.1 数组&lt;/h2&gt;
&lt;p&gt;数组（array) 是一种数据格式，能够存储多个&lt;strong&gt;同类型&lt;/strong&gt;的值。每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;即一个数组所在的内存区域是连续的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要创建数组，可使用声明语句。数组声明应指出以下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储在每个元素中的值的类型；&lt;/li&gt;
&lt;li&gt;数组名；&lt;/li&gt;
&lt;li&gt;数组中的元素数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在C++中，通过在简单变量后面添加中括号（其中包含 元素数目）来完成数组声明。而数组中的每一个元素都看作是一个简单变量。声明数组的通用格式为 :&lt;/p&gt;
&lt;p&gt;&lt;code&gt;typeName arrayName[arraySize]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;表达式arraySize指定元素数目，它必须是整型常数（如10）或const 值，也可以是常量表达式（如8 * sizeof（int）），即其中所有的值在编 译时都是已知的。具体说，arraySize不能是变量，变量的值是在程序 运行时设置的。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;int months[12];   // 声明一个包含 12 个整数的数组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C++ 通过使用下标来访问数组中的每一个元素，C++ 数据从0开始编号，数组总长度-1 是最后一个元素，如上：months[0] 为第一个元素，months[11] 是最后一个元素。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210721153711828.png&#34; alt=&#34;image-20210721153711828&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;411&#34;&gt;4.1.1&lt;/h3&gt;
&lt;p&gt;C++可以在声明语句中初始化数组，只需提供一个用逗号分隔的值列表（初始化列表），并将它们用花 括号括起即可。如 ：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;int yamcosts[3] = {20, 30, 5};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果没有初始化数组的值，则其元素值将是不确定的，这意味着元素的值为以前驻留在该内 存单元中的值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将sizeof运算符用于数组名，得到的将是整个数组 中的字节数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;412-数组的初始化规则&#34;&gt;4.1.2 数组的初始化规则&lt;/h3&gt;
&lt;p&gt;只有在定义数组时才能使用初始化，此后就不能使用了，&lt;strong&gt;也不能将一个数组赋给另一个数组&lt;/strong&gt;：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210721154858602.png&#34; alt=&#34;image-20210721154858602&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;这个方式和 Python 完全不同，原因可能是 Python 以引用为基础赋值，C++此处则是值赋值，只能一个一个来（声明时除外）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但此后，仍然可以通过下标分别给数组中的元素赋值。注意，&lt;strong&gt;这里是赋值不再是初始化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;初始化数组时，提供的值可以少于数组的元素数目，编译器将把其他元素设置为 0。因此，将数组中所有的元素都初始化为0非常简单—只要显式地将第 一个元素初始化为0，然后编译器会自动将其他元素都初始化为0。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;还有一种方法，如果初始化数组时方括号内（[ ]）为空，C++编译器将计算元素个 数。但这是很糟糕的做法，不提倡，不举例。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;413-c11数组初始化方法&#34;&gt;4.1.3 C++11数组初始化方法&lt;/h3&gt;
&lt;p&gt;数组以前就可使用列表初始化， 但C++11中的列表初始化新增了一些功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，初始化数组时，可省略等号（=）；&lt;/li&gt;
&lt;li&gt;其次，可不在大括号内包含任何东西，这将把所有元素都设置为零；&lt;/li&gt;
&lt;li&gt;第三，列表初始化禁止缩窄转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210721160721085.png&#34; alt=&#34;image-20210721160721085&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在上述代码中，第一条语句不能通过编译，因为将浮点数转换为整 型是缩窄操作，即使浮点数的小数点后面为零。第二条语句也不能通过 编译，因为1122011超出了char变量的取值范围（这里假设char变量的长 度为8位）。第三条语句可通过编译，因为虽然112是一个int值，但它在 char变量的取值范围内。&lt;/p&gt;
&lt;h2 id=&#34;42-字符串&#34;&gt;4.2 字符串&lt;/h2&gt;
&lt;p&gt;字符串是存储在内存的一片连续字节中的一系列字符，这里的&lt;strong&gt;连续&lt;/strong&gt;是重点。&lt;br&gt;
存储在连续字节中的一系列字符意味着可以将字符串存储在char数 组中，其中每个字符都位于自己的数组元素中。字符串提供了一种存储 文本信息的便捷方式。本章介绍两种处理字符串的方法：（1）C-风格字符串；（2）基于 string 类的方法。&lt;/p&gt;
&lt;p&gt;C-风格字符串具有 一种特殊的性质：以空字符（null character）结尾，空字符被写作 \0， 其ASCII码为0，用来标记字符串的结尾。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210721161457763.png&#34; alt=&#34;image-20210721161457763&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这两个数组都是char数组，但只有第二个数组是字符串，空字符对 C-风格字符串而言至关重要。C++有很多处理字符串的函数，其 中包括cout使用的那些函数。它们都逐个地处理字符串中的字符，直到 到达空字符为止。如果使用cout显示上面的cat这样的字符串，则将显示 前7个字符，发现空字符后停止。使用cout显示上面的dog数 组（它不是字符串），cout将打印出数组中的8个字母，并接着将内存 中随后的各个字节解释为要打印的字符，直到遇到空字符为止（因此不加空字符是C-风格字符串中极其危险的行为）。&lt;/p&gt;
&lt;p&gt;有一种更好的、 将字符数组初始化为字符串的方法—只需使用一个用引号括起的字符串 即可，这种字符串被称为字符串常量（string constant）或字符串字面值 （string literal），如下所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210721162122919.png&#34; alt=&#34;image-20210721162122919&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;用引号括起来的字符串&lt;strong&gt;隐式&lt;/strong&gt;地包括结尾的空字符，因此不用显式地包括它。&lt;/p&gt;
&lt;p&gt;最需要注意的是，&lt;strong&gt;使用C-风格字符串，在确定存储字符串所需的最短数组时，别忘了+1，要将结尾的空字符计算在内&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210721162704816.png&#34; alt=&#34;image-20210721162704816&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210721162840015.png&#34; alt=&#34;image-20210721162840015&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;这里的赋值改为：&lt;code&gt;char shirt_size[2] = &amp;quot;S&amp;quot;;&lt;/code&gt;  才是正确的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;421-拼接字符串常量&#34;&gt;4.2.1 拼接字符串常量&lt;/h3&gt;
&lt;p&gt;事实上，任何两个由空 白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。 因此，下面所有的输出语句都是等效的：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210721163221414.png&#34; alt=&#34;image-20210721163221414&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注意，拼接时不会在被连接的字符串之间添加空格，第二个字符串 的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑\0）后 面。第一个字符串中的\0字符将被第二个字符串的第一个字符取代。&lt;/p&gt;
&lt;h3 id=&#34;422-在数组中使用字符串&#34;&gt;4.2.2 在数组中使用字符串&lt;/h3&gt;
&lt;p&gt;从程序清单4.2中可以学到什么呢？&lt;br&gt;
首先，sizeof运算符指出整个数组的长度：15字节，但 strlen( )函数返回的是存储在数组中的字符串的长度，而不是数组本身的长度。&lt;br&gt;
另外，strlen( ) 只计算可见的字符，而不把空字符计算在内。因此，对于Basicman，返回的值为8，而不是 9。如果cosmic是字符串，则要存储该字符串，数组的长度不能短于strlen（cosmic）+1。&lt;br&gt;
由于name1和name2是数组，所以可以用索引来访问数组中各个字符。例如，该程序使用 name1[0]找到数组的第一个字符。另外，该程序将name2[3]设置为空字符。这使得字符串在第 3个字符后即结束，虽然数组中还有其他的字符（参见图4.3）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210721164300455.png&#34; alt=&#34;image-20210721164300455&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;程序清单 4.2 使用 cin 暗含两个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遇到空格结束；&lt;/li&gt;
&lt;li&gt;输入字符串长于目标数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;423-字符串输入&#34;&gt;4.2.3 字符串输入&lt;/h3&gt;
&lt;p&gt;cin是如何确定已完成字符串输入呢？由于不能通过键盘输入空字 符，因此cin需要用别的方法来确定字符串的结尾位置。cin使用空白 （空格、制表符和换行符）来确定字符串的结束位置，这意味着cin在 获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串 放到数组中，并自动在结尾添加空字符。&lt;/p&gt;
&lt;p&gt;这个例子的实际结果是，cin把Alistair作为第一个字符串，并将它 放到name数组中。这把Dreeb留在输入队列中。当cin在输入队列中搜索 用户喜欢的甜点时，它发现了Dreeb，因此cin读取Dreeb，并将它放到 dessert数组中。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210721171126781.png&#34; alt=&#34;image-20210721171126781&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;另一个问题是，输入字符串可能比目标数组长（运行中没有揭示出 来）。像这个例子一样使用cin，确实不能防止将包含30个字符的字符 串放到20个字符的数组中的情况发生。&lt;/p&gt;
&lt;p&gt;文章将这个问题的系统处理留到第 17 章，但下文也能解决。&lt;/p&gt;
&lt;h3 id=&#34;424-每次读取一行字符串输入&#34;&gt;4.2.4 每次读取一行字符串输入&lt;/h3&gt;
&lt;p&gt;每次读取一个单词通常不是最好的选择。具体地说，需要采用面向行而不是面向单词的方法。istream中的类（如 cin）提供了一些面向行的类成员函数：&lt;code&gt;getline()&lt;/code&gt; 和 &lt;code&gt;get()&lt;/code&gt;。这两个函数都读取一 行输入，直到到达换行符（回车符）。区别是，&lt;code&gt;getline()&lt;/code&gt; 将读入并丢弃换行符，而 &lt;code&gt;get()&lt;/code&gt; 则将换行符保留在输入队列中。&lt;strong&gt;注意是还保留在输入流里，没有被读走！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1．面向行的输入：getline( )&lt;/p&gt;
&lt;p&gt;getline( )函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。通过 &lt;code&gt;cin.getline()&lt;/code&gt; 调用。该函数有两个参数，第一个参数是存储输入行的数组名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符或者碰到换行符为止，并自动在结尾处添加空字符。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;cin.getline(array_name, 20);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例子程序清单 4.4:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722004651618.png&#34; alt=&#34;image-20210722004651618&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722004809212.png&#34; alt=&#34;image-20210722004809212&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;2．面向行的输入：get( )&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iostream&lt;/code&gt; 中的 &lt;code&gt;get()&lt;/code&gt; 虽然和 &lt;code&gt;getline()&lt;/code&gt; 类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但 get 将换行符保留在输入队列中，假设我们连续两次 调用 &lt;code&gt;get( )&lt;/code&gt; 那么要注意了。&lt;/p&gt;
&lt;p&gt;第一次调用后，换行符将被留在输入队列中，因此第二次调用时看到的第一个字符便是换行符，此时 &lt;code&gt;get()&lt;/code&gt; 以为已经到达行尾了，而没有发现任何可读取的内容。&lt;strong&gt;如果不借助于帮助，&lt;code&gt;get()&lt;/code&gt; 将不能跨过该换行符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这时要用 &lt;code&gt;get()&lt;/code&gt; 的另一种变体——不带任何参数，可读取下一个字符（即使是换行符），因此可以用它来处理换行符，为读取下一行输入做好准备。例子：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722005755295.png&#34; alt=&#34;image-20210722005755295&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;由于 &lt;code&gt;cin.get(name, ArSize)&lt;/code&gt; 返回的还是 cin 对象，因此还可以合并起来调用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;cin.get(name, ArSize).get();  // 这样也能同时将末尾的换行符读走
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但风险就是，&lt;strong&gt;假如 ArSize 小于一行的字符数，那么调用 &lt;code&gt;get()&lt;/code&gt; 后就会发生字符丢失&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getline()&lt;/code&gt; 成员函数也同样可以合并调用连续读取字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;cin.getline(name1, ArSize).getline(name2, ArSize);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这语句将把输入中 连续的两行分别读入到数组name1和name2 中，其效果与两次调用 &lt;code&gt;cin.getline()&lt;/code&gt; 相同。&lt;/p&gt;
&lt;p&gt;为什么要使用 &lt;code&gt;get()&lt;/code&gt;，而不是 &lt;code&gt;getline()&lt;/code&gt; 呢？&lt;br&gt;
首先，老式实现没有 &lt;code&gt;getline()&lt;/code&gt;。其次，&lt;code&gt;get()&lt;/code&gt; 使输入更仔细。例如，假设用&lt;code&gt;get( )&lt;/code&gt; 将一行读入数组中。&lt;strong&gt;如何知道停止读取的原因是由于已经读取了整行，而不是由于数组已填满呢？&lt;/strong&gt; （getline，判断不了）， 查看下一个输入字符，如果是换行符，说明已读取了整行；否则，说明该行中还有其他输入。&lt;/p&gt;
&lt;p&gt;总之， &lt;code&gt;getline()&lt;/code&gt; 使用起来简单一些，但 &lt;code&gt;get( )&lt;/code&gt; 使得检查错误更简单些。&lt;/p&gt;
&lt;p&gt;3．空行和其他问题&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;getline()&lt;/code&gt; 或 &lt;code&gt;get()&lt;/code&gt; 读取空行时，将发生什么情况？最初的做法是， 下一条输入语句将在前一条 &lt;code&gt;getline()&lt;/code&gt; 或 &lt;code&gt;get()&lt;/code&gt; 结束读取的位置开始读取； 但当前的做法是，当 &lt;code&gt;get()&lt;/code&gt;（不是getline）读取空行后将设置失效位 （failbit）。这意味着接下来的输入将被阻断，要用 &lt;code&gt;cin.clear()&lt;/code&gt; 的命令来恢复输入。&lt;/p&gt;
&lt;p&gt;另一个潜在的问题是，输入字符串可能比分配的空间长。如果输入行包含的字符数比指定的多，则 &lt;code&gt;getline()&lt;/code&gt; 和 &lt;code&gt;get()&lt;/code&gt; 将把余下的字符留在输入队列中，&lt;code&gt;getline()&lt;/code&gt; 还会设置失效位，并关闭后面的输入。&lt;/p&gt;
&lt;h3 id=&#34;425-混合输入字符串和数字&#34;&gt;4.2.5 混合输入字符串和数字&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722012337405.png&#34; alt=&#34;image-20210722012337405&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;清单程序4.6 的一个问题是：&lt;br&gt;
当cin读取年份，将回 车键生成的换行符留在了输入队列中。后面的cin.getline( )看到换行符 后，将认为是一个空行，并将一个空字符串赋给address数组。解决之道 是，在读取地址之前先读取并丢弃换行符。这可以通过几种方法来完 成，其中包括使用没有参数的get( )和使用接受一个char参数的get( )。&lt;/p&gt;
&lt;p&gt;也可以利用表达式cin&amp;gt;&amp;gt;year返回cin对象，将调用拼接起来：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;(cin &amp;gt;&amp;gt; year).get();  // or (cin &amp;gt;&amp;gt; year).get(ch);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;43-string-类简介&#34;&gt;4.3 string 类简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt; 类包含于头文件 &lt;code&gt;string&lt;/code&gt; 并位于名称空间 &lt;code&gt;std&lt;/code&gt; 中，使用起来比字符数组简单，它提供了将字符串作为一种数据类型的表示方法，符合 C++ 的风格。&lt;br&gt;
string 类定义隐藏了字符串的数组性质，让我们能够像处理普通变量那样处理字符串。&lt;/p&gt;
&lt;p&gt;在很多方面，使用 string 对象的方式和使用字符数组相同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以使用 C-风格字符串来初始化 string 对象；&lt;/li&gt;
&lt;li&gt;可以使用 cin 来将键盘输入存储到 string 对象中；&lt;/li&gt;
&lt;li&gt;可以使用 cout 来显示 string 对象；&lt;/li&gt;
&lt;li&gt;可以使用数组表示法来访问存储在 string 对象中的字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;string 对象和字符数组的主要区别是，可以将 string 对象声明为简单变量，而不是数组。&lt;/p&gt;
&lt;p&gt;类设计让程序能够自动处理string的大小。例如，str1的声明创建一 个长度为0的 string 对象，但程序将输入读取到str1中时，将自动调整 str1 的长度。&lt;/p&gt;
&lt;p&gt;这使得与使用数组相比，使用string对象更方便，也更安全。从理论上说，可以将char 数组视为一组用于存储一个字符串的 char 存储单元，而 string 类变量是一个表示字符串的实体。&lt;/p&gt;
&lt;h3 id=&#34;431-c11字符串初始化&#34;&gt;4.3.1 C++11字符串初始化&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722141823630.png&#34; alt=&#34;image-20210722141823630&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;432-string-赋值-拼接和附加&#34;&gt;4.3.2 string 赋值、拼接和附加&lt;/h3&gt;
&lt;p&gt;string 可以如简单变量那般操作。比如，虽然不能将一个数组赋给另一个数组，但却可以将一个 string 对象赋给另一个 string 对象。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722142110617.png&#34; alt=&#34;image-20210722142110617&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以使用运算符 + 将两个string 对象合并起来，还可以使用运算符 += 将字符串附加到string对象的末尾。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;string str1 = &amp;quot;aa&amp;quot;;
string str2 = &amp;quot;bb&amp;quot;;
string str3;

str3 = str1 + str2;  // 正确
str3 += str1;        // 正确
str3 += &amp;quot; cc&amp;quot;;       // 一样正确
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;433-string类的其他操作&#34;&gt;4.3.3 string类的其他操作&lt;/h3&gt;
&lt;p&gt;处理string对象的语法通常比使用C字符串函数简单，尤其是执行较为复杂的操作时。例如，对于下述操作：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;str3 = str1 + str2;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用C-风格字符串时，需要使用的函数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;strcpy(charr3, charr1);
strcat(charr3, charr2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;strcpy()&lt;/code&gt; 和  &lt;code&gt;strcat()&lt;/code&gt; 函数包含在头文件 cstring 中。函数 &lt;code&gt;strcpy()&lt;/code&gt; 将字符串复制到字符数组中，使用函数 &lt;code&gt;strcat()&lt;/code&gt; 将字符串附加到字符数组末尾。&lt;br&gt;
另外，使用字符数组时，&lt;strong&gt;总是存在目标数组过小，无法存储指定信息的危险&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722143658095.png&#34; alt=&#34;image-20210722143658095&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;函数strcat( )试图将全部12个字符复制到数组site中，这将覆盖相邻的内存。这可能导致程序终止，或者程序继续运行，但数据被损坏。&lt;strong&gt;string类具有自动调整大小的功能，从而能够避免这种问题发生&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;434-string类io&#34;&gt;4.3.4 string类I/O&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722144341278.png&#34; alt=&#34;image-20210722144341278&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在用户输入之前，该程序指出数组charr中的字符串长度为27，这比 该数组的长度要大。这里要两点需要说明。首先，为初始化的数组的内 容是未定义的；其次，函数strlen( )从数组的第一个元素开始计算字节 数，直到遇到空字符。在这个例子中，在数组末尾的几个字节后才遇到 空字符。对于未被初始化的数据，第一个空字符的出现位置是随机的， 因此您在运行该程序时，得到的数组长度很可能与此不同。&lt;/p&gt;
&lt;p&gt;用户输入之前，str中的字符串长度为0。这是因为未被初始化的string对象的长度被自动设置为0。 &lt;strong&gt;这是和字符串数组不同的地方&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;源代码中是将一行输入读取到string对象中的代码是：&lt;code&gt;getline(cin, str);&lt;/code&gt;。这个 &lt;code&gt;getline()&lt;/code&gt; 不是类方法，它将 cin 作为参数，指出去哪里查找输入，另外，也没有指出字符串长度 的参数，因为 &lt;code&gt;string&lt;/code&gt; 对象将根据字符串的长度自动调整自己的大小。&lt;/p&gt;
&lt;h3 id=&#34;435-其他形式的字符串字面值&#34;&gt;4.3.5 其他形式的字符串字面值&lt;/h3&gt;
&lt;p&gt;除char类型外，C++还有类型wchar_t；而C++11新 增了类型char16_t和char32_t。可创建这些类型的数组和这些类型的字符 串字面值。对于这些类型的字符串字面值，C++分别使用前缀L、u和U 表示，下面是一个如何使用这些前缀的例子：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722162656588.png&#34; alt=&#34;image-20210722162656588&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;C++11还支持Unicode字符编码方案UTF-8。&lt;br&gt;
C++11新增的另一种类型是原始（raw）字符串，并使用前缀 R 来标识，原始字符表示的就是自己，例如，序列 &lt;code&gt;\n&lt;/code&gt; 不表示换行符，而表示两个常 规字符—斜杠和n，因此在屏幕上显示时，将显示这两个字符。&lt;/p&gt;
&lt;h2 id=&#34;44-结构体简介&#34;&gt;4.4 结构体简介&lt;/h2&gt;
&lt;p&gt;**结构体（Struct）**是 一种比数组更灵活的数据格式，因为同一个结构体可以存储多种不同类型的数据，从而将数据的表示合并到一起。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文称 struct 为 “结构”，我认为这不符合一贯以来的称呼，因此在这个笔记中我一律改为通常在 &lt;code&gt;C/C++&lt;/code&gt; 中所称呼的 “结构体”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结构体是用户定义的类型，而结构体声明定义了这种类型的数据属性。结构体的定义需要用 关键字 &lt;strong&gt;struct&lt;/strong&gt; 做标识。 定义了类型后，便可以创建这种类型的变量。以下例子是一个结构体的定义，它使用了一个适合用于存储字符串的 char数组、一个float和一个double。列表中的每一项都被称为结构体成员，因此 infatable 结构体有3个成员（参见图4.6）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722163912443.png&#34; alt=&#34;image-20210722163912443&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;定义之后就可以将这个结构体当做常规的 C++ 数据类型（如同 int、double、string等）来使用。&lt;/p&gt;
&lt;p&gt;在结构体类型中，可以通过使用成员运算符 &lt;code&gt;.&lt;/code&gt; 来访问各个成员。&lt;/p&gt;
&lt;h3 id=&#34;441-在程序中使用结构体&#34;&gt;4.4.1 在程序中使用结构体&lt;/h3&gt;
&lt;p&gt;结构声明的位置很重要。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722165020076.png&#34; alt=&#34;image-20210722165020076&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;结构体的初始化方式和数组一样，使用逗号分隔值列表，并将这些值用花括号括起。如:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722165157045.png&#34; alt=&#34;image-20210722165157045&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;花括号中每个值可以独占一行，也可以将他们都放在同一行中，注意变量之间有逗号隔开就行，其他的随意。&lt;/p&gt;
&lt;h3 id=&#34;442-c11-结构体初始化&#34;&gt;4.4.2 C++11 结构体初始化&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722165537179.png&#34; alt=&#34;image-20210722165537179&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;443-结构体可以将string类作为成员吗&#34;&gt;4.4.3 结构体可以将string类作为成员吗?&lt;/h3&gt;
&lt;p&gt;可以，只要编译器支持 string 类型就没问题，唯一要注意的问题注意添加名字空间 std 。 如:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722165802188.png&#34; alt=&#34;image-20210722165802188&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;444-其他结构属性&#34;&gt;4.4.4 其他结构属性&lt;/h3&gt;
&lt;p&gt;结构体和 C++ 内置类型的用法类似，它可以作为参数传递给函数，也可以让函数返回一个结构体。另外，&lt;strong&gt;还可以使用赋值运算符（=）将结构体赋给另一个同类型的结构体&lt;/strong&gt;，这样结构体中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为成员赋值（memberwise assignment）。&lt;/p&gt;
&lt;p&gt;结构体类型还可以同时完成定义结构体和创建结构体变量的工作，只需将变量名放在结束括号的后面即可：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722170446818.png&#34; alt=&#34;image-20210722170446818&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;但不推荐这样做，将结构体定义和变量声明分开，可以使程序更易于阅读和理解。&lt;/p&gt;
&lt;h3 id=&#34;445-结构体数组&#34;&gt;4.4.5 结构体数组&lt;/h3&gt;
&lt;p&gt;创建结构体数组的方法和创建 C++ 基本类型的数组完全相同。&lt;/p&gt;
&lt;p&gt;要初始化结构体数组，可以使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）和初始化结构体的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。由于数组中的每个 元素都是结构，因此可以使用结构初始化的方式来提供它的值。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722170912740.png&#34; alt=&#34;image-20210722170912740&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;45-共用体&#34;&gt;4.5 共用体&lt;/h2&gt;
&lt;p&gt;共用体（union），也叫联合体是一种数据格式，它能够存储不同的数据类型， 但只能同时存储其中的一种类型。也就是说，结构体可以同时存储 int、 long和double，共用体只能存储int、long或double。共用体的句法与结构相似，但含义不同。如：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722171406230.png&#34; alt=&#34;image-20210722171406230&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;共用体每次只能存储一个值&lt;/strong&gt;，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的。&lt;/p&gt;
&lt;p&gt;共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省内存空间，其实对当前内存充裕的计算机来说，并非很有必要使用共用体。&lt;/p&gt;
&lt;h2 id=&#34;46-枚举&#34;&gt;4.6 枚举&lt;/h2&gt;
&lt;p&gt;这也是一个很少用的类型，略。&lt;br&gt;
&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722171825483.png&#34; alt=&#34;image-20210722171825483&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;47-指针和自由存储空间&#34;&gt;4.7 指针和自由存储空间&lt;/h2&gt;
&lt;p&gt;计算机在存储数据时必须跟踪的3种基本属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信息存储在何处；&lt;/li&gt;
&lt;li&gt;存储的值为多少；&lt;/li&gt;
&lt;li&gt;存储的信息是什么类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ 提供了一种策略，可以在程序内部跟踪内存单元，这个策略以指针为基础。C++ 中 &lt;strong&gt;指针是一个变量，其存储的是值的地址，而不是值本身&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先，我们如何找到常规变量的地址？在C/C++中只需对变量应用地址运算符 &lt;code&gt;&amp;amp;&lt;/code&gt;，就可以获得它的位置；例如，如果 &lt;code&gt;home&lt;/code&gt; 是一个变量，则 &lt;code&gt;&amp;amp;home&lt;/code&gt; 是它在内存中的地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用常规变量时，值是指定的量，而地址为派生量&lt;/strong&gt;。接下来看看指针策略，它是C++内存管理编程理念的核心。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722232030057.png&#34; alt=&#34;image-20210722232030057&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;指针处理存储数据的新策略刚好相反，&lt;strong&gt;指针将地址视为指定的量，而将值视为派生量&lt;/strong&gt;，因此，指针名表示的是地址。&lt;code&gt;*&lt;/code&gt; 运算符被称为&lt;strong&gt;间接值（indirect velue）或解除引用 （dereferencing）运算符&lt;/strong&gt;，应用于指针得到该地址处所存储的值。例如，假设 &lt;code&gt;manly&lt;/code&gt; 是一个指针，则 &lt;code&gt;manly&lt;/code&gt; 表示的是一个地址，&lt;code&gt;*manly&lt;/code&gt; 表示存储在该地址处的值，即 &lt;code&gt;*manly&lt;/code&gt; 和常规变量等效。&lt;strong&gt;变量的指针和变量的值本身本质只不过是一个硬币的两个面&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;变量是编译时分配出来的一个有名称的内存，这是变量的实质。而指针是一个可以通过名称直接访问内存的别名，内存里存储的东西就是变量的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;45&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722233255845.png&#34; alt=&#34;image-20210722233255845&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;471-声明和初始化指针&#34;&gt;4.7.1 声明和初始化指针&lt;/h3&gt;
&lt;p&gt;不同数据类型存储值时的内存格式不同，所以指针声明时必须 &lt;strong&gt;指定指针指向的数据类型&lt;/strong&gt;，声明一个指针的通用方式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typeName *p_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 符用于指明该变量是指针，每个指针变量声明时都需要带 &lt;code&gt;*&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;46&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210722233705755.png&#34; alt=&#34;image-20210722233705755&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用指针的时候要注意区分地址是地址，值是值。指针本身也是一种数据类型，它的值是地址，这个地址也有它自己的字节长度（由计算机系统内定），它的长度和它这个地址里存储的数值没有任何关系。指向 int 类型和指向 double 类型或者 string 类型的指针类型的字节长度都是一样的，它们都是地址。&lt;/p&gt;
&lt;h3 id=&#34;472-指针的危险&#34;&gt;4.7.2 指针的危险&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;创建指针时，计算机将分配用来存储指针这个变量本身的内存，但不会分配指针所指向的数据所需的内存&lt;/strong&gt;。为数据提供空间是一个独立的步骤，如果忽略这一步麻烦就大了。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;long *fellow;       // 创建一个指向 long 类型的指针
*fellow = 223323;   // 指针还不知道指向哪个地址，就强制赋值，大错特错
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;声明时，只是告诉程序 &lt;code&gt;fellow&lt;/code&gt; 是一个 &lt;code&gt;long&lt;/code&gt; 指针，程序只给 &lt;code&gt;fellow&lt;/code&gt; 这个指针变量分配了一个属于 &lt;code&gt;fellow&lt;/code&gt; 自己的存储空间，至于它里面要存什么地址值还完全不知道。必须先申请一个存 &lt;code&gt;long&lt;/code&gt; 类型的地址空间，然后赋值给 &lt;code&gt;fellow&lt;/code&gt;，最后才可以将 223323 赋值过去。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一定要在对指针应用解除引用运算符 &lt;code&gt;*&lt;/code&gt; 之前，将指针初始化为一个确定的、适当的地址，这是关于使用指针的铁律。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;473-指针和数字&#34;&gt;4.7.3 指针和数字&lt;/h3&gt;
&lt;p&gt;指针不是整型，虽然计算机通常把地址当作整数来处理。在有些平台 中，int 类型是个2字节值，而地址是个4字节值。&lt;/p&gt;
&lt;h3 id=&#34;474-使用new来分配内存&#34;&gt;4.7.4 使用new来分配内存&lt;/h3&gt;
&lt;p&gt;指针真正的用武之地在于，运行阶段分配未命名的内存用于存储值。C++ 通过 new 运算符为变量分配内存。&lt;/p&gt;
&lt;p&gt;程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长 度正确的内存块，并返回该内存块的地址。程序员的责任是将该地址赋 给一个指针。下面是一个这样的示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;int *pn = new int;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;new int&lt;/code&gt; 告诉程序，需要适合存储 &lt;code&gt;int&lt;/code&gt; 的内存。&lt;code&gt;new&lt;/code&gt; 运算符根据类型来确定需要多少字节的内存。然后，它找到这样的内存，并返回其地址。 接下来，将地址赋给 &lt;code&gt;pn&lt;/code&gt;，&lt;code&gt;pn&lt;/code&gt; 是被声明为指向 &lt;code&gt;int&lt;/code&gt; 的指针。现在，&lt;code&gt;pn&lt;/code&gt; 是地址，而 &lt;code&gt;*pn&lt;/code&gt; 是存储在那里的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;code&gt;pn&lt;/code&gt; 指向的内存不是变量（那是一个地址，是不变的），内存里存储的东西才是可变的。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这引出了一个问题：pn指向的内存没 有名称，如何称呼它呢？我们说pn指向一个数据对象，这里的“对象”不 是“面向对象编程”中的对象，而是一样“东西”。术语“数据对象”比“变 量”更通用，它指的是为数据项分配的内存块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为一个数据对象（可以是结构，也可以是基本类型）获得并指定分 配内存的通用格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;typeName *pointer_name = new typeName;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要指出的另一点是，&lt;code&gt;new&lt;/code&gt; 分配的内存块通常与常规变量声明分配的内存块不同。常规变量存储在被称为栈 （stack）的内存区域中，而 &lt;code&gt;new&lt;/code&gt; 从被称为堆（heap）或自由存储区（free store）的内存区域分配内存。&lt;/p&gt;
&lt;p&gt;如果内存分配失败，&lt;code&gt;new&lt;/code&gt; 运算符将返回空指针（null pointer），其值为 0。&lt;/p&gt;
&lt;h3 id=&#34;475-使用-delete-释放内存&#34;&gt;4.7.5 使用 delete 释放内存&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;delete&lt;/code&gt; 运算符，用于将不再使用的内存归还给内存池&lt;/strong&gt;，归还或释放（free）的内存可供程序的其他部分使用。使用 &lt;code&gt;delete&lt;/code&gt; 时，后面要加上指向内存块的指针（这些内存块最初是用new分配的）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;int *ps = new int;   // 声明指针并分配一个可以存 int 类型的内存给指针
...
delete ps;  // 归还内存
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;归还 ps 指向的内存，并不会删除指针 ps 本身，它可以继续用来指向新分配的内存。&lt;br&gt;
&lt;strong&gt;&lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 一定要配对使用，否则会导致程序发生内存泄露（memory leak）&lt;/strong&gt;，即分配出去的内存拿不回来，无法再使用。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;47&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210723144325225.png&#34; alt=&#34;image-20210723144325225&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;另外，不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般来说，不要创建两个指向同一个内存块的指针，因为这将增加 错误地删除同一个内存块两次的可能性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，不能使用 &lt;code&gt;delete&lt;/code&gt; 释放声明变量所获得的内存，&lt;strong&gt;只能用它释放 &lt;code&gt;new&lt;/code&gt; 分配的内存&lt;/strong&gt;，这是关键点。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;48&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210723105004298.png&#34; alt=&#34;image-20210723105004298&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;476-使用new来创建动态数组&#34;&gt;4.7.6 使用new来创建动态数组&lt;/h3&gt;
&lt;p&gt;对于大型数据（如数组、字符串和结 构），应使用new，这正是new的用武之地。&lt;/p&gt;
&lt;p&gt;在编译时给数组分配内存被称为静态联编（static binding），这就是为什么只能分配固定大小的数组。但使用 &lt;code&gt;new&lt;/code&gt; 时，在运行阶段需要数组，则创建它；如果不需 要，则不创建，还可以选择数组的长度，这被称为动态联 编（dynamic binding），意味着数组是在程序运行时创建的。&lt;/p&gt;
&lt;p&gt;1．使用 new 创建动态数组&lt;/p&gt;
&lt;p&gt;创建动态数组很容易；只要将数组的元素类型和元素数 目告诉new即可。必须在类型名后加上方括号，其中包含元素数目。为数组分配内存的通用格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typeName *pointer_name = new typeName [num_elements];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给个例子如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;int *psome = new int [10];  // 分配可以存储 10 个 int 的内存块
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt; 返回第一个元素的地址，并将该地址被赋给指针 &lt;code&gt;psome&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;释放这一块内存时要这样做：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;delete [] psome;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。 &lt;strong&gt;注意delete和指针之间有方括号&lt;/strong&gt;。对于 ANSI/ISO标准来说，&lt;code&gt;new&lt;/code&gt; 与 &lt;code&gt;delete&lt;/code&gt; 的格式要匹配，否则导致的后果是不确定。&lt;/p&gt;
&lt;p&gt;总之，使用new和delete时，应遵守以下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要使用 &lt;code&gt;delete&lt;/code&gt; 来释放不是 &lt;code&gt;new&lt;/code&gt; 分配的内存；&lt;/li&gt;
&lt;li&gt;不要使用 &lt;code&gt;delete&lt;/code&gt; 释放同一个内存块两次；&lt;/li&gt;
&lt;li&gt;如果使用 &lt;code&gt;new []&lt;/code&gt; 为数组分配内存，则应使用 &lt;code&gt;delete []&lt;/code&gt; 来释放；&lt;/li&gt;
&lt;li&gt;如果使用 &lt;code&gt;new []&lt;/code&gt; 为一个实体分配内存，则应使用 &lt;code&gt;delete&lt;/code&gt;（没有方括 号）来释放(这一点要找例子来理解)；&lt;/li&gt;
&lt;li&gt;对空指针应用 &lt;code&gt;delete&lt;/code&gt; 是安全的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2．使用动态数组&lt;/p&gt;
&lt;p&gt;创建动态数组后，如何使用它呢？&lt;strong&gt;只需要将指针名当做数组名，然后按照数组的访问方式即可&lt;/strong&gt;，C/C++ 中数组和指针是基本等价的（但也有实质区别，后续再说）。例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;int *psome = new int [10];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于第1个元素，可以使用 &lt;code&gt;psome[0]&lt;/code&gt;，而不是 &lt;code&gt;*psome&lt;/code&gt;；对于第2个元 素，可以使用 &lt;code&gt;psome[1]&lt;/code&gt;，依此类推。&lt;/p&gt;
&lt;p&gt;程序清单4.18演示了如何使用new来创建动 态数组以及使用数组表示法来访问元素；它还指出了指针和真正的数组名之间的根本差别（注意红框）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;49&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210723111823885.png&#34; alt=&#34;image-20210723111823885&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;将&lt;code&gt;p3&lt;/code&gt; 加1导致它指向第2个元素而不是第1个。将它减1后，指针将指向原来的值，这样程序便可以给 &lt;code&gt;delete[]&lt;/code&gt; 提供正确的地址。(这叫指针移动)&lt;/p&gt;
&lt;h2 id=&#34;48-指针-数组和指针算术&#34;&gt;4.8 指针、数组和指针算术&lt;/h2&gt;
&lt;p&gt;指针算术是有特殊之处的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指针和数组基本等价的原因在于指针算术（pointer arithmetic）和 C++ 内部处理数组的方式&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将整数变量加1 后，其值将增加1；但将指针变量加1后，增加的量等于它指向的类型的 字节数。将指向double的指针加1后，如果系统对double使用8个字节存 储，则数值将增加8；将指向short的指针加1后，如果系统对short使用2 个字节存储，则指针值将增加2。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;481-程序说明&#34;&gt;4.8.1 程序说明&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;50&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210723112411334.png&#34; alt=&#34;image-20210723112411334&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;将指针变量加1后，其增加的值等于指向的类型占用的字节数&lt;/strong&gt;。 也就是跳到下一个存储值的地址上。&lt;/p&gt;
&lt;p&gt;从该程序的输出可知，&lt;code&gt;*（stacks + 1）&lt;/code&gt;和 &lt;code&gt;stacks[1]&lt;/code&gt; 是等价的。同样， &lt;code&gt;*（stacks + 2）&lt;/code&gt;和 &lt;code&gt;stacks[2]&lt;/code&gt; 也是等价的。通常，使用数组表示法时，&lt;code&gt;C++&lt;/code&gt; 都执行下面的转换：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arrayname[i] becomes *(arrayname + i)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果使用的是指针，而不是数组名，则C++也将执行同样的转换：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pointername[i] becomes *(pointername + i)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，在很多情况下，可以相同的方式使用指针名和数组名。也就是说，使用 &lt;code&gt;new&lt;/code&gt; 来创建数组以及使用指针来访问不同的元素时，只要把指针当作数组名对待即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【注意】数组名被解释为其第一个元素的地址，而对数组名应用地址运算符 时，得到的是整个数组的地址，区别很大。&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;51&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210723113548998.png&#34; alt=&#34;image-20210723113548998&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;482-指针小结&#34;&gt;4.8.2 指针小结&lt;/h3&gt;
&lt;p&gt;1．声明指针&lt;br&gt;
要声明指向特定类型的指针，请使用下面的格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;typeName *pointer_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2．给指针赋值&lt;/p&gt;
&lt;p&gt;应将内存地址赋给指针。可以对变量名应用 &lt;code&gt;&amp;amp;&lt;/code&gt; 地址运算符，来获得被命名的内存的地址，或 &lt;code&gt;new&lt;/code&gt; 运算符返回未命名的内存的地址。&lt;/p&gt;
&lt;p&gt;3．对指针解引用&lt;/p&gt;
&lt;p&gt;对指针解引用意味着获得指针指向的值。&lt;code&gt;*&lt;/code&gt; 是指针应用解引用或间接值运算符。&lt;/p&gt;
&lt;p&gt;4．区分指针和指针所指向的值&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;pt&lt;/code&gt; 是指向int的指针，则 &lt;code&gt;*pt&lt;/code&gt; 不是指向 &lt;code&gt;int&lt;/code&gt; 的指针，而是完全等同于 一个 &lt;code&gt;int&lt;/code&gt; 类型的变量，&lt;code&gt;pt&lt;/code&gt; 才是指针。&lt;/p&gt;
&lt;p&gt;5．数组名&lt;/p&gt;
&lt;p&gt;大多数情况下，C++将数组名视为数组的第一个元素的地址。一种例外情况是，将sizeof运算符用于数组名用时，此时将返回整个数组的长度（单位为字节）。&lt;/p&gt;
&lt;p&gt;6．指针算术&lt;/p&gt;
&lt;p&gt;C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数，也就是移动到下一个存储值的地址。还可以将一个指针减去另一个指针，获得两个指针的差。后一种运算将得到一个整数，仅当两个指针指向同一个数 组（也可以指向超出结尾的一个位置）时，这种运算才有意义，这将得到两个元素的间隔。&lt;/p&gt;
&lt;p&gt;7．数组的动态联编和静态联编&lt;/p&gt;
&lt;p&gt;使用数组声明来创建数组时，将采用静态联编，即数组的长度在编 译时设置。&lt;br&gt;
使用 &lt;code&gt;new[]&lt;/code&gt; 运算符创建数组时，将采用动态联编（动态数组），即将在运行时为数组分配空间，其长度也将在运行时设置。使用完这种数组后，应使用 &lt;code&gt;delete []&lt;/code&gt; 释放其占用的内存。&lt;/p&gt;
&lt;p&gt;8．数组表示法和指针表示法&lt;/p&gt;
&lt;p&gt;使用方括号数组表示法等同于对指针解引用。数组名和指针变量都是如此，因此对于指针和数组名，既可以使用 指针表示法，也可以使用数组表示法。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;52&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210723115130804.png&#34; alt=&#34;image-20210723115130804&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;483-指针和字符串&#34;&gt;4.8.3 指针和字符串&lt;/h3&gt;
&lt;p&gt;数组和指针的特殊关系可以扩展到C-风格字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;char flower[10] = &amp;quot;rose&amp;quot;;
cout &amp;lt;&amp;lt; flower &amp;lt;&amp;lt; &amp;quot;s are red.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码中，数组名是第一个元素的地址，因此cout语句中的flower是包含字符r 的 char 元素的地址。cout 对象认为 char 的地址是字符串的地址，因此它打 印该地址处的字符，然后继续打印后面的字符，直到遇到空字符 (\0)  为止。总之，如果给cout提供一个字符的地址，则它将从该字符开始打 印，直到遇到空字符为止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这意味着可以将指向char的指针变量作为cout的参数，因为它也是 char的地址。&lt;/strong&gt;&lt;br&gt;
在C++中，用引号括起的字符串像数组名一样，也是第一个元素的地 址。这意味着对于数组中的字符串、用引号括起的字符串常量以及指针 所描述的字符串，处理的方式是一样的，都将传递它们的地址。与逐个 传递字符串中的所有字符相比，这样做的工作量确实要少。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 cout 和多数 C++ 表达式中，&lt;code&gt;char&lt;/code&gt; 数组名、&lt;code&gt;char&lt;/code&gt; 指针以及用引号括起的字符串常量都被解释为字符串第一个字符的地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;请不要使用字符串常量或未被初始化的指针来接收输入。为避免这 些问题，也可以使用std::string对象，而不是数组。&lt;/p&gt;
&lt;p&gt;在将字符串读入程序时，应使用已分配的内存地址。该地址可以是数组名，也可以是使用new 初始化过的指针。&lt;/p&gt;
&lt;p&gt;注意这段代码及其输出：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;53&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210723122618520.png&#34; alt=&#34;image-20210723122618520&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一般来说，如果给cout提供一个指针，它将打印地址。但如果指针 的类型为 &lt;code&gt;char *&lt;/code&gt;，则 cout将显示指向的字符串。如果要显示的是字符串的 地址，则必须将这种指针强制转换为另一种指针类型，如 &lt;code&gt;int *&lt;/code&gt;（上面的 代码就是这样做的）。&lt;/p&gt;
&lt;p&gt;经常需要将字符串放到数组中。初始化数组时，请使用=运算符； 否则应使用strcpy( )或strncpy( )。应使用strcpy( )或strncpy( )，而不是赋值运算符来将字符串赋给数组。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是 C-风格 字符串的操作方式，C++ string 类型则并不需要如此，会简单得多，不用担心字符串会导致数 组越界，并可以使用赋值运算符而不是函数strcpy( )和strncpy( )。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;484-使用-new-创建动态结构体&#34;&gt;4.8.4 使用 new 创建动态结构体&lt;/h3&gt;
&lt;p&gt;在运行时创建数组优于在编译时创建数组，对于结构也是如此。通过使用new，可以创建动态结构。&lt;/p&gt;
&lt;p&gt;将 new 用于结构体由两步组成：创建结构体和访问其成员。要创建结构体，需要同时使用结构体类型和 new。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;inflatable *ps = new inflatable;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这将把足以存储inflatable结构的一块可用内存的地址赋给ps。这种 句法和C++的内置类型完全相同。&lt;/p&gt;
&lt;p&gt;此时要访问结构体成员，需通过箭头成员运算符 &lt;code&gt;−&amp;gt;&lt;/code&gt;，它用于指向结构体的指针，就像点运算符可用于结构体名一样，如 &lt;code&gt;ps-&amp;gt;price&lt;/code&gt; 指向了结构体中的 price 成员。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;54&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210723134422484.png&#34; alt=&#34;image-20210723134422484&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;如果结构标识符是结构名，则使用句点运算符；如果标识符是指向结构 的指针，则使用箭头运算符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另一种访问结构成员的方法是先对指针解引用。如果 &lt;code&gt;ps&lt;/code&gt; 是指向结构的指针，则 &lt;code&gt;*ps&lt;/code&gt; 就是被指向的值—结构本身。由于 &lt;code&gt;*ps&lt;/code&gt; 是一个结构，因此 &lt;code&gt;(*ps).price&lt;/code&gt; 是 该结构的 &lt;code&gt;price&lt;/code&gt; 成员。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;55&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210723134903499.png&#34; alt=&#34;image-20210723134903499&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;485-自动存储-静态存储和动态存储&#34;&gt;4.8.5 自动存储、静态存储和动态存储&lt;/h3&gt;
&lt;p&gt;根据用于分配内存的方法，C++有3种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。在存在时间的长短方面，以这3种方式分配的数据对象各不相同。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动存储&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在函数内部定义的常规变量使用自动存储空间，被称为自动变量 （automatic variable），只在包含它的代码中有效，这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。&lt;/p&gt;
&lt;p&gt;自动变量通常存储在栈中。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;静态存储&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;静态存储是整个程序执行期间都存在的存储方式。使变量成为静态 的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用 关键字 &lt;code&gt;static&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;动态存储&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap）。该内存池同用于静态变量和自动变量的内存是分开的。&lt;/p&gt;
&lt;h2 id=&#34;49-类型组合&#34;&gt;4.9 类型组合&lt;/h2&gt;
&lt;p&gt;指针数组，指向指针的指针，也叫二维指针可以用来创建动态二维数组，类型较为复杂。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;56&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210723150508488.png&#34; alt=&#34;image-20210723150508488&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;410-数组的替代品&#34;&gt;4.10 数组的替代品&lt;/h2&gt;
&lt;p&gt;STL 标准库中的模板类 &lt;code&gt;vector&lt;/code&gt; 和 &lt;code&gt;array&lt;/code&gt; 是数组的替代品。&lt;/p&gt;
&lt;h3 id=&#34;4101-模板类-vector&#34;&gt;4.10.1 模板类 vector&lt;/h3&gt;
&lt;p&gt;模板类 &lt;code&gt;vector&lt;/code&gt; 类似于 &lt;code&gt;string&lt;/code&gt; 类，也是一种动态数组，创建时要包含头文件 vector 。可以在运行阶段设置 &lt;code&gt;vector&lt;/code&gt; 对象的长度，也可在末尾附加新数据，还可以在中间插入新数据，&lt;code&gt;vector&lt;/code&gt; 的长度不要求必须设定，因为它会依据插入的数据量自动增长，容量增长的速度是 2 的 &lt;code&gt;n&lt;/code&gt; 次方。&lt;/p&gt;
&lt;p&gt;基本上，它是使用 &lt;code&gt;new&lt;/code&gt; 创建动态数组的替代品。实际上，&lt;code&gt;vector&lt;/code&gt; 类确实使用 &lt;code&gt;new&lt;/code&gt; 和&lt;code&gt;delete&lt;/code&gt; 来管理内存，但这种工作是自动完成的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt; 的声明方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;#include&amp;lt;vector&amp;gt;
vector&amp;lt;typeName&amp;gt; v_name(number);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样 v_name 就是一个 vector 对象，但 number 不是必须的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt; 的最完整文档和例子，应参照网站 &lt;a href=&#34;http://cplusplus.com/reference/vector/vector&#34;&gt;http://cplusplus.com/reference/vector/vector&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;4102-模板类arrayc11&#34;&gt;4.10.2 模板类array（C++11）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt; 类的功能比数组强大，但付出的代价是效率稍低（其实没那么低效）。如果您需 要的是长度固定的数组，使用数组是更佳的选择，但代价是不那么方便 和安全。有鉴于此，C++11 新增了模板类 &lt;code&gt;array&lt;/code&gt;，它也位于名称空间 &lt;code&gt;std&lt;/code&gt; 中。与数组一样，&lt;code&gt;array&lt;/code&gt; 对象的长度也是固定的，也使用栈（静态内存分 配），而不是自由存储区，因此其效率与数组相同，但更方便，更安全。&lt;/p&gt;
&lt;p&gt;要创建array对象，需要包含头文件array。array对象的创建语法与 vector稍有不同：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;#include&amp;lt;array&amp;gt;

array&amp;lt;typeName, num_element&amp;gt; arr;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与创建 &lt;code&gt;vector&lt;/code&gt; 对象不同的是，n_element 不能是变量，必须是固定的常量和普通数组要求一样。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过 &lt;code&gt;array&lt;/code&gt; 模板类创建数组有什么优势？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://cplusplus.com/reference/array/array&#34;&gt;https://cplusplus.com/reference/array/array&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;4103-比较数组-vector-对象和-array-对象&#34;&gt;4.10.3 比较数组、vector 对象和 array 对象&lt;/h3&gt;
&lt;p&gt;这三者的异同是什么？&lt;/p&gt;
&lt;p&gt;首先，无论是数组、&lt;code&gt;vector&lt;/code&gt; 对象还是 &lt;code&gt;array&lt;/code&gt; 对象，都可使用标 准数组表示法来访问各个元素；&lt;/p&gt;
&lt;p&gt;其次，从地址可知，&lt;code&gt;array&lt;/code&gt; 对象和数组存 储在相同的内存区域（即栈）中，而&lt;code&gt;vector&lt;/code&gt; 对象存储在另一个区域（自由存储区或堆）中；&lt;/p&gt;
&lt;p&gt;第三，&lt;strong&gt;可以将一个 &lt;code&gt;array&lt;/code&gt; 对象直接赋给另一个 &lt;code&gt;array&lt;/code&gt; 对象，而标准数组，必须逐元素复制数据&lt;/strong&gt; (使用 array 模板类的两个好处之一，另一个好处是控制数组超界风险)。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;57&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210723153517389.png&#34; alt=&#34;image-20210723153517389&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;58&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210723160219245.png&#34; alt=&#34;image-20210723160219245&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在上面代码中注意一个语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;a1[-2] = 20.2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是什么意思？这个语句会被转换为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;*(a1 - 2) = 20.2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;含义是：找到a1指向的地方，向前移两个double元素，并将 20.2存储到目的地。也就是说，将信息存储到数组的外面。&lt;strong&gt;与C语言一 样，C++也不检查这种超界错误&lt;/strong&gt;，也就是说数组的这种行为是不安全的，C++ 却不禁止，要小心。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt; 和 &lt;code&gt;array&lt;/code&gt; 对象能够禁止这种行为吗？如果您让它们禁止，它们 就能禁止。另外，这 些类还让您能够降低意外超界错误的概率。例如，它们包含成员函数 &lt;code&gt;begin()&lt;/code&gt; 和 &lt;code&gt;end()&lt;/code&gt;，让您能够确定边界，以免无意间超界。&lt;/p&gt;
&lt;h2 id=&#34;411-总结&#34;&gt;4.11 总结&lt;/h2&gt;
&lt;p&gt;数组、结构体和指针是C++的3种复合类型。&lt;/p&gt;
&lt;p&gt;数组可以在一个数据对 象中存储多个同种类型的值。通过使用索引或下标，可以访问数组中各 个元素。&lt;/p&gt;
&lt;p&gt;结构体可以将多个不同类型的值存储在同一个数据对象中，可以使用成员关系运算符&lt;code&gt;.&lt;/code&gt; 来访问其中的成员。使用结构体的第一步是创建结构体模板，它定义结构存储了哪些成员。&lt;strong&gt;模板的名称将成为新类型的标识符，然后就可以声明这种类型的结构变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;指针是被设计用来存储地址的变量，指针指向它存储的地 址。指针声明指出了指针指向的对象的类型。对指针应用解引用运算符 &lt;code&gt;*&lt;/code&gt;，将得到指针指向的位置中的值。&lt;/p&gt;
&lt;p&gt;字符串是以空字符为结尾的一系列字符。字符串可用引号括起的字 符串常量表示，其中隐式包含了结尾的空字符。可以将字符串存储在 char数组中，可以用被初始化为指向字符串的char指针表示字符串。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt; 对象将根据要存储的字符串自动调整其 大小，用户可以使用赋值运算符来复制字符串。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt; 运算符允许在程序运行时为数据对象请求内存。该运算符返回 获得内存的地址，可以将这个地址赋给一个指针，程序将只能使用该指 针来访问这块内存。使用解引用运算符 &lt;code&gt;*&lt;/code&gt; 获得其值；如果数据对象是数组，则可以像使用数组名那样使用指针来访问元素；如果数据对象是结构体，则可以用指针解引用运算符 &lt;code&gt;-&amp;gt;&lt;/code&gt; 访问其成员。&lt;/p&gt;
&lt;p&gt;指针和数组紧密相关。如果 &lt;code&gt;ar&lt;/code&gt; 是数组名，则表达式 &lt;code&gt;ar[i]&lt;/code&gt; 被解释为  &lt;code&gt;*(ar + i)&lt;/code&gt;（ &lt;code&gt;i&lt;/code&gt; 可以是负值，表示指针左移），其中数组名被解释为数组第一个元素的地址。这样，数组名的作用和指针相同。反过来，可以使用数组表示法，通过指针名来访 问new分配的数组中的元素。&lt;/p&gt;
&lt;p&gt;运算符 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 允许显式控制何时给数据对象分配内存，何时将内存归还给内存池。&lt;/p&gt;
&lt;h1 id=&#34;第五章-循环和关系表达式&#34;&gt;第五章 循环和关系表达式&lt;/h1&gt;
&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for 循环；&lt;/li&gt;
&lt;li&gt;表达式和语句；&lt;/li&gt;
&lt;li&gt;递增运算符和递减运算符： ++ 和 --；&lt;/li&gt;
&lt;li&gt;组合赋值运算符；&lt;/li&gt;
&lt;li&gt;复合语句（语句块）；&lt;/li&gt;
&lt;li&gt;逗号运算符；&lt;/li&gt;
&lt;li&gt;关系运算符：&amp;gt;、&amp;gt;=、==、&amp;lt;=、&amp;lt; 和 !=；&lt;/li&gt;
&lt;li&gt;while 循环；&lt;/li&gt;
&lt;li&gt;typedef 工具；&lt;/li&gt;
&lt;li&gt;do while 循环；&lt;/li&gt;
&lt;li&gt;字符输入方法 get() ；&lt;/li&gt;
&lt;li&gt;文件尾条件；&lt;/li&gt;
&lt;li&gt;嵌套循环和二维数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;51-for-循环&#34;&gt;5.1 for 循环&lt;/h2&gt;
&lt;h3 id=&#34;511-for-循环初始化&#34;&gt;5.1.1 for 循环初始化&lt;/h3&gt;
&lt;p&gt;for循环为执行重复的操作提供了循序渐进的步骤。组成部分完成下面这些步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置初始值；&lt;/li&gt;
&lt;li&gt;执行测试，判断循环是否应当继续进行；&lt;/li&gt;
&lt;li&gt;执行循环操作；&lt;/li&gt;
&lt;li&gt;更新用于测试的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;初始化、测试和更 新操作构成了控制部分，这些操作由括号括起。其中每部分都是一个表 达式，彼此由分号隔开。控制部分后面的语句叫作循环体，只要测试表 达式为true，它便被执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;for (initialization; test-expression; update-expression)
    body;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;循环体如果大于一条语句，需要加花括号：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;for (initialization; test-expression; update-expression) {
    body;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C++语法将整个for看作一条语句—虽然循环体可以包含一条或多条 语句。循环只执行一次初始化。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for&lt;/code&gt; 是一个 C++ 关键字，编译器不会将 &lt;code&gt;for&lt;/code&gt; 视为一个函 数，这还将防止将函数命名为 &lt;code&gt;for&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;59&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727003613922.png&#34; alt=&#34;image-20210727003613922&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;【编程风格 Tips】C++ 常用的方式是，在 for 和括号之间加上一个空格，但省略函数名与括号之间的空格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看这个表达式赋值逻辑：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;x = y = z = 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;赋值运算符是从右向左结合的&lt;/strong&gt;，因此首先将0赋给z，然 后将z = 0赋给y，依此类推。&lt;/p&gt;
&lt;p&gt;C++在C循环的基础上添加了一项特性，要求对for循环句法做一些 微妙的调整。&lt;/p&gt;
&lt;p&gt;这是原来的句法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;for (expresson; expression; expression)
    statement;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但，C++循环允许像下面这样做：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;for (int i=0; i&amp;lt;5; ++i)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是说，可以在for循环的初始化部分中声明变量。这很方便，但并不适用于原来的句法，因为声明不是表达式。这个变量的生存时间只存在于for语句中，也就是说，当程序离开循环后，&lt;code&gt;i&lt;/code&gt; 这个变量将消失。&lt;/p&gt;
&lt;h3 id=&#34;512-回到for循环&#34;&gt;5.1.2 回到for循环&lt;/h3&gt;
&lt;p&gt;很简单，略。&lt;/p&gt;
&lt;h3 id=&#34;513-修改步长&#34;&gt;5.1.3 修改步长&lt;/h3&gt;
&lt;p&gt;循环示例每一轮循环都将循环计数加1或减1。可以通 过修改更新表达式来修改步长，例如改为表达式 &lt;code&gt;i = i + by&lt;/code&gt;，其中 &lt;code&gt;by&lt;/code&gt; 是用户选择的步长值。&lt;/p&gt;
&lt;h3 id=&#34;514-使用for循环访问字符串&#34;&gt;5.1.4 使用for循环访问字符串&lt;/h3&gt;
&lt;p&gt;很简单，略。&lt;/p&gt;
&lt;h3 id=&#34;515-递增运算符和递减运算符&#34;&gt;5.1.5 递增运算符（++）和递减运算符（−−）&lt;/h3&gt;
&lt;p&gt;这两个运算符执行两种极其常见 的循环操作：将循环计数加1或减1。这两个运算符都有两种变体。前缀（prefix）版本位于操作数前 面，如++x；后缀（postfix）版本位于操作数后面，如x++。两个版本对操作数的影响是一样的，但是影响的时间不同。这就像对于钱包来说， 清理草坪之前付钱和清理草坪之后付钱的最终结果是一样的，但支付钱 的时间不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;粗略地讲，a++意味着使用a的当前值计算表达式，然后将a的值加 1；而++b的意思是先将b的值加1，然后使用新的值来计算表达式。&lt;/strong&gt; 递减操作符也同理。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;60&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727010134791.png&#34; alt=&#34;image-20210727010134791&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;516-副作用和顺序点&#34;&gt;5.1.6 副作用和顺序点&lt;/h3&gt;
&lt;p&gt;C++就递增运算符何时生效的哪些方面做了规 定，哪些方面没有规定。首先，副作用（side effect）指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改；顺序点 （sequence point）是程序执行过程中的一个点，在这里，进入下一步之 前将确保对所有的副作用都进行了评估。在C++中，&lt;strong&gt;语句中的分号就是 一个顺序点&lt;/strong&gt;，这意味着程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必须完成。&lt;/p&gt;
&lt;p&gt;另外，任何完整的表达式末尾都是一个顺序点。&lt;/p&gt;
&lt;p&gt;何为完整表达式呢？它是这样一个表达式：不是另一个更大表达式 的子表达式。完整表达式的例子有：表达式语句中的表达式部分以及用 作while循环中检测条件的表达式。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;61&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727010733540.png&#34; alt=&#34;image-20210727010733540&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;517-前缀格式和后缀格式&#34;&gt;5.1.7 前缀格式和后缀格式&lt;/h3&gt;
&lt;p&gt;如果变量被用于某些目的（如用作函数参数或给变量赋 值），使用前缀格式和后缀格式的结果将不同。&lt;/p&gt;
&lt;p&gt;然而，虽然选择使用前缀格式还是后缀格式对程序的行为没有影 响，但执行速度可能有细微的差别。对于内置类型和当代的编译器而 言，这看似不是什么问题。然而，C++允许您针对类定义这些运算符， 在这种情况下，用户这样定义前缀函数：将值加1，然后返回结果；但后缀版本首先复制一个副本，将其加1，然后将复制的副本返回。因 此，对于类而言，前缀版本的效率比后缀版本高。&lt;/p&gt;
&lt;h3 id=&#34;518-递增递减运算符和指针&#34;&gt;5.1.8 递增/递减运算符和指针&lt;/h3&gt;
&lt;p&gt;可以将递增运算符用于指针和基本变量。将递增 运算符用于指针时，将把指针的值增加其指向的数据类型占用的字节数，这种规则适用于对指针递增和递减。&lt;/p&gt;
&lt;p&gt;前缀递增、前缀递减和解引用运算符的优先级相同，以从右到左的方式进行结合。后缀递增和后缀递减的优先级相同，但比前缀运算符的优先级高，这两个运算符以从左到右的方式进行结合。&lt;/p&gt;
&lt;p&gt;前缀运算符的从右到到结合规则意味着 &lt;code&gt;*++pt&lt;/code&gt; 的含义如下：现将 &lt;code&gt;++&lt;/code&gt; 应用于 &lt;code&gt;pt&lt;/code&gt;（因为 &lt;code&gt;++&lt;/code&gt; 位于 &lt;code&gt;*&lt;/code&gt; 的右边），然后将 &lt;code&gt;*&lt;/code&gt; 应用于被递增后的 &lt;code&gt;pt&lt;/code&gt;。 另一方面，&lt;code&gt;++*pt&lt;/code&gt; 意味着先取得 &lt;code&gt;pt&lt;/code&gt; 指向的值，然后将这个值加 1，&lt;code&gt;pt&lt;/code&gt; 依然指向原来的地址；&lt;/p&gt;
&lt;p&gt;而这个组合 &lt;code&gt;(*pt)++&lt;/code&gt; 圆括号指出，首先对指针解引用，得到值。然后，运算符++将这个值递增 1，但 &lt;code&gt;pt&lt;/code&gt; 仍然指在原来的地址。&lt;/p&gt;
&lt;h3 id=&#34;519-组合赋值运算符&#34;&gt;5.1.9 组合赋值运算符&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;+=&lt;/code&gt; 运算符将两个操作数相加，并将结果赋给左边的操作数。这意味着左边的操作数必须能够被赋值，如变量、数组元素、结构体成员或通过对指针解引用来标识的数据。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;62&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727012040437.png&#34; alt=&#34;image-20210727012040437&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;63&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727012104165.png&#34; alt=&#34;image-20210727012104165&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5110-复合语句语句块&#34;&gt;5.1.10 复合语句（语句块）&lt;/h3&gt;
&lt;p&gt;只有这个地方要注意：假设对循环体进行了缩进，但省略了花括号，编译器将忽略缩进，因此只有第一条语句位于循环中。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;64&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727012230040.png&#34; alt=&#34;image-20210727012230040&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5111-其他语法技巧逗号运算符&#34;&gt;5.1.11 其他语法技巧—逗号运算符&lt;/h3&gt;
&lt;p&gt;语句块允许把两条或更多条语句放到按C++句法 只能放一条语句的地方。逗号运算符对表达式完成同样的任务，允许将 两个表达式放到C++句法只允许放一个表达式的地方。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;++j, --i你  // 没有分号，合法，但不能独立运行，要在另外语句中，如 for 里
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;65&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727012641834.png&#34; alt=&#34;image-20210727012641834&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;但逗号并不总是逗号运算符。 如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;int i, j; // 个声明中的逗号将变量列 表中相邻的名称分开
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到目前为止，逗号运算符最常见的用途是将两个或更多的表达式放 到一个for循环表达式中。不过C++还为这个运算符提供了另外两个特 性。首先，它确保先计算第一个表达式，然后计算第二个表达式（换句 话说，逗号运算符是一个顺序点）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;i = 20, j = 2 * i   // 这是合法的，这里 y 是 40
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在所有运算符中，逗号运算符的优先级是最低的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;66&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727013030988.png&#34; alt=&#34;image-20210727013030988&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5112-关系表达式&#34;&gt;5.1.12 关系表达式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;67&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727013059937.png&#34; alt=&#34;image-20210727013059937&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5113-赋值-比较和可能犯的错误&#34;&gt;5.1.13 赋值、比较和可能犯的错误&lt;/h3&gt;
&lt;p&gt;很简单，略。&lt;/p&gt;
&lt;h3 id=&#34;5114-c-风格字符串的比较&#34;&gt;5.1.14 C-风格字符串的比较&lt;/h3&gt;
&lt;p&gt;假设要知道字符数组中的字符串是不是mate。如果word是数组名， 下面的测试可能并不能像我们预想的那样工作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;word == &amp;quot;mate&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;请记住，数组名是数组的地址。同样，用引号括起的字符串常量也 是其地址。因此，上面的关系表达式不是判断两个字符串是否相同，而 是查看它们是否存储在相同的地址上。两个字符串的地址是否相同呢？ 回答是否定的，虽然它们包含相同的字符。&lt;/p&gt;
&lt;p&gt;由于C++将C-风格字符串视为地址，因此如果使用关系运算符来比 较它们，将无法得到满意的结果。需要用 C 字符串库中的 strcmp() 函数来比较。 该函数接受两个字符串地址作为参数。这意味着 参数可以是指针、字符串常量或字符数组名。如果两个字符串相同，该 函数将返回零；如果第一个字符串按字母顺序排在第二个字符串之前， 则strcmp( )将返回一个负数值；如果第一个字符串按字母顺序排在第二 个字符串之后，则strcpm( )将返回一个正数值。实际上，“按系统排列顺 序”比“按字母顺序”更准确。这意味着字符是根据字符的系统编码来进 行比较的。例如，使用ASCII码时，所有大写字母的编码都比小写字母 小，所以按排列顺序，大写字母将位于小写字母之前。因此，字符 串“Zoo”在字符串“aviary”之前。&lt;/p&gt;
&lt;p&gt;存储在不同长度的数组 中的字符串彼此不相等。但是C-风格字符串是通过结尾的空值字符定义 的，而不是由其所在数组的长度定义的。这意味着两个字符串即使被存 储在长度不同的数组中，也可能是相同的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;68&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727014019373.png&#34; alt=&#34;image-20210727014019373&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5115-比较string类字符串&#34;&gt;5.1.15 比较string类字符串&lt;/h3&gt;
&lt;p&gt;如果使用string类字符串而不是C-风格字符串，比较起来将简单些。直接通过运算符比较：&amp;gt;, &amp;lt;, == 等。&lt;/p&gt;
&lt;h2 id=&#34;52-while-循环&#34;&gt;5.2 while 循环&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;while&lt;/code&gt; 循环是一个没有初始化和更新部分的 &lt;code&gt;for&lt;/code&gt; 循环，它只有测试条件和循环体，与for循环一样，循环体也由一条语句或两个花括号定义的语句块组成。句法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;while (test-condition)
    body
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果循环体有多条语句，需要花括号：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;while (test-condition) {
    body
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先，程序计算圆括号内的测试条件（test-condition）表达式。如 果该表达式为true，则执行循环体中的语句。执行完循环体后，程序返 回测试条件，对它进行重新评估。如果该条件为非零，则再次执行循环 体。测试和执行将一直进行下去，直到测试条件为false为止。&lt;/p&gt;
&lt;p&gt;while 循环和 for 循环一样，也是一 种入口条件循环。因此，如果测试条件一开始便为false，则程序将不会 执行循环体。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;69&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727121115868.png&#34; alt=&#34;image-20210727121115868&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;521-for-与-while&#34;&gt;5.2.1 for 与 while&lt;/h3&gt;
&lt;p&gt;在C++中，for 和 while 循环本质上是相同的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;70&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727121739245.png&#34; alt=&#34;image-20210727121739245&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;但它们之间存在三个差别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;for&lt;/code&gt; 循环中省略了测试条件时，将认为条件为 &lt;code&gt;true&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;for&lt;/code&gt; 循环中，可使用初始化语句声明一个局部变量，但在 &lt;code&gt;while&lt;/code&gt; 循环中不能这样做；&lt;/li&gt;
&lt;li&gt;如果循环体中包括 &lt;code&gt;continue&lt;/code&gt; 语句，情况将稍有不同，&lt;code&gt;continue&lt;/code&gt; 语句将在第6章讨论。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，程序员使用 &lt;code&gt;for&lt;/code&gt; 循环来为循环计数，因为 &lt;code&gt;for&lt;/code&gt; 循环格式允许将所有相关的信息—初始值、终止值和更新计数器的方法—放在同一个地方。在无法预先知道循环将执行的次数时，程序员常使用 &lt;code&gt;while&lt;/code&gt; 循环。&lt;/p&gt;
&lt;h3 id=&#34;522-等待一段时间编写延时循环&#34;&gt;5.2.2 等待一段时间：编写延时循环&lt;/h3&gt;
&lt;p&gt;函数 &lt;code&gt;clock()&lt;/code&gt; 可以返回程序开始执行后所用的系统时间。但，首先，clock( )返回时间的单位不一定是秒；其次，该函数的返回类 型在某些系统上可能是long，在另一些系统上可能是unsigned long或其 他类型。&lt;/p&gt;
&lt;p&gt;头文件 &lt;code&gt;ctime&lt;/code&gt; 提供了这些问题的解决方案。首先，它定义了一个符号常量—&lt;code&gt;CLOCKS_PER_SEC&lt;/code&gt;，该常量等于 每秒钟包含的系统时间单位数。因此，将系统时间除以这个值，可以得 到秒数。或者将秒数乘以 &lt;code&gt;CLOCK_PER_SEC&lt;/code&gt;，可以得到以系统时间单位 为单位的时间。其次，&lt;code&gt;ctime&lt;/code&gt; 将 &lt;code&gt;clock_t&lt;/code&gt; 作为 &lt;code&gt;clock()&lt;/code&gt; 返回类型的别名，这意味着可以将变量声明为 &lt;code&gt;clock_t&lt;/code&gt; 类型，编译器将把它转换为long、unsigned int 或适合系统的其他类型。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;71&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727133448815.png&#34; alt=&#34;image-20210727133448815&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;do-while-循环&#34;&gt;do while 循环&lt;/h2&gt;
&lt;p&gt;它 不同于另外两种循环，因为它是出口条件（exit condition）循环。这意 味着这种循环将首先执行循环体，然后再判定测试表达式，决定是否应 继续执行循环。如果条件为false，则循环终止；否则，进入新一轮的执 行和测试。这样的循环通常至少执行一次，循环体是一条语句或用括号括起的语句块。句法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;do {
    body
} while (test-condition);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;72&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727135803904.png&#34; alt=&#34;image-20210727135803904&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;54-基于范围的for循环c11&#34;&gt;5.4 基于范围的for循环（C++11）&lt;/h2&gt;
&lt;p&gt;C++11新增了一种循环：基于范围（range-based）的for循环。这简化了一种常见的循环任务：对数组（或容器类，如vector和array）的每 个元素执行相同的操作。&lt;/p&gt;
&lt;h2 id=&#34;55-循环和文本输入&#34;&gt;5.5 循环和文本输入&lt;/h2&gt;
&lt;h3 id=&#34;551-使用原始的cin进行输入&#34;&gt;5.5.1 使用原始的cin进行输入&lt;/h3&gt;
&lt;p&gt;为什么程序在输出时省略了空格呢？原因 在cin。读取char值时，与读取其他基本类型一样，cin将忽略空格和换行 符。因此输入中的空格没有被回显，也没有被包括在计数内。&lt;/p&gt;
&lt;p&gt;更为复杂的是，发送给cin的输入被缓冲。这意味着只有在用户按 下回车键后，他输入的内容才会被发送给程序。这就是在运行该程序 时，可以在#后面输入字符的原因。按下回车键后，整个字符序列将被 发送给程序，但程序在遇到#字符后将结束对输入的处理。&lt;/p&gt;
&lt;h3 id=&#34;552-使用cingetchar进行补救&#34;&gt;5.5.2 使用cin.get(char)进行补救&lt;/h3&gt;
&lt;p&gt;通常，逐个字符读取输入的程序需要检查每个字符，包括空格、制 表符和换行符。&lt;code&gt;cin&lt;/code&gt; 所属的 &lt;code&gt;istream&lt;/code&gt; 类（在 &lt;code&gt;iostream&lt;/code&gt; 中定义）中包含一个能 够满足这种要求的成员函数。具体地说，成员函数cin.get(ch)读取输入 中的下一个字符（即使它是空格），并将其赋给变量ch。使用这个函数 调用替换cin&amp;gt;&amp;gt;ch，可以修补程序清单5.16的问题。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;73&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727161504704.png&#34; alt=&#34;image-20210727161504704&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;在C语言中， 要修改变量的值，必须将变量的地址传递给函数。但程序清单5.17调用 cin.get( )时，传递的是ch，而不是&amp;amp;ch。在C语言中，这样的代码无效， 但在C++中有效，只要函数将参数声明为引用即可。引用是C++在C语 言的基础上新增的一种类型。头文件iostream将cin.get(ch)的参数声明为 引用类型，因此该函数可以修改其参数的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;553-使用哪一个cinget&#34;&gt;5.5.3 使用哪一个cin.get( )&lt;/h3&gt;
&lt;p&gt;函数重载允许创建多个同名函数，条件是它们 的参数列表不同。例如，如果在C++中使用 &lt;code&gt;cin.get(name，ArSize)&lt;/code&gt;， 则编译器将找到使用 &lt;code&gt;char*&lt;/code&gt; 和 &lt;code&gt;int&lt;/code&gt; 作为参数的 &lt;code&gt;cin.get()&lt;/code&gt; 版本；如果使用 &lt;code&gt;cin.get(ch)&lt;/code&gt;，则编译器将使用接受一个 &lt;code&gt;char&lt;/code&gt; 参数的版本；如果没有提 供参数，则编译器将使用不接受任何参数的&lt;code&gt;cin.get()&lt;/code&gt; 版本。函数重载允 许对多个相关的函数使用相同的名称，这些函数以不同方式或针对不同类型执行相同的基本任务。&lt;/p&gt;
&lt;h3 id=&#34;554-文件尾条件&#34;&gt;5.5.4 文件尾条件&lt;/h3&gt;
&lt;p&gt;如果输入来自于文件，则可以使用一种功能更强大的技 术—检测文件尾（EOF）。C++输入工具和操作系统协同工作，来检测文件尾并将这种信息告知程序。&lt;/p&gt;
&lt;p&gt;检测到EOF后，cin将两位（eofbit和failbit）都设置为1。可以通过 成员函数eof( )来查看eofbit是否被设置；如果检测到EOF，则cin.eof( )将 返回bool值true，否则返回false。同样，如果eofbit或failbit被设置为1， 则fail( )成员函数返回true，否则返回false。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;74&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727162259773.png&#34; alt=&#34;image-20210727162259773&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;555-另一个cinget-版本&#34;&gt;5.5.5 另一个cin.get( )版本&lt;/h3&gt;
&lt;p&gt;为成功地使用cin.get( )，需要知道其如何处理EOF条件。当该函数 到达EOF时，将没有可返回的字符。相反，cin.get( )将返回一个用符号 常量EOF表示的特殊值。该常量是在头文件iostream中定义的。EOF值 必须不同于任何有效的字符值，以便程序不会将EOF与常规字符混淆。 通常，EOF被定义为值−1，因为没有ASCII码为−1的字符，但并不需要知道实际的值，而只需在程序中使用EOF即可。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;75&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727162823543.png&#34; alt=&#34;image-20210727162823543&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;76&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727163014040.png&#34; alt=&#34;image-20210727163014040&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;另一方面，使用cin.get(ch)（有一个参数）进行输入时，将不会导 致任何类型方面的问题。前面讲过，cin.get(char)函数在到达EOF时，不 会将一个特殊值赋给ch。事实上，在这种情况下，它不会将任何值赋给 ch。ch不会被用来存储非char值。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;77&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727163117901.png&#34; alt=&#34;image-20210727163117901&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;那么应使用cin.get( )还是cin.get(char)呢？使用字符参数的版本更符 合对象方式，因为其返回值是istream对象。这意味着可以将它们拼接起 来。例如，下面的代码将输入中的下一个字符读入到ch1中，并将接下 来的一个字符读入到ch2中:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;cin.get(ch1).get(ch2);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;56-嵌套循环和二维数组&#34;&gt;5.6 嵌套循环和二维数组&lt;/h2&gt;
&lt;p&gt;C++没有提供二维数组类型，但用户可以创建每个元素本身都是数 组的数组。可以这样声明数组：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;
int maxtemps[4][5];
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;78&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727163540362.png&#34; alt=&#34;image-20210727163540362&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;79&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727163623327.png&#34; alt=&#34;image-20210727163623327&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;80&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210727163905902.png&#34; alt=&#34;image-20210727163905902&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;假设要打印数组所有的内容，可以用一个for循环来改变行，用另一 个被嵌套的for循环来改变列：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;for (int row = 0; row &amp;lt; 4; ++row) {
    for (int col=0; col &amp;lt; 5; ++col) {
        cout &amp;lt;&amp;lt; maxtemps[row][col] &amp;lt;&amp;lt; &amp;quot;\t&amp;quot;;
    }
    cout &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;实际上，我更喜欢用 vector 来创建动态二维数据，只要创建 vector 的vector 就行，用起来更简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;57-总结&#34;&gt;5.7 总结&lt;/h2&gt;
&lt;p&gt;C++提供了3种循环：for循环、while循环和do while循环。如果循环 测试条件为true或非零，则循环将重复执行一组指令；如果测试条件为 false或0，则结束循环。for循环和while循环都是入口条件循环，这意味 着程序将在执行循环体中的语句之前检查测试条件。do while循环是出 口条件循环，这意味着其将在执行循环体中的语句之后检查条件。&lt;/p&gt;
&lt;p&gt;关系表达式对两个值进行比较，常被用作循环测试条件。关系表达 式是通过使用6种关系运算符之一构成的：&lt;code&gt;&amp;lt;&lt;/code&gt;、&lt;code&gt;&amp;lt;=&lt;/code&gt;、&lt;code&gt;==&lt;/code&gt;、&lt;code&gt;&amp;gt;=&lt;/code&gt;、&lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;!=&lt;/code&gt;。 关系表达式的结果为bool类型，值为true或false。&lt;/p&gt;
&lt;h1 id=&#34;第六章-分支语句和逻辑运算符&#34;&gt;第六章 分支语句和逻辑运算符&lt;/h1&gt;
&lt;p&gt;本章的内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if&lt;/code&gt; 语句；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if else&lt;/code&gt; 语句；&lt;/li&gt;
&lt;li&gt;逻辑运算符：&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;||&lt;/code&gt; 和 &lt;code&gt;!&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cctype&lt;/code&gt; 字符函数库；&lt;/li&gt;
&lt;li&gt;条件运算符：&lt;code&gt;?:&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;switch&lt;/code&gt; 语句；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;continue&lt;/code&gt; 和 &lt;code&gt;break&lt;/code&gt; 语句；&lt;/li&gt;
&lt;li&gt;读取数字的循环；&lt;/li&gt;
&lt;li&gt;基本文件输入/输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;61-if-语句&#34;&gt;6.1 &lt;code&gt;if&lt;/code&gt; 语句&lt;/h2&gt;
&lt;p&gt;如果测试条件为 &lt;code&gt;true&lt;/code&gt;， 则 &lt;code&gt;if&lt;/code&gt; 语句将引导程序执行语句或语句块；如果条件是&lt;code&gt;false&lt;/code&gt;，程序将跳过 这条语句或语句块。因此，&lt;code&gt;if&lt;/code&gt; 语句让程序能够决定是否应执行特定的语句。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;81&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728225254330.png&#34; alt=&#34;image-20210728225254330&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;611-if-else-语句&#34;&gt;6.1.1 &lt;code&gt;if else&lt;/code&gt; 语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt; 语句让程序决定是否执行特定的语句或语句块，而&lt;code&gt;if else&lt;/code&gt;语句则让程序决定执行两条语句或语句块中的哪一条，这种语句对于选择其中一 种操作很有用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;if else&lt;/code&gt; 语句的通用格式如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;82&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728225544934.png&#34; alt=&#34;image-20210728225544934&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;83&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728225606236.png&#34; alt=&#34;image-20210728225606236&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;612-格式化-if-else-语句&#34;&gt;6.1.2 格式化 &lt;code&gt;if else&lt;/code&gt; 语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;if else&lt;/code&gt; 中的两种操作都必须是一条语句。如果需要多条语句，需要 用大括号将它们括起来，组成一个块语句。&lt;/p&gt;
&lt;h3 id=&#34;613-if-else-if-else-结构&#34;&gt;6.1.3  &lt;code&gt;if&lt;/code&gt;- &lt;code&gt;else if&lt;/code&gt;- &lt;code&gt;else&lt;/code&gt; 结构&lt;/h3&gt;
&lt;p&gt;计算机程序也可能提供两个以上的 选择。可以将&lt;code&gt;C++&lt;/code&gt;的 &lt;code&gt;if else&lt;/code&gt; 语句进行扩展来满足这种需求。正如读者知 道的，&lt;code&gt;else&lt;/code&gt; 之后应是一条语句，也可以是语句块。由于 &lt;code&gt;if else&lt;/code&gt; 语句本身是 一条语句，所以可以放在 &lt;code&gt;else&lt;/code&gt; 的后面。&lt;/p&gt;
&lt;h2 id=&#34;62-逻辑表达式&#34;&gt;6.2 逻辑表达式&lt;/h2&gt;
&lt;p&gt;C++ 提供了3种逻辑运算符，来组合或修改已有的表达式。这些运算符分别是逻 辑 &lt;code&gt;OR (||)&lt;/code&gt;、逻辑 &lt;code&gt;AND (&amp;amp;&amp;amp;)&lt;/code&gt;和逻辑 &lt;code&gt;NOT (!)&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;621-逻辑or运算符&#34;&gt;6.2.1 逻辑OR运算符：&lt;code&gt;||&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;C++可以采用逻辑OR运算 符 &lt;code&gt;||&lt;/code&gt;，将两个表达式组合在一起。如果原来表达式中的任何一个或 全部都为 &lt;code&gt;true&lt;/code&gt;（或非零），则得到的表达式的值为 &lt;code&gt;true&lt;/code&gt;；否则，表达式的值为 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;C++ 规定 &lt;code&gt;||&lt;/code&gt; 运算符是个顺序点（sequence point）。也是说，先修改左侧的值，再对右侧的值进行判定（C++11的说法是，运算符左边的子表达式先于右边的子表达式）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;84&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728230438579.png&#34; alt=&#34;image-20210728230438579&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;622-逻辑and运算符&#34;&gt;6.2.2 逻辑AND运算符：&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;逻辑AND运算符 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;，也是将两个表达式组合成一个表达式。 仅当原来的两个表达式都为 &lt;code&gt;true&lt;/code&gt; 时，得到的表达式的值才为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符也是顺序点，因此将首先判定左侧， 并且在右侧被判定之前产生所有的副作用。如果左侧为 &lt;code&gt;false&lt;/code&gt;，则整个逻 辑表达式必定为 &lt;code&gt;false&lt;/code&gt;，在这种情况下，C++ 将不会再对右侧进行判定。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;85&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728230605370.png&#34; alt=&#34;image-20210728230605370&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;623-用-来设置取值范围&#34;&gt;6.2.3 用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 来设置取值范围&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符还允许建立一系列&lt;code&gt;if&lt;/code&gt; &lt;code&gt;else if&lt;/code&gt; &lt;code&gt;else&lt;/code&gt;语句，其中每种选择都对 应于一个特定的取值范围。&lt;/p&gt;
&lt;h3 id=&#34;624-逻辑not运算符&#34;&gt;6.2.4 逻辑NOT运算符：&lt;code&gt;!&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;!&lt;/code&gt; 运算符将它后面的表达式的真值取反。也是说，如果 &lt;code&gt;expression&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;，则 &lt;code&gt;!expression&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt;；如果 &lt;code&gt;expression&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;，则 &lt;code&gt;!expression&lt;/code&gt;是 &lt;code&gt;true&lt;/code&gt;。更准确地说，如果 &lt;code&gt;expression&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 或非零，则 &lt;code&gt;!expression&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然而，&lt;code&gt;!&lt;/code&gt; 运算符对于返回 &lt;code&gt;true-false&lt;/code&gt; 值或可以被解释为 &lt;code&gt;true-false&lt;/code&gt; 值的函数来说很有用。例如，如果C-风格字符串 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 不同，则 &lt;code&gt;strcmp(s1,s2)&lt;/code&gt; 将返回非零&lt;code&gt;true&lt;/code&gt;值，否则返回 &lt;code&gt;0&lt;/code&gt;。这意味着如果这两个字符串相同， 则 &lt;code&gt;!strcmp(s1,s2)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;625-逻辑运算符细节&#34;&gt;6.2.5 逻辑运算符细节&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;!&lt;/code&gt; 运算符的优先级高于所有的关系运算符和算术运算符。因此，要对表达式求反，必须用括号将其括起。&lt;/p&gt;
&lt;h3 id=&#34;626-其他表示方式&#34;&gt;6.2.6 其他表示方式&lt;/h3&gt;
&lt;p&gt;并不是所有的键盘都提供了用作逻辑运算符的符号，因此C++标准 提供了另一种表示方式，如表6.3所示。标识符&lt;code&gt;and&lt;/code&gt;、&lt;code&gt;or&lt;/code&gt;和&lt;code&gt;not&lt;/code&gt;都是C++保 留字，这意味着不能将它们用作变量名等。它们不是关键字，因为它们 都是已有语言特性的另一种表示方式。另外，它们并不是C语言中的保 留字，但C语言程序可以将它们用作运算符，只要在程序中包含了头文 件 &lt;code&gt;iso646.h&lt;/code&gt;。C++不要求使用头文件。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;86&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728232023659.png&#34; alt=&#34;image-20210728232023659&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;63-字符函数库-cctype&#34;&gt;6.3 字符函数库 &lt;code&gt;cctype&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;C++ 从 C 语言继承了一个与字符相关的、非常方便的函数软件包， 它可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这 些函数的原型是在头文件&lt;code&gt;cctype&lt;/code&gt;（老式的风格中为 &lt;code&gt;ctype.h&lt;/code&gt;）中定义的。 例如，如果 &lt;code&gt;ch&lt;/code&gt; 是一个字母，则 &lt;code&gt;isalpha(ch)&lt;/code&gt; 函数返回一个非零值，否则返回 &lt;code&gt;0&lt;/code&gt;。同样，如果 &lt;code&gt;ch&lt;/code&gt; 是标点符号（如逗号或句号），函数 &lt;code&gt;ispunct(ch)&lt;/code&gt; 将返回 &lt;code&gt;true&lt;/code&gt;。（&lt;strong&gt;注意这些函数的返回类型为 &lt;code&gt;int&lt;/code&gt;，而不是 &lt;code&gt;bool&lt;/code&gt;， 但通常 &lt;code&gt;bool&lt;/code&gt; 转换能够将它们视为&lt;code&gt;bool&lt;/code&gt; 类型&lt;/strong&gt;）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;87&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728232352198.png&#34; alt=&#34;image-20210728232352198&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;isalpha()&lt;/code&gt; 不仅更容易使用，而且更通用。例子中用AND/OR格式假设A-Z的字符编码是连续的，其他字符的编码不在这个范围内。这种假设对于ASCII码来说是成立的，但也并非总是如此。&lt;/p&gt;
&lt;p&gt;具体地说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isalpha()&lt;/code&gt; 用来检查字符是否为字母字符；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isdigit()&lt;/code&gt; 用来测试字符是否为数字字符（0~9），如 3；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isspace()&lt;/code&gt; 用来测试字符是否为空白，包括换行符、空格和制表符；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ispunct()&lt;/code&gt; 用来测试字符是否为标点符号。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;88&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728232647223.png&#34; alt=&#34;image-20210728232647223&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;总结一下这个函数包：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;89&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728232856482.png&#34; alt=&#34;image-20210728232856482&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;90&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728232930054.png&#34; alt=&#34;image-20210728232930054&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;64-运算符&#34;&gt;6.4 &lt;code&gt;?:&lt;/code&gt; 运算符&lt;/h2&gt;
&lt;p&gt;C++有一个常被用来代替 &lt;code&gt;if else&lt;/code&gt; 语句的运算符，这个运算符被称为条件运算符 &lt;code&gt;?:&lt;/code&gt;，它是C++中唯一一个需要3个操作数的运算符，也叫&lt;strong&gt;三目运算符&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;expression1 ? expression2 : expression3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 &lt;code&gt;expression1&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;，则整个条件表达式的值为 &lt;code&gt;expression2&lt;/code&gt; 的值； 否则，整个表达式的值为 &lt;code&gt;expression3&lt;/code&gt; 的值。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;91&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728233356197.png&#34; alt=&#34;image-20210728233356197&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;65-switch语句&#34;&gt;6.5 &lt;code&gt;switch&lt;/code&gt;语句&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;92&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728234430665.png&#34; alt=&#34;image-20210728234430665&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt; 语句与 Pascal 等语言中类似的语句之间存在重大的差别。 C++中的 &lt;code&gt;case&lt;/code&gt; 标签只是行标签，而不是选项之间的界线。也是说，程序跳到 &lt;code&gt;switch&lt;/code&gt; 中特定代码行后，将依次执行之后的所有语句，除非有明确的其他指示。程序不会在执行到下一个 &lt;code&gt;case&lt;/code&gt; 处自动停止，&lt;strong&gt;要让程序执行 完一组特定语句后停止，必须使用&lt;code&gt;break&lt;/code&gt; 语句&lt;/strong&gt;。这将导致程序跳到 &lt;code&gt;switch&lt;/code&gt; 后面的语句处执行。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;93&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728234458366.png&#34; alt=&#34;image-20210728234458366&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;651-将枚举量用作标签&#34;&gt;6.5.1 将枚举量用作标签&lt;/h3&gt;
&lt;p&gt;通常，&lt;code&gt;cin&lt;/code&gt; 无法识别枚举类型（它不知道程序员是如 何定义它们的），因此该程序要求用户选择选项时输入一个整数。当 &lt;code&gt;switch&lt;/code&gt; 语句将 &lt;code&gt;int&lt;/code&gt; 值和枚举量标签进行比较时，将枚举量提升为 &lt;code&gt;int&lt;/code&gt;。另 外，在 &lt;code&gt;while&lt;/code&gt; 循环测试条件中，也会将枚举量提升为 &lt;code&gt;int&lt;/code&gt; 类型。&lt;/p&gt;
&lt;h3 id=&#34;652-switch-和-if-else&#34;&gt;6.5.2 &lt;code&gt;switch&lt;/code&gt; 和 &lt;code&gt;if else&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;语句和&lt;code&gt;if else&lt;/code&gt;语句都允许程序从选项中进行选择。相比之下， &lt;code&gt;if else&lt;/code&gt;更通用，例如，它可以处理取值范围。&lt;/p&gt;
&lt;p&gt;然而，&lt;code&gt;switch&lt;/code&gt;并不是为处理取值范围而设计的。&lt;code&gt;switch&lt;/code&gt;语句中的每 一个&lt;code&gt;case&lt;/code&gt;标签都必须是一个单独的值。另外，这个值必须是整数（包括 &lt;code&gt;char&lt;/code&gt;），因此 &lt;code&gt;switch&lt;/code&gt; 无法处理浮点测试。另外 &lt;code&gt;case&lt;/code&gt; 标签值还必须是常量。 如果选项涉及取值范围、浮点测试或两个变量的比较，则应使用 &lt;code&gt;if else&lt;/code&gt; 语句。&lt;/p&gt;
&lt;h2 id=&#34;66-break-和-continue-语句&#34;&gt;6.6 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt; 语句&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt;和 &lt;code&gt;continue&lt;/code&gt;语句都使程序能够跳过部分代码。可以在 &lt;code&gt;switch&lt;/code&gt;语句或任何循环中使用 &lt;code&gt;break&lt;/code&gt; 语句，使程序跳到 &lt;code&gt;switch&lt;/code&gt; 或循环后面的语句处执行。&lt;code&gt;continue&lt;/code&gt; 语句用于循环中，让程序跳过循环体中余下的代码，并开始新一轮循环。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;94&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728235538853.png&#34; alt=&#34;image-20210728235538853&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;67-读取数字的循环&#34;&gt;6.7 读取数字的循环&lt;/h2&gt;
&lt;p&gt;假设要编写一个将一系列数字读入到数组中的程序，并允许用户在 数组填满之前结束输入，一种方法是利用cin。看下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;int n;
cin &amp;gt;&amp;gt; n;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果用户输入一个单词，而不是一个数字，发生这种类型不匹配的情况时，将发生4种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; 的值保持不变；&lt;/li&gt;
&lt;li&gt;不匹配的输入将被留在输入队列中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cin&lt;/code&gt; 对象中的一个错误标记被设置；&lt;/li&gt;
&lt;li&gt;对 &lt;code&gt;cin&lt;/code&gt; 方法的调用将返回 &lt;code&gt;false&lt;/code&gt;（如果被转换为 &lt;code&gt;bool&lt;/code&gt; 类型）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;方法返回 &lt;code&gt;false&lt;/code&gt; 意味着可以用非数字输入来结束读取数字的循环&lt;/strong&gt;。当用户输入的不是数字时，该程序将不再读取输入。非数字输入设置错误标记意味着&lt;strong&gt;必须重置该标记，程序才能继续读取输 入&lt;/strong&gt;。&lt;code&gt;clear()&lt;/code&gt; 方法重置错误输入标记，同时也重置文件尾（&lt;code&gt;EOF&lt;/code&gt;条件，参见第5章）。输入错误和 &lt;code&gt;EOF&lt;/code&gt; 都将导致&lt;code&gt;cin&lt;/code&gt;返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;95&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210729001427328.png&#34; alt=&#34;image-20210729001427328&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;96&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210729001350955.png&#34; alt=&#34;image-20210729001350955&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果用户输入非数字输入，程序将拒绝，并要求用户继续输入数字。可以看到，可以使用 &lt;code&gt;cin&lt;/code&gt; 输入表达式的值来检测输入是不是数字。 程序发现用户输入了错误内容时，应采取3个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重置 &lt;code&gt;cin&lt;/code&gt; 以接受新的输入；&lt;/li&gt;
&lt;li&gt;删除错误输入；&lt;/li&gt;
&lt;li&gt;提示用户再输入。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，程序必须先重置cin，然后才能删除错误输入。如下程序清单 6.14演示了如何完成这些工作。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;

const int Max = 5;
int main() {
    using namespace std;
    // get data
    int golf[Max];
    cout &amp;lt;&amp;lt; &amp;quot;Please enter your golf scores.\n&amp;quot;;
    cout &amp;lt;&amp;lt; &amp;quot;You must enter &amp;quot; &amp;lt;&amp;lt; Max &amp;lt;&amp;lt; &amp;quot; rounds.\n&amp;quot;;
    int i;
    for (i = 0; i &amp;lt; Max; i++) {
        cout &amp;lt;&amp;lt; &amp;quot;round #&amp;quot; &amp;lt;&amp;lt; i+1 &amp;lt;&amp;lt; &amp;quot;: &amp;quot;;
        while (!(cin &amp;gt;&amp;gt; golf[i])) {
            cin.clear();     // reset input
            while (cin.get() != &#39;\n&#39;)
                continue;    // get rid of bad input
            cout &amp;lt;&amp;lt; &amp;quot;Please enter a number: &amp;quot;;
        }
    }
    
    // calculate average
    double total = 0.0;
    for (i = 0; i &amp;lt; Max; i++)
        total += golf[i];
        
    // report results
    cout &amp;lt;&amp;lt; total / Max &amp;lt;&amp;lt; &amp;quot; = average score &amp;quot;
         &amp;lt;&amp;lt; Max &amp;lt;&amp;lt; &amp;quot; rounds\n&amp;quot;;
    // cin.get();
    // cin.get();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;97&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210729165001482.png&#34; alt=&#34;image-20210729165001482&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;如果用户输入 88，则 &lt;code&gt;cin&lt;/code&gt; 表达式将为 &lt;code&gt;true&lt;/code&gt;，因此将一个值放到数组中；而表达式 &lt;code&gt;!(cin &amp;gt;&amp;gt; golf [i])&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;，因此结束内部循环。然而，如果用户输入 &lt;code&gt;must i?&lt;/code&gt;，则 &lt;code&gt;cin&lt;/code&gt; 表达式将为 &lt;code&gt;false&lt;/code&gt;，因此不会将任何值放到数组 中；而表达式 &lt;code&gt;!(cin &amp;gt;&amp;gt; golf [i])&lt;/code&gt; 将为 &lt;code&gt;true&lt;/code&gt;，因此进入内部的 &lt;code&gt;while&lt;/code&gt; 循环。该循环的第一条语句使用 &lt;code&gt;clear()&lt;/code&gt; 方法重置输入，如果省略这条语句，程序将拒绝继续读取输入。接下来，程序在 &lt;code&gt;while&lt;/code&gt; 循环中使用 &lt;code&gt;cin.get()&lt;/code&gt; 来读取 行尾之前的所有输入，从而删除这一行中的错误输入。另一种方法是读取到下一个空白字符，这样将每次删除一个单词，而不是一次删除整 行。最后，程序告诉用户，应输入一个数字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;68-简单文件输入输出&#34;&gt;6.8 简单文件输入/输出&lt;/h2&gt;
&lt;h3 id=&#34;681-文本io和文本文件&#34;&gt;6.8.1 文本I/O和文本文件&lt;/h3&gt;
&lt;h3 id=&#34;682-写入到文本文件中&#34;&gt;6.8.2 写入到文本文件中&lt;/h3&gt;
&lt;p&gt;文件输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须包含头文件 &lt;code&gt;fstream&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;头文件 &lt;code&gt;fstream&lt;/code&gt; 定义了一个用于处理输出的 &lt;code&gt;ofstream&lt;/code&gt; 类；&lt;/li&gt;
&lt;li&gt;需要声明一个或多个 &lt;code&gt;ofstream&lt;/code&gt; 变量（对象），并以自己喜欢的方式 对其进行命名，条件是遵守常用的命名规则；&lt;/li&gt;
&lt;li&gt;必须指明名称空间 &lt;code&gt;std&lt;/code&gt;。例如，为引用元素 &lt;code&gt;ofstream&lt;/code&gt;，必须使用编译指令&lt;code&gt;using&lt;/code&gt; 或前缀 &lt;code&gt;std::&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;需要将 &lt;code&gt;ofstream&lt;/code&gt; 对象与文件关联起来。为此，方法之一是使用 &lt;code&gt;open()&lt;/code&gt; 方法；&lt;/li&gt;
&lt;li&gt;使用完文件后，应使用方法 &lt;code&gt;close()&lt;/code&gt; 将其关闭；&lt;/li&gt;
&lt;li&gt;可结合使用 &lt;code&gt;ofstream&lt;/code&gt; 对象和运算符 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 来输出各种类型的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然头文件 &lt;code&gt;iostream&lt;/code&gt; 提供了一个预先定义好的名为 &lt;code&gt;cout&lt;/code&gt; 的 &lt;code&gt;ostream&lt;/code&gt; 对象，但您必须声明自己的 &lt;code&gt;ofstream&lt;/code&gt; 对象，为其命名，并将其同文件关联起来。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;98&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210729232741786.png&#34; alt=&#34;image-20210729232741786&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注意，方法&lt;code&gt;open()&lt;/code&gt; 只接受C-风格字符串作为参数，这可以是一个 字面字符串，也可以是存储在数组中的字符串。&lt;/p&gt;
&lt;p&gt;重要的是，声明一个&lt;code&gt;ofstream&lt;/code&gt;对象并将其同文件关联起来后，便可以像使用cout那样使用它。所有可用于cout的操作和方法（如&amp;lt;&amp;lt;、endl 和setf( )）都可用于ofstream对象（如前述示例中的outFile和fout）。&lt;/p&gt;
&lt;p&gt;总之，使用文件输出的主要步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包含头文件 &lt;code&gt;fstream&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;创建一个 &lt;code&gt;ofstream&lt;/code&gt; 对象；&lt;/li&gt;
&lt;li&gt;将该 &lt;code&gt;ofstream&lt;/code&gt; 对象同一个文件关联起来；&lt;/li&gt;
&lt;li&gt;就像使用 &lt;code&gt;cout&lt;/code&gt; 那样使用该 &lt;code&gt;ofstream&lt;/code&gt; 对象;&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;close()&lt;/code&gt; 成员函数，关闭文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;默认情况下，&lt;code&gt;open()&lt;/code&gt; 的将首先截断该文件，即将其长度截短到零——丢弃原有的内容，然后将新的输出加入到该文件中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;683-读取文本文件&#34;&gt;6.8.3 读取文本文件&lt;/h3&gt;
&lt;p&gt;接下来介绍文本文件输入，它是基于控制台输入的。控制台输入涉 及多个方面，下面首先总结这些方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须包含头文件 &lt;code&gt;fstream&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;头文件 &lt;code&gt;fstream&lt;/code&gt; 定义了一个用于处理输入的 &lt;code&gt;ifstream&lt;/code&gt; 类；&lt;/li&gt;
&lt;li&gt;需要声明一个或多个 &lt;code&gt;ifstream&lt;/code&gt; 变量（对象），并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则；&lt;/li&gt;
&lt;li&gt;必须指明名称空间 &lt;code&gt;std&lt;/code&gt;；例如，为引用元素 &lt;code&gt;ifstream&lt;/code&gt;，必须使用编译指令&lt;code&gt;using&lt;/code&gt;或前缀&lt;code&gt;std::&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;需要将 &lt;code&gt;ifstream&lt;/code&gt; 对象与文件关联起来。为此，方法之一是使用 &lt;code&gt;open()&lt;/code&gt; 方法；&lt;/li&gt;
&lt;li&gt;使用完文件后，应使用 &lt;code&gt;close()&lt;/code&gt; 方法将其关闭；&lt;/li&gt;
&lt;li&gt;可结合使用 &lt;code&gt;ifstream&lt;/code&gt; 对象和运算符 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 来读取各种类型的数据；&lt;/li&gt;
&lt;li&gt;可以使用 &lt;code&gt;ifstream&lt;/code&gt; 对象和 &lt;code&gt;get()&lt;/code&gt; 方法来读取一个字符，使用 &lt;code&gt;ifstream&lt;/code&gt; 对象和 &lt;code&gt;getline()&lt;/code&gt; 来读取一行字符；&lt;/li&gt;
&lt;li&gt;可以结合使用 &lt;code&gt;ifstream&lt;/code&gt; 和 &lt;code&gt;eof()&lt;/code&gt;、&lt;code&gt;fail()&lt;/code&gt; 等方法来判断输入是否成功；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ifstream&lt;/code&gt; 对象本身被用作测试条件时，如果最后一个读取操作成 功，它将被转换为布尔值 &lt;code&gt;true&lt;/code&gt;，否则被转换为 &lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果试图打开一个不存在的文件用于输入，情况将如何呢？这种错误将导致后面使用&lt;code&gt;ifstream&lt;/code&gt; 对象进行输入时失败。检查文件是否被成功打开的首选方法是使用&lt;code&gt;is_open()&lt;/code&gt;，为此，可以使用类似于下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;inFile.open(&amp;quot;b.txt&amp;quot;);
if (!inFile.is_open()) {
    exit(EXIT_FEAILURE);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果文件被成功地打开，方法 &lt;code&gt;is_open()&lt;/code&gt; 将返回 &lt;code&gt;true&lt;/code&gt;；因此如果文件没有被打开，表达式 &lt;code&gt;!inFile.is_open()&lt;/code&gt; 将为 &lt;code&gt;true&lt;/code&gt;。函数 &lt;code&gt;exit()&lt;/code&gt; 的原型是在头文件 &lt;code&gt;cstdlib&lt;/code&gt; 中定义的，在该头文件中，还定义了一个用于同操作系统通信的参数值 &lt;code&gt;EXIT_FAILURE&lt;/code&gt;。函数 &lt;code&gt;exit()&lt;/code&gt; 终止程序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;方法 &lt;code&gt;is_open()&lt;/code&gt; 是C++中相对较新的内容。如果读者的编译器不支持它，可使用较老的方法 &lt;code&gt;good()&lt;/code&gt; 来代替。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210730001839791.png&#34; alt=&#34;image-20210730001839791&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210730001922821.png&#34; alt=&#34;image-20210730001922821&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;假设该文件名为scores.txt，包含的内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;18 19 18.5 13.5
16 19.5 18.5
17.5
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;检查文件是否被成功打开至关重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;读取文件时，有 几点需要检查。首先，程序读取文件时不应超过 EOF。如果最后一次读取数据时遇到 &lt;code&gt;EOF&lt;/code&gt;，方法 &lt;code&gt;eof()&lt;/code&gt; 将返回 &lt;code&gt;true&lt;/code&gt;。其次，程序可能遇到类型不 匹配的情况。例如，程序清单6.16期望文件中只包含数字。如果最后一次读取操作中发生了类型不匹配的情况，方法 &lt;code&gt;fail()&lt;/code&gt; 将返回 &lt;code&gt;true&lt;/code&gt;（如果遇到了 &lt;code&gt;EOF&lt;/code&gt;，该方法也将返回 &lt;code&gt;true&lt;/code&gt;）。最后，可能出现意外的问题，如文 件受损或硬件故障。如果最后一次读取文件时发生了这样的问题，方法 &lt;code&gt;bad()&lt;/code&gt; 将返回 &lt;code&gt;true&lt;/code&gt;。不要分别检查这些情况，一种更简单的方法是使用 &lt;code&gt;good()&lt;/code&gt; 方法，该方法在没有发生任何错误时返回 &lt;code&gt;true&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;while (inFile.good()) {
    ......
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法 &lt;code&gt;good()&lt;/code&gt; 指出最后一次读取输入的操作是否成功，这一点至关重要。这意味着应该在执行读取输入的操作后，立刻应用这种测试。为此，一种标准方法是，在循环之前（首次执行循环测试前）放置一条输 入语句，并在循环的末尾（下次执行循环测试之前）放置另一条输入语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// standard file-reading loop design
inFile &amp;gt;&amp;gt; value;         // get first value
while (inFile.good()) {  // while uput good and not at EOF
    //loop body goes here
    inFile &amp;gt;&amp;gt; value;     // get next value
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;鉴于以下事实，可以对上述代码进行精简：表达式 &lt;code&gt;inFile &amp;gt;&amp;gt; value&lt;/code&gt; 的结果为&lt;code&gt;inFile&lt;/code&gt;，而在需要一个 &lt;code&gt;bool&lt;/code&gt; 值的情况下，&lt;code&gt;inFile&lt;/code&gt; 的结果为 &lt;code&gt;inFile.good()&lt;/code&gt;，即 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此，可以将两条输入语句用一条用作循环测试的输入语句代替。 也就是说，可以将上述循环结构替换为如下循环结构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// omit pre-loop input
while (inFile &amp;gt;&amp;gt; value) {  // read and test for success
    // loop body goes here
    // omit end-of-loop input
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;99&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210730002759125.png&#34; alt=&#34;image-20210730002759125&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这些代码紧跟在循环的后面，用于判断循环为何终止。由于 &lt;code&gt;eof()&lt;/code&gt; 只能判断是否到达 &lt;code&gt;EOF&lt;/code&gt;，而 &lt;code&gt;fail()&lt;/code&gt; 可用于检查 &lt;code&gt;EOF&lt;/code&gt; 和类型不匹配，因此上述 代码首先判断是否到达 &lt;code&gt;EOF&lt;/code&gt;。这样，如果执行到了 &lt;code&gt;else if&lt;/code&gt; 测试，便可排除 &lt;code&gt;EOF&lt;/code&gt;，因此，如果 &lt;code&gt;fail()&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt;，便可断定导致循环终止的原因是类型不匹配。&lt;/p&gt;
&lt;p&gt;这种设计仍然遵循了在测试之前进行读取的规则，因为要计算表达式 &lt;code&gt;inFile &amp;gt;&amp;gt; value&lt;/code&gt; 的值，程序必须首先试图将一个数字读取到 &lt;code&gt;value&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;以上仅是对文件 I/O 的初步介绍。&lt;/p&gt;
&lt;h2 id=&#34;69-总结&#34;&gt;6.9 总结&lt;/h2&gt;
&lt;p&gt;C++提供了 &lt;code&gt;if&lt;/code&gt; 语句、&lt;code&gt;if-else&lt;/code&gt; 语句和 &lt;code&gt;switch&lt;/code&gt; 语句来管理选项。&lt;br&gt;
C++还提供了帮助决策的运算符。通过使用逻辑运算符（&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;、&lt;code&gt;||&lt;/code&gt; 和 &lt;code&gt;!&lt;/code&gt;），可以组合或修改关系表达式，创建更细致的测试。条件运算符 &lt;code&gt;(?:)&lt;/code&gt; 提供了一种选择两个值之一 的简洁方式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cctype&lt;/code&gt; 字符函数库提供了一组方便的、功能强大的工具，可用于分析字符输入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728232856482.png&#34; alt=&#34;image-20210728232856482&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://static.fungenomics.com/images/2021/07/image-20210728232930054.png&#34; alt=&#34;image-20210728232930054&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;文件 I/O 与控制台 I/O 极其相似。声明 ifstream 和 ofstream 对象，并将它们同文件关联起来后，便可以像使用 cin 和 cout 那样使用这些对象。&lt;/p&gt;
&lt;h1 id=&#34;第七章-函数c的编程模块&#34;&gt;第七章 函数——C++的编程模块&lt;/h1&gt;
&lt;p&gt;本周内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数基本知识；&lt;/li&gt;
&lt;li&gt;函数原型；&lt;/li&gt;
&lt;li&gt;按值传递函数参数；&lt;/li&gt;
&lt;li&gt;设计处理数据的函数；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;const&lt;/code&gt; 指针参数；&lt;/li&gt;
&lt;li&gt;设计处理文本字符串的函数；&lt;/li&gt;
&lt;li&gt;设计处理结构的函数；&lt;/li&gt;
&lt;li&gt;设计处理 &lt;code&gt;string&lt;/code&gt; 对象的函数；&lt;/li&gt;
&lt;li&gt;调用自身的函数（递归）；&lt;/li&gt;
&lt;li&gt;指向函数的指数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;71-函数基本知识&#34;&gt;7.1 函数基本知识&lt;/h2&gt;
&lt;p&gt;自定义函数三要素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数定义；&lt;/li&gt;
&lt;li&gt;函数原型；&lt;/li&gt;
&lt;li&gt;调用函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;711-定义函数&#34;&gt;7.1.1 定义函数&lt;/h3&gt;
&lt;p&gt;函数有两类：没有返回值的函数和有返回值的函数。&lt;/p&gt;
&lt;p&gt;函数定义通用格式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;void functionName(parameterList) {
    statement(s);
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;C++ 对于返回值的类型有一定的限制：&lt;strong&gt;不能是数组&lt;/strong&gt;，但可以是其他任何类型——整数、浮点数、指针，甚至可以是结构体和对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++ 函数返回值的原理是什么？&lt;/strong&gt;&lt;br&gt;
首先，函数将返回值复制到指定的CPU寄存器或内存单元中将值返回；随后，调用程序将查看该内存单元。&lt;strong&gt;返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致&lt;/strong&gt;。函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;100&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804133448677.png&#34; alt=&#34;image-20210804133448677&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;712-函数原型和函数调用&#34;&gt;7.1.2 函数原型和函数调用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;为什么需要函数原型&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;double volume = cube(side);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先，原型告诉编译器，&lt;code&gt;cube()&lt;/code&gt; 有一个 double 参数。如果程序没有 提供这样的参数，原型将让编译器能够捕获这种错误。其次，&lt;code&gt;cube()&lt;/code&gt; 函数完成计算后，将把返回值放置在指定的位置——可能是 CPU 寄存器， 也可能是内存中。然后调用函数（这里为 &lt;code&gt;main()&lt;/code&gt;）将从这个位置取得返回值。由于原型指出了 &lt;code&gt;cube()&lt;/code&gt; 的类型为 double，因此编译器知道应检索多少个字节以及如何解释它们。如果没有这些信息，编译器将只能进行猜测，而编译器是不会这样做的。&lt;/p&gt;
&lt;p&gt;为何编译器需要原型，它就不能在文件中进一步查找，以了解函数是如何定义的吗？这种方法的一个问题是效率不高。编译器在搜索文件的剩余部分时必须停止对 &lt;code&gt;main()&lt;/code&gt; 的编译。一个更严重的问题是，函数甚至可能并不在文件中。C++ 允许将一个程序放 在多个文件中，单独编译这些文件，然后再将它们组合起来。在这种情况下，编译器在编译 &lt;code&gt;main()&lt;/code&gt; 时，可能无权访问函数代码。如果函数位于库中，情况也将如此。避免使用函数原型的唯一方法是，在首次使用函数之前定义它，但这并不总是可行的。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;原型的语法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数原型是一条语句，因此必须以分号结束。获得原型最简单的方 法是，复制函数定义中的函数头，并添加分号。&lt;br&gt;
函数原型不要求提供变量名，有类型列表就足够了。&lt;strong&gt;通常，在原型的参数列表中，可以包括变量名，也可以不包括。原 型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;原型的功能&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它们可以极大地降低程序出错的几率。具体来说，原型 确保以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译器正确处理函数返回值；&lt;/li&gt;
&lt;li&gt;编译器检查使用的参数数目是否正确；&lt;/li&gt;
&lt;li&gt;编译器检查使用的参数类型是否正确，如果不正确，则转换为正确的类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;101&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804144730761.png&#34; alt=&#34;image-20210804144730761&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;仅当有意义时，原型化才会导致类型转换。例如，原型不会将整数转换为结构或指针。&lt;/p&gt;
&lt;p&gt;在编译阶段进行的原型化被称为静态类型检查（static type checking）。&lt;/p&gt;
&lt;h2 id=&#34;72-函数参数和按值传递&#34;&gt;7.2 函数参数和按值传递&lt;/h2&gt;
&lt;p&gt;C++通常按值传递参数，这意味着将 数值参数传递给函数，而后者将其赋给一个新的变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;double volume = cube(side);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;102&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804145401521.png&#34; alt=&#34;image-20210804145401521&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;side 是一个变量，被调用时，该函数将创建一个新的名为x的double变量，并将其初 始化为5。这样，cube( )执行的操作将不会影响main( )中的数据，因为 cube( )使用的是side的副本，而不是原来的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在函数中声明的变量（包括参数）是该函数私有的。在函数被调用 时，计算机将为这些变量分配内存；在函数结束时，计算机将释放这些 变量使用的内存&lt;/strong&gt;。这样的变量被称为局部变量，因为它们被限制在函数中。前面提到过，这样做有助于确保数据的完整性。这还意 味着，如果在main( )中声明了一个名为x的变量，同时在另一个函数中 也声明了一个名为x的变量，则它们将是两个完全不同的、毫无关系的变量。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;103&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804145526933.png&#34; alt=&#34;image-20210804145526933&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;721-多个参数&#34;&gt;7.2.1 多个参数&lt;/h3&gt;
&lt;p&gt;函数可以有多个参数。在调用函数时，只需使用逗号将这些参数分开即可。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;104&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804150422862.png&#34; alt=&#34;image-20210804150422862&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;它使用&lt;code&gt;cin&amp;gt;&amp;gt;ch&lt;/code&gt;，而不是&lt;code&gt;cin.get(ch)&lt;/code&gt;或&lt;code&gt;ch = cin.get()&lt;/code&gt;来读取一个字符。这样做是有原因的。前面讲过，这两个&lt;code&gt;cin.get()&lt;/code&gt; 函数读取所有的输入字符，包括空格和换行符，而 &lt;code&gt;cin&amp;gt;&amp;gt;&lt;/code&gt; 跳过空格和换行符。当用户对程序提示作出响应时，必须在每行的最后按 &lt;code&gt;Enter&lt;/code&gt; 键，以生成换行符。&lt;code&gt;cin&amp;gt;&amp;gt;ch&lt;/code&gt; 方法可以轻松地&lt;strong&gt;跳过这些换行符&lt;/strong&gt;，但当输入的下一个字符为数字时，&lt;code&gt;cin.get()&lt;/code&gt; 将读取后面的换行符，虽然可以通过编程来避开这种麻烦，但比较简便的方法是像该程序那样使用 &lt;code&gt;cin&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;73-函数和数&#34;&gt;7.3 函数和数&lt;/h2&gt;
&lt;p&gt;需要将数组名作为参数传递给它，为使函数通用，而不限于特定长度的数组，还需要传递数组长度。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;int sum_arr(int arr[], int n);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方括号指出 &lt;code&gt;arr&lt;/code&gt; 是一个数组，而方括号为空则表明，可以将任何长度的数组传递给该函数。但实际情况并非如此：&lt;code&gt;arr&lt;/code&gt;实际上并不是数组，&lt;strong&gt;而是一个指针&lt;/strong&gt;，好消息是，在编写函数的其余部分时，可以将 &lt;code&gt;arr&lt;/code&gt; 看作是数组。&lt;/p&gt;
&lt;h3 id=&#34;731-函数如何使用指针来处理数组&#34;&gt;7.3.1 函数如何使用指针来处理数组&lt;/h3&gt;
&lt;p&gt;在大多数情况下，C++和C语言一样，也将数组名视为指针。C++将数组名解释为其第一个元素的地址：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;cookies == &amp;amp;cookies[0];   // array name is the address of first element
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先，数组声明使用数组名来标记存储位置； 其次，对数组名使用sizeof将得到整个数组的长度（以字节为单位）； 第三，正如第4章指出的，将地址运算符&amp;amp;用于数组名时，将返回整个数组的地址。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;105&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804152348446.png&#34; alt=&#34;image-20210804152348446&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;当且仅当在函数头中或者函数原型中，&lt;code&gt;int *arr&lt;/code&gt; 和 &lt;code&gt;int arr[]&lt;/code&gt; 的含义是相同的。它们都指 arr 是一个 int 指针。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于数组，以下两个语句是恒等的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;arr[i] == *(arr+i);  // values in two notations
&amp;amp;arr[i] == arr + i;  // addresses in two notations
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;732-将数组作为参数意味着什么&#34;&gt;7.3.2 将数组作为参数意味着什么&lt;/h3&gt;
&lt;p&gt;传递常规变量时，函数将使用该变量的拷贝；&lt;strong&gt;但传递数组时，函数将使用原来的数组（传地址）&lt;/strong&gt;。实际上，这种区别并不违反C++按值传递的方法，&lt;code&gt;sum_arr()&lt;/code&gt; 函数仍传递了一个值，这个值被赋给 一个新变量，但这个值是一个地址，而不是数组的内容。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;106&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804154353723.png&#34; alt=&#34;image-20210804154353723&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;将数组地址作为参数可以节省复制整个数组所需的时间和内存&lt;/strong&gt;。如果数组很大，则使用拷贝的系统开销将非常大；程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。&lt;strong&gt;但另一方面，使用原始数据增加了破坏数据的风险&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sum_arr(cookies+4, 4)&lt;/code&gt; 和 &lt;code&gt;sum_arr(&amp;amp;cookies[4], 4)&lt;/code&gt; 是等效的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;107&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804155245012.png&#34; alt=&#34;image-20210804155245012&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;733-更多数组函数示&#34;&gt;7.3.3 更多数组函数示&lt;/h3&gt;
&lt;p&gt;1．填充数组&lt;/p&gt;
&lt;p&gt;2．显示数组及用const保护数组&lt;/p&gt;
&lt;p&gt;创建显示数组内容的函数很简单。只需将数组名和填充的元素数目传递给函数，然后该函数使用循环来显示每个元素。然而，还有另一个问题——确保显示函数不修改原始数组。除非函数的目的就是修改传递给它的数据，否则应避免发生这种情况。使用普通参数时，这种保护将自动实现，这是由于C++按值传递数据，函数使用数据的副本。然而，接受数组名的函数将使用原始数据。为防止函数无意中修改数组的内容，可在声明形参时 使用关键字&lt;code&gt;const&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;void show_array(const double arr[], int n);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;show_array()&lt;/code&gt; 将数组视为只读数据。&lt;/p&gt;
&lt;p&gt;3．修改数组&lt;/p&gt;
&lt;p&gt;在这个例子中，对数组进行的第三项操作是将每个元素与同一个重新评估因子相乘。需要给函数传递3个参数：因子、数组和元素数目。 该&lt;strong&gt;函数不需要返回值&lt;/strong&gt;，因此其代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;void revalue(double r, double arr[], int n) {
    for (int i=0; i &amp;lt; n; ++i) {
        arr[i] *= r;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于这个函数将修改数组的值，因此在声明 &lt;code&gt;arr&lt;/code&gt; 时，不能使用 &lt;code&gt;const&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;4．将上述代码组合起来&lt;/p&gt;
&lt;p&gt;前面已经讨论了与该示例相关的重要编程细节，因此这里回顾一下 整个过程。&lt;strong&gt;我们首先考虑的是通过数据类型和设计适当的函数来处理数据，然后将这些函数组合成一个程序。有时也称为自下而上的程序设计 （bottom-up programming），因为设计过程从组件到整体进行。这种方 法非常适合于OOP——它首先强调的是数据表示和操纵&lt;/strong&gt;。而传统的过程性编程倾向于从上而下的程序设计（top-down programming），首先指定模块化设计方案，然后再研究细节。这两种方法都很有用，最终的产品都是模块化程序。&lt;/p&gt;
&lt;p&gt;6．数组处理函数的常用编写方式&lt;/p&gt;
&lt;p&gt;假设要编写一个处理double数组的函数。如果该函数要修改数组， 其原型可能类似于下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;void f_modfiy(double arr[], int n);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果函数不修改数组，其原型可能类似于下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;void _f_no_change(const double arr[], int n);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;734-使用数组区间的函数&#34;&gt;7.3.4 使用数组区间的函数&lt;/h3&gt;
&lt;p&gt;对于处理数组的C++函数，必须将数组中的数据种类、数组的起始位置和数组中元素数量提交给它；传统的C/C++方法是，将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数（指针指出数组的位置和数据类型），这样便给函数提供找到所有数据所需的信息。&lt;/p&gt;
&lt;p&gt;还有另一种给函数提供所需信息的方法，即指定元素区间 （range），这可以通过传递两个指针来完成：&lt;strong&gt;一个指针标识数组的开头，另一个指针标识数组的尾部&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;108&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804170600111.png&#34; alt=&#34;image-20210804170600111&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;它将 &lt;code&gt;pt&lt;/code&gt; 设置为指向要处理的第一个元素（&lt;code&gt;begin&lt;/code&gt;指向的元素）的指针，并将&lt;code&gt;*pt&lt;/code&gt;（元素的值）加入到 &lt;code&gt;total&lt;/code&gt; 中。然后，循环通过递增操作来更新 &lt;code&gt;pt&lt;/code&gt;，使之指向下一个元素。只要 &lt;code&gt;pt&lt;/code&gt; 不等于 &lt;code&gt;end&lt;/code&gt;，这一过程就将继续下去。当 &lt;code&gt;pt&lt;/code&gt; 等于 &lt;code&gt;end&lt;/code&gt; 时，它将指向区间中最后一个元素后面的一个位置，此时循环将结束。&lt;/p&gt;
&lt;h3 id=&#34;735-指针和-const&#34;&gt;7.3.5 指针和 &lt;code&gt;const&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;将 &lt;code&gt;const&lt;/code&gt; 用于指针有一些很微妙的地方，可以用两种不同的方式将 &lt;code&gt;const&lt;/code&gt; 关键字用于指针。&lt;strong&gt;第一种方法是让指针指向一个常量对象&lt;/strong&gt;，防止使用该指针来修改所指向的值，&lt;strong&gt;第二种方法是将指针本身声明为常量&lt;/strong&gt;，这样可以防止改变指针指向的位置。&lt;/p&gt;
&lt;p&gt;首先看一个指向常量的指针：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;109&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804171314723.png&#34; alt=&#34;image-20210804171314723&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这里要求 &lt;code&gt;pt&lt;/code&gt; 指向的是一个 &lt;code&gt;const int&lt;/code&gt;，所以，赋值之后我们是不能用 &lt;code&gt;*pt&lt;/code&gt; 来修改 age 的值的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;110&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804171334907.png&#34; alt=&#34;image-20210804171334907&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;现在来看一个微妙的问题。pt的声明并不限定着它指向的值就必须得是一个常量，只是对pt来说，这个值是常量。例如，pt指向age，但age不是const。我们是可以直接通过 age 变量来修改 age 的值的，但不能使用 pt 指针来修改它。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;111&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804171429933.png&#34; alt=&#34;image-20210804171429933&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;我觉得这类指针可以称为：&lt;strong&gt;只读指针&lt;/strong&gt;。这个指针可以移动，但是它只能读出它所指向地址的内容，但是无法通过这个指针修改其中的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;112&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804171526205.png&#34; alt=&#34;image-20210804171526205&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;C++禁止第二种情况的原因很简单——如果将 &lt;code&gt;g_moon&lt;/code&gt; 的地 址赋给 &lt;code&gt;pm&lt;/code&gt;，那么就可以用 &lt;code&gt;pm&lt;/code&gt; 来修改 &lt;code&gt;g_moon&lt;/code&gt; 的值，这使得 &lt;code&gt;g_moon&lt;/code&gt; 的 &lt;code&gt;const&lt;/code&gt; 状态很荒谬，因此, &lt;strong&gt;C++禁止将 const 的地址赋给非 const 指针&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设有一个由 &lt;code&gt;const&lt;/code&gt; 数据组成的数组则禁止将常量数组的地址赋给非常量指针将意味着不能将数组名作为参数传递给使用非常量形参的函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要条件允许，则应将指针形参声明为指向 &lt;code&gt;const&lt;/code&gt; 的指针。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;尽可能使用 const&lt;/strong&gt;:&lt;br&gt;
将指针参数声明为指向常量数据的指针有两个优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免由于无意间修改数据而导致的编程错误；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;const&lt;/code&gt; 使得函数能够处理 &lt;code&gt;const&lt;/code&gt; 和非 &lt;code&gt;const&lt;/code&gt; 实参，否则将只能接受非 &lt;code&gt;const&lt;/code&gt; 数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt; 只能防止修改 &lt;code&gt;pt&lt;/code&gt; 指向的值（这里为39），而不能防止修改 &lt;code&gt;pt&lt;/code&gt; 的值。也就是说，可以将一个新地址赋给 &lt;code&gt;pt&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第二种使用 &lt;code&gt;const&lt;/code&gt; 的方式使得无法修改指针的值：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;113&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804172355209.png&#34; alt=&#34;image-20210804172355209&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;这样的指针，我想将其称为：&lt;strong&gt;静止指针&lt;/strong&gt;。指针本身定死在一个地址上了，但是地址里的内容是可以通过这个指针随便修改的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;114&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804172525799.png&#34; alt=&#34;image-20210804172525799&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通常，将指针作为函数参数来传递时，可以使用指向&lt;code&gt;const&lt;/code&gt;的指针来保护数据。&lt;/p&gt;
&lt;p&gt;在该声明中使用 &lt;code&gt;const&lt;/code&gt; 意味着 &lt;code&gt;show_array()&lt;/code&gt; 不能修改传递给它的数组中的值。只要只有一层间接关系，就可以使用这种技术。例如，这里的数组元素是基本类型，但如果它们是指针或指向指针的指针，则不能使用 &lt;code&gt;const&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;74-函数和二维数组&#34;&gt;7.4 函数和二维数组&lt;/h2&gt;
&lt;p&gt;数组名被视为其地 址，因此，相应的形参是一个指针，就像一维数组一样。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Data&lt;/code&gt; 是一个数组名，该数组有3个元素。第一个元素本身是一个数组，由4个 &lt;code&gt;int&lt;/code&gt; 值组成。因此 &lt;code&gt;data&lt;/code&gt; 的类型是指向由4个 &lt;code&gt;int&lt;/code&gt; 组成的数组的指针，因此正确的原型如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;int sum(int (*ar2)[4], int size);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有另外一种格式，这种格式与上述原型的含义完全相同，但可读性更强：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;int sum(int ar2[][4], int size);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于二维数据，必须对指针 &lt;code&gt;ar2&lt;/code&gt; 执行两次解除引用，才能得到数据。最简单的方法是使用方括号两次：&lt;code&gt;ar2[r][c]&lt;/code&gt;。然而，如果不考虑难看的话，也可以使用运算符&lt;code&gt;*&lt;/code&gt;两次：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;ar2[r][c] == *(*(ar2+r)+c);   // 等效
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;75-函数和c-风格字符串&#34;&gt;7.5 函数和C-风格字符串&lt;/h2&gt;
&lt;p&gt;C-风格字符串由一系列字符组成，以空值字符（&lt;code&gt;\0&lt;/code&gt;）结尾。&lt;/p&gt;
&lt;h3 id=&#34;751-将c-风格字符串作为参数的函数&#34;&gt;7.5.1 将C-风格字符串作为参数的函数&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;115&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804204604444.png&#34; alt=&#34;image-20210804204604444&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;假设要将字符串作为参数传递给函数，则表示字符串的方式有三 种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;char&lt;/code&gt; 数组；&lt;/li&gt;
&lt;li&gt;用引号括起的字符串常量（也称字符串字面值）；&lt;/li&gt;
&lt;li&gt;被设置为字符串的地址的&lt;code&gt;char&lt;/code&gt;指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但上述3种选择的类型都是&lt;code&gt;char&lt;/code&gt;指针（准确地说是&lt;code&gt;char*&lt;/code&gt;），因此可 以将其作为字符串处理函数的参数。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;116&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210804214230755.png&#34; alt=&#34;image-20210804214230755&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以说是将字符串作为参数来传递，&lt;strong&gt;但实际传递的是字符串第一个字符的地址&lt;/strong&gt;。这意味着字符串函数原型应将其表示字符串的形参声明为 &lt;code&gt;char *&lt;/code&gt; 类型。&lt;/p&gt;
&lt;p&gt;C-风格字符串与常规 &lt;code&gt;char&lt;/code&gt; 数组之间的一个重要区别是，字符串有内置的结束字符。这意味着不必将字符串长度作为参数传递给函数，而函数可以使用循环依次检查字符串中的每个字符，直到遇到结尾的空值字符为止。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不以空值字符结尾的char数组只是数组，而不是字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;752-返回c-风格字符串的函数&#34;&gt;7.5.2 返回C-风格字符串的函数&lt;/h3&gt;
&lt;p&gt;函数无法返回一 个字符串，但可以返回字符串的地址，这样做的效率更高。这种设计（让函数返回一个指针，该指针指向 &lt;code&gt;new&lt;/code&gt; 分配的内存）的缺点是，程序员必须记住使用 &lt;code&gt;delete&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;76-函数和结构体&#34;&gt;7.6 函数和结构体&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;结构体变量的行为更接近于基本的单值变量&lt;/strong&gt;。也就是说，与数组不同，结构体将其数据组合成单个实体或数据对象，该实体被视为一个整体。前面讲过，可以将一个结构体赋给另外一个结构体。同样，也&lt;strong&gt;可以按值传递结构体，就像普通变量那样&lt;/strong&gt;。在这种情况下，函数将使用原始结构体的副本。另外，函数也可以返回结构体。&lt;strong&gt;与数组名就是数组第一个元素的地址不同的是，结构体名只是结构体的名称，要获得结构的地址，必须使用地址运算符 &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用结构编程时，最直接的方式是像处理基本类型那样来处理结构体；也就是说，将结构体作为参数传递，并在需要时将结构体用作返回值使用。&lt;/p&gt;
&lt;h3 id=&#34;761-传递和返回结构体&#34;&gt;7.6.1 传递和返回结构体&lt;/h3&gt;
&lt;p&gt;当结构体比较小时，按值传递结构体最合理。&lt;/p&gt;
&lt;h3 id=&#34;762-另一个处理结构的函数示例&#34;&gt;7.6.2 另一个处理结构的函数示例&lt;/h3&gt;
&lt;h3 id=&#34;763-传递结构体的地址&#34;&gt;7.6.3 传递结构体的地址&lt;/h3&gt;
&lt;p&gt;假设要传递结构的地址而不是整个结构以节省时间和空间，则需要 重新编写前面的函数，使用指向结构的指针。首先来看一看如何重新编写 &lt;code&gt;show_polar()&lt;/code&gt; 函数。需要修改三个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用函数时，将结构的地址（&lt;code&gt;&amp;amp;pplace&lt;/code&gt;）而不是结构本身（&lt;code&gt;pplace&lt;/code&gt;） 传递给它；&lt;/li&gt;
&lt;li&gt;将形参声明为指向 &lt;code&gt;polar&lt;/code&gt; 的指针，即&lt;code&gt;polar *&lt;/code&gt;类型。由于函数不应该修改结构，因此使用了 &lt;code&gt;const&lt;/code&gt; 修饰符；&lt;/li&gt;
&lt;li&gt;由于形参是指针而不是结构，因此应间接成员运算符（&lt;code&gt;-&amp;gt;&lt;/code&gt;），而不是成员运算符（句点）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;77-函数和-string-对象&#34;&gt;7.7 函数和 &lt;code&gt;string&lt;/code&gt; 对象&lt;/h2&gt;
&lt;p&gt;可以将对象作为完整的实体进行传递，如果需要多个字符串，可以声明一个&lt;code&gt;string&lt;/code&gt; 对象数组，而不是二维 &lt;code&gt;char&lt;/code&gt; 数组。&lt;/p&gt;
&lt;h2 id=&#34;78-函数与-array-对象&#34;&gt;7.8 函数与 &lt;code&gt;array&lt;/code&gt; 对象&lt;/h2&gt;
&lt;h2 id=&#34;79-递归&#34;&gt;7.9 递归&lt;/h2&gt;
&lt;p&gt;C++函数有一种有趣的特点——可 以调用自己，但不允许main()调用自己，这种功能称为递归。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我不喜欢递归，太耗资源，可读性还差。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;791-包含一个递归调用的递归&#34;&gt;7.9.1 包含一个递归调用的递归&lt;/h3&gt;
&lt;h3 id=&#34;792-包含多个递归调用的递归&#34;&gt;7.9.2 包含多个递归调用的递归&lt;/h3&gt;
&lt;h2 id=&#34;710-函数指针&#34;&gt;7.10 函数指针&lt;/h2&gt;
&lt;p&gt;与数据项相似，函数也有地址。函数的地址是存储其机器语言代码 的内存的开始地址。对程序而言很有用，可以编写以另一个函数的地址作为参数的函数。&lt;/p&gt;
&lt;p&gt;这样第一个函数就可以找到第二个函数，并运行它。与直接调用另一个函数相比，这种方法很笨拙，但它允许在不同的情况下传递不同函数的地址，这意味着可以在不同的时间使用不同的函数。&lt;/p&gt;
&lt;h3 id=&#34;7101-函数指针的基础知识&#34;&gt;7.10.1 函数指针的基础知识&lt;/h3&gt;
&lt;p&gt;1．获取函数的地址&lt;br&gt;
获取函数的地址很简单：只要&lt;strong&gt;使用函数名（后面不跟参数）即可&lt;/strong&gt;。要将函数作为参数进行传递，必须传递函数名，要区分传递的是函数的地址还是函数的返回值。&lt;/p&gt;
&lt;p&gt;2．声明函数指针&lt;/p&gt;
&lt;p&gt;声明指向函数的指针时，必须指定指针指向的函数类型。意味着声明应指定函数的返回类型以及函数的特征标（参数列表）。也就是说，声明应像函数原型那样指出有关函数的信息：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;117&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210805084458826.png&#34; alt=&#34;image-20210805084458826&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;3．使用指针来调用函数&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;118&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210805084920592.png&#34; alt=&#34;image-20210805084920592&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;为何pf和&lt;code&gt;(*pf&lt;/code&gt;等价呢？一种学派认为，由于pf是函数指针，而 &lt;code&gt;*pf&lt;/code&gt; 是函数，因此应将&lt;code&gt;(*pf)()&lt;/code&gt;用作函数调用。另一种学派认为，由于函数名是指向该函数的指 针，指向函数的指针的行为应与函数名相似，因此应将pf( )用作函数调用使用。C++进行了折 衷——这2种方式都是正确的，或者至少是允许的，虽然它们在逻辑上是互相冲突的。在认为 这种折衷粗糙之前，应该想到，容忍逻辑上无法自圆其说的观点正是人类思维活动的特点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;119&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210805085227934.png&#34; alt=&#34;image-20210805085227934&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可能看起来比较深奥，但指向函数指针数组的指针并不少见。实际上，类的虚方法实现通常都采用了这种技术（参见第13章）。&lt;/p&gt;
&lt;h3 id=&#34;7104-使用typedef进行简化&#34;&gt;7.10.4 使用typedef进行简化&lt;/h3&gt;
&lt;p&gt;这里采用的方法是，将别名当做标识符进行声明，并在开头使用关键字 &lt;code&gt;typedef&lt;/code&gt;。&lt;br&gt;
使用typedef可减少输入量，让您编写代码时不容易犯错，并让程序 更容易理解。&lt;/p&gt;
&lt;h3 id=&#34;711-总结&#34;&gt;7.11 总结&lt;/h3&gt;
&lt;p&gt;函数是C++的编程模块。要使用函数，必须提供定义和原型，并调 用该函数。函数定义是实现函数功能的代码；函数原型描述了函数的接 口：传递给函数的值的数目和种类以及函数的返回类型。函数调用使得 程序将参数传递给函数，并执行函数的代码。&lt;/p&gt;
&lt;p&gt;C++提供了3种表示C-风格字符串的方法：字符数组、字符串常量 和字符串指针。它们的类型都是&lt;code&gt;char*&lt;/code&gt;（&lt;code&gt;char&lt;/code&gt;指针），因此被作为&lt;code&gt;char*&lt;/code&gt;类型参数传递给函数。C++使用空值字符 &lt;code&gt;\0&lt;/code&gt; 来结束字符串，因此字符 串函数检测空值字符来确定字符串的结尾。&lt;/p&gt;
&lt;p&gt;C++处理结构体的方式与基本类型完全相同，这意味着可以按值传递结构体，并将其用作函数返回类型。然而，如果结构体非常大，则传递结构体指针的效率将更高，同时函数能够使用原始数据。&lt;/p&gt;
&lt;h1 id=&#34;第八章-函数探幽&#34;&gt;第八章 函数探幽&lt;/h1&gt;
&lt;p&gt;本章内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内联函数；&lt;/li&gt;
&lt;li&gt;引用变量；&lt;/li&gt;
&lt;li&gt;如何按引用传递函数参数；&lt;/li&gt;
&lt;li&gt;默认参数；&lt;/li&gt;
&lt;li&gt;函数重载；&lt;/li&gt;
&lt;li&gt;函数模板；&lt;/li&gt;
&lt;li&gt;函数模板具体化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;81-c-内联函数&#34;&gt;8.1 C++ 内联函数&lt;/h2&gt;
&lt;p&gt;内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。 常规函数调用也使程序跳到另一个地址（函数的地址），并在函数结束时返回。&lt;/p&gt;
&lt;p&gt;C++内联函数提供了另一种选择。内联函数的编译代码与其他程序代码“内联”起来了。也就是说，&lt;strong&gt;编译器将使用相应的函数代码替换函数调用&lt;/strong&gt;。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;120&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210805155012304.png&#34; alt=&#34;image-20210805155012304&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;要使用这项特性，必须采取下述措施之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在函数声明前加上关键字 inline；&lt;/li&gt;
&lt;li&gt;在函数定义前加上关键字 inline；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内联函数最好都是一些很简单、行数少的函数。&lt;/p&gt;
&lt;h2 id=&#34;82-引用变量&#34;&gt;8.2 引用变量&lt;/h2&gt;
&lt;p&gt;C++新增了一种复合类型——引用变量。&lt;strong&gt;引用是已定义的变量的别名（另一个名称）&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;821-创建引用变量&#34;&gt;8.2.1 创建引用变量&lt;/h3&gt;
&lt;p&gt;C++给&lt;code&gt;&amp;amp;&lt;/code&gt;符号赋予另一个含义，将其用来声明引用。例如，要将 &lt;code&gt;rodents&lt;/code&gt;作为&lt;code&gt;rats&lt;/code&gt;变量的别名，可以这样做：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;int rats;
int &amp;amp;rodents = rats;  // makes rodents an alias for rats
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，&lt;strong&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 不是地址运算符，而是类型标识符的一部分&lt;/strong&gt;。就像声明中的 &lt;code&gt;char*&lt;/code&gt; 指的是指向 &lt;code&gt;char&lt;/code&gt; 的指针一样，&lt;code&gt;int &amp;amp;&lt;/code&gt; 指的是指向 &lt;code&gt;int&lt;/code&gt; 的引用。&lt;/p&gt;
&lt;p&gt;将 &lt;code&gt;rodents&lt;/code&gt; 加1将影响这两个变量。更准确地说， &lt;code&gt;rodents++&lt;/code&gt; 操作将一共有两个名称的变量加1。&lt;/p&gt;
&lt;p&gt;引用看上去很像伪装表示的指针（其中，&lt;code&gt;*&lt;/code&gt; 解除引用运算符被隐式理解）。实际上，引用还是不同于指针的。除了表示法不同外，还有其他的差别。例如，差别之一是， 必须在声明引用时将其初始化，而不能像指针那样，先声明，再赋值。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;121&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210805160617225.png&#34; alt=&#34;image-20210805160617225&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。也就是说：&lt;strong&gt;某个变量的引用是不可更改的&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;引用是别名。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;822-将引用用作函数参数&#34;&gt;8.2.2 将引用用作函数参数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法称为按引用传递&lt;/strong&gt;。按引用传递允许被调用的函数能够访问调用函数中的变量。&lt;strong&gt;C++新增的这项特性是对C语言的超越，C语言只能按值传递&lt;/strong&gt;。按值传递导致被调用函数使用调用程序的值的拷贝（参见图8.2）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;122&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210805161500948.png&#34; alt=&#34;image-20210805161500948&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;交换函数必须能够修改调用程序中的变量的值。这意味着按值传递变量将不管用，因为函数将交换原始变量副本的内容，而不是变量本身的内容。但传递引用时，函数将可以使用原始数据。另一种方法是，传递指针来访问原始数据。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;123&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210805162214166.png&#34; alt=&#34;image-20210805162214166&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;124&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210805162432252.png&#34; alt=&#34;image-20210805162432252&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;823-引用的属性和特别之处&#34;&gt;8.2.3 引用的属性和特别之处&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;refcube()&lt;/code&gt; 函数修改了 &lt;code&gt;main()&lt;/code&gt; 中的 &lt;code&gt;x&lt;/code&gt; 值，而 &lt;code&gt;cube()&lt;/code&gt; 没有，这提醒我们为何通常按值传递。变量 &lt;code&gt;a&lt;/code&gt; 位于 &lt;code&gt;cube()&lt;/code&gt; 中，它被初始化为 &lt;code&gt;x&lt;/code&gt; 的值，但修改 &lt;code&gt;a&lt;/code&gt; 并不会影响 &lt;code&gt;x&lt;/code&gt;。但由于 &lt;code&gt;refcube()&lt;/code&gt; 使用了引用参数，因此修改 &lt;code&gt;ra&lt;/code&gt; 实际上就是修改 &lt;code&gt;x&lt;/code&gt;。如果只是让函数使用传递给它的信息，而不对这些信息进行修改，同时又想使用引用，则应使用常量引用。&lt;/p&gt;
&lt;p&gt;例如，在这个例子中，应在函数原型和函数头中使用&lt;code&gt;const&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;double refcube(const double &amp;amp;ra);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要编写类似于上述示例的函数（即使用基本数值 类型），应采用按值传递的方式，而不要采用按引用传递的方式。当数据比较大（如结构和类）时，引用参数将很有用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数中应尽可能将引用形参声明为 const，这样好处有三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;const 可以避免无意中修改数据，从而导致编程错误；&lt;/li&gt;
&lt;li&gt;const 使函数能够处理 const 和非 const 实参，否则只能接受非 const 数据；&lt;/li&gt;
&lt;li&gt;const 引用使函数能够正确生成并使用临时变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;824-将引用用于结构体&#34;&gt;8.2.4 将引用用于结构体&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;125&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210805164836645.png&#34; alt=&#34;image-20210805164836645&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;2．为何要返回引用&lt;/p&gt;
&lt;p&gt;下面更深入地讨论返回引用与传统返回机制的不同之处。传统返回机制与按值传递函数参数类似：计算关键字return后面的表达式，并将结果返回给调用函数。从概念上说，这个值被复制到一个临时位置，而 调用程序将使用这个值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;返回引用的函数实际上是被引用的变量的别名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3．返回引用时需要注意的问题&lt;/p&gt;
&lt;p&gt;返回引用时最重要的一点是，应避免返回函数终止时不再存在的内存单元引用。应&lt;strong&gt;避免&lt;/strong&gt;编写如下代码：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;126&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210805165912018.png&#34; alt=&#34;image-20210805165912018&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;该函数返回一个指向临时变量（newguy）的引用，函数运行完毕后 它将不再存在。同样，也应避免返回 指向临时变量的指针。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为避免这种问题，最简单的方法是，返回一个作为参数传递给函数 的引用。作为参数的引用将指向调用函数使用的数据，因此返回的引用 也将指向这些数据。&lt;/p&gt;
&lt;p&gt;4．为何将const用于引用返回类型&lt;/p&gt;
&lt;h3 id=&#34;825-将引用用于类对象&#34;&gt;8.2.5 将引用用于类对象&lt;/h3&gt;
&lt;p&gt;将类对象传递给函数时，C++通常的做法是使用引用。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;127&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210805171059802.png&#34; alt=&#34;image-20210805171059802&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;826-对象-继承和引用&#34;&gt;8.2.6 对象、继承和引用&lt;/h3&gt;
&lt;h3 id=&#34;827-何时使用引用参数&#34;&gt;8.2.7 何时使用引用参数&lt;/h3&gt;
&lt;p&gt;使用引用参数的主要原因有两个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够修改调用函数中的数据对象;&lt;/li&gt;
&lt;li&gt;通过传递引用而不是整个数据对象，可以提高程序的运行速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另一个接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下总结使用引用的原则&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果数据对象很小。如内置数据类型或者小型数据结构，则按值传递；&lt;/li&gt;
&lt;li&gt;如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向 const 的指针；&lt;/li&gt;
&lt;li&gt;如果数据对象是较大的结构体，则使用 const 指针或者 const 引用，以便提升程序的效率。这样可以节省复制结构体所需的时间和空间；&lt;/li&gt;
&lt;li&gt;如果数据对象是类对象，则使用 const 引用。类设计的语义常常要求使用引用，&lt;strong&gt;这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于修改调用函数中数据的函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果数据对象是内置数据类型，则使用指针（不使用引用）。看到诸如：&lt;code&gt;fixit(&amp;amp;x)&lt;/code&gt; 这样的代码（x是int），则很明显，该函数将要修改x；&lt;/li&gt;
&lt;li&gt;如果数据对象是数组，则只能使用指针；&lt;/li&gt;
&lt;li&gt;如果数据对象是结构体，则可以使用引用或者指针；&lt;/li&gt;
&lt;li&gt;如果数据对象是类对象，则（首选）使用引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;83-默认参数&#34;&gt;8.3 默认参数&lt;/h2&gt;
&lt;p&gt;默认参数指的是当函数调用中省略了实参时自动使用的一个值。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;char * left(const char *str, int n=1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对于带参数列表的函数，必须从右向左添加默认值&lt;/strong&gt;。也就是说，要为某个参数设置默认值，&lt;strong&gt;则必须为它右边的所有参数提供默认值&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;int harpo(int n, int m=4, int j=5);      // Valid
int chico(int n, int m=6, int j);        // IN-Valid
int groucho(int k=1, int m=2, int n=3);  // Valid
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实参按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;默认参数只在声明函数的时候给出，定义函数时，则不需要给出&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;128&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210807220518596.png&#34; alt=&#34;image-20210807220518596&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;129&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210807220537984.png&#34; alt=&#34;image-20210807220537984&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;84-函数重载&#34;&gt;8.4 函数重载&lt;/h2&gt;
&lt;p&gt;函数多态是C++在C语言的基础上新增的功能。默认参数让我们能够使用不同数目的参数调用同一个函数，而函数多态（函数重载）让我们能够使用多个同名的函数，这称为函数重载，它们完成相同的工作，但使用不同的参数列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数重载的关键是函数的参数列表——也称为函数特征标 （function signature）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。 C++允许定义名称相同的函数，条件是它们的特征标不同。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;130&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210807221358552.png&#34; alt=&#34;image-20210807221358552&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一些看起来彼此不同的特征标是不能共存的。例如，请看下面的两 个原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;double cube(double x);
double cube(double &amp;amp;x);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能认为可以在此处使用函数重载，因为它们的特征标看起来不同。然而，请从编译器的角度来考虑这个问题。假设有下面这样的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;cout &amp;lt;&amp;lt; cube(x);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参数 &lt;code&gt;x&lt;/code&gt; 与 &lt;code&gt;double x&lt;/code&gt; 原型和 &lt;code&gt;double &amp;amp;x&lt;/code&gt; 原型都匹配，因此编译器无法确定究竟应使用哪个原型。为避免这种混乱，&lt;strong&gt;编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;请记住，&lt;strong&gt;是特征标(即，函数特征列表)，而不是函数返回类型使得可以对函数进行重载&lt;/strong&gt;。 例 如，下面的两个声明是互斥的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;long gronk(int n, float m);    // same signatures,
double gronk(int n, float m);  // hence not allowed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因此，C++不允许以这种方式重载gronk( )。&lt;strong&gt;返回类型可以不同，但特征标也必须不同&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;匹配函数时，并不区分&lt;code&gt;const&lt;/code&gt;和非&lt;code&gt;const&lt;/code&gt;变量（这就要小心了）。看下面的原型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;void dribble(char *bits);         // overloaded
void dribble(const char *cbits);  // overloaded
void dabble(char *bits);          // not overloaded
void drivel(const char *bits);    // not overloaded
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;841-函数重载示例&#34;&gt;8.4.1 函数重载示例&lt;/h3&gt;
&lt;h3 id=&#34;842-何时使用函数重载&#34;&gt;8.4.2 何时使用函数重载&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;虽然函数重载很吸引人，但也不要滥用。仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;85-函数模板&#34;&gt;8.5 函数模板&lt;/h2&gt;
&lt;p&gt;现在的C++编译器实现了C++的另一个新增特性——函数模板。函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的类型（如&lt;code&gt;int&lt;/code&gt;或&lt;code&gt;double&lt;/code&gt;）替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许以泛型（而不是具体类型）的方式编写程序，因此有时也被称为通用编程。由于类型是用参数表示的，因此模板特性有时也被称为参数化类型（parameterized types）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;131&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210807224625424.png&#34; alt=&#34;image-20210807224625424&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;第一行指出，要建立一个模板，并将类型命名为 &lt;code&gt;AnyType&lt;/code&gt;。关键字 &lt;code&gt;template&lt;/code&gt;和 &lt;code&gt;typename&lt;/code&gt; 是必需的，除非可以使用关键字 &lt;code&gt;class&lt;/code&gt; 代替 &lt;code&gt;typename&lt;/code&gt;。 另外，&lt;strong&gt;必须使用尖括号&lt;/strong&gt;。类型名可以任意选择（这里为 &lt;code&gt;AnyType&lt;/code&gt;），只要遵守C++命名规则即可；许多程序员都使用简单的名称，如 &lt;code&gt;T&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;模板并不创建任何函数，而只是告诉编译器如何定义函数。需要交换&lt;code&gt;int&lt;/code&gt;的函数时，编译器将按模板 模式创建这样的函数，并用&lt;code&gt;int&lt;/code&gt;代替&lt;code&gt;AnyType&lt;/code&gt;。同样，需要交换&lt;code&gt;double&lt;/code&gt;的函数时，编译器将按模板模式创建这样的函数，并用&lt;code&gt;double&lt;/code&gt;代替 &lt;code&gt;AnyType&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最终 的代码不包含任何模板，而只包含了为程序生成的实际函数。使用模板 的好处是，它使生成多个函数定义更简单、更可靠。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;132&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210807225139508.png&#34; alt=&#34;image-20210807225139508&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;typename&lt;/code&gt;关键字使得参数&lt;code&gt;AnyType&lt;/code&gt;表示类型这一点更为明显；然而，有大量代码库是使用关键字class开发的。在这种上下文中，&lt;strong&gt;这两个关键字是等价的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;需要多个对不同类型使用同一种算法的函数时，可使用模板。&lt;/p&gt;
&lt;h3 id=&#34;852-模板的局限&#34;&gt;8.5.2 模板的局限&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;下面的代码假定定义了赋 值，但如果T为数组，这种假设将不成立；&lt;/li&gt;
&lt;li&gt;下面的语句假设定义了 &lt;code&gt;&amp;lt;&lt;/code&gt;，但如果T为结构，该假设便不成立；另外，为数组名定义了运算符 &lt;code&gt;&amp;gt;&lt;/code&gt;，但由于数组名为地址，因此它比较的是数组的地址，而这可能不是您希望的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总之，编写的模板函数很可能无法处理某些类型。另一方面，有时 候通用化是有意义的，但C++语法不允许这样做。&lt;/p&gt;
&lt;h3 id=&#34;853-显式具体化&#34;&gt;8.5.3 显式具体化&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;由于C++允许将一个结构赋给另一个结构，因此即使T是一个&lt;code&gt;job&lt;/code&gt;结构，上述代码也适用。然而，假设只想交换 &lt;code&gt;salary&lt;/code&gt; 和 &lt;code&gt;floor&lt;/code&gt; 成员，而不交 换 &lt;code&gt;name&lt;/code&gt; 成员，则需要使用不同的代码，但 &lt;code&gt;Swap()&lt;/code&gt; 的参数将保持不变 （两个 &lt;code&gt;job&lt;/code&gt; 结构的引用），因此无法使用模板重载来提供其他的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;对于给定的函数名，可以有非模板函数、模板函数和显式具体化模 板函数以及它们的重载版本；&lt;/li&gt;
&lt;li&gt;显式具体化的原型和定义应以 &lt;code&gt;template&amp;lt;&amp;gt;&lt;/code&gt; 打头，并通过名称来指出 类型；&lt;/li&gt;
&lt;li&gt;具体化优先于常规模板，而非模板函数优先于具体化和常规模板。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果有多个原型，则编译器在选择原型时，&lt;strong&gt;非模板版本优先于显式具体化和模板版本，而显式具体化优先于使用模板生成的版本&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;133&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210808001952681.png&#34; alt=&#34;image-20210808001952681&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;134&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210808002201785.png&#34; alt=&#34;image-20210808002201785&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;854-实例化和具体化&#34;&gt;8.5.4 实例化和具体化&lt;/h3&gt;
&lt;p&gt;为进一步了解模板，必须理解术语实例化和具体化。记住，在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例（instantiation）。&lt;/p&gt;
&lt;p&gt;函数调用&lt;code&gt;Swap(i,j&lt;/code&gt;)导致编译器生成&lt;code&gt;Swap()&lt;/code&gt;的一个实例，该实例使用&lt;code&gt;int&lt;/code&gt;类型。&lt;strong&gt;模板并非函数定 义，但使用int的模板实例是函数定义&lt;/strong&gt;。这种实例化方式被称为隐式实例 化（implicit instantiation），因为编译器之所以知道需要进行定义，是 由于程序调用Swap( )函数时提供了int参数。&lt;/p&gt;
&lt;p&gt;最初，编译器只能通过隐式实例化，来使用模板生成函数定义，但现在C++还允许显式实例化（explicit instantiation）。这意味着可以直接 命令编译器创建特定的实例，如&lt;code&gt;Swap&amp;lt;int&amp;gt;()&lt;/code&gt;。其语法是，声明所需的种类——用&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;符号指示类型，并在声明前加上关键字 &lt;code&gt;template&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;template void Swap&amp;lt;int&amp;gt;(int, int);  // explicit instantiation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现了这种特性的编译器看到上述声明后，将使用&lt;code&gt;Swap()&lt;/code&gt;模板生成 一个使用&lt;code&gt;int&lt;/code&gt;类型的实例。也就是说，该声明的意思是“使用&lt;code&gt;Swap()&lt;/code&gt;模板生成&lt;code&gt;int&lt;/code&gt;类型的函数定义“。&lt;/p&gt;
&lt;p&gt;与显式实例化不同的是，显式具体化使用下面两个等价的声明之 一：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;template &amp;lt;&amp;gt; void Swap&amp;lt;int&amp;gt;(int &amp;amp;, int &amp;amp;);
template &amp;lt;&amp;gt; void Swap(int &amp;amp;, int &amp;amp;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区别在于，这些声明的意思是“不要使用 &lt;code&gt;Swap()&lt;/code&gt; 模板来生成函数定 义，而应使用专门为 &lt;code&gt;int&lt;/code&gt; 类型显式地定义的函数定义”。这些原型必须有自己的函数定义。&lt;strong&gt;显式具体化声明在关键字 &lt;code&gt;template&lt;/code&gt; 后包含 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;，而显式实例化没有&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;隐式实例化、显式实例化和显式具体化统称为具体化 （specialization）。它们的相同之处在于，它们表示的都是使用具体类 型的函数定义，而不是通用描述。&lt;/p&gt;
&lt;p&gt;引入显式实例化后，必须使用新的语法——在声明中使用前缀&lt;code&gt;template&lt;/code&gt;和&lt;code&gt;template &amp;lt;&amp;gt;&lt;/code&gt;，以区分显式实例化和显式具体化。通常，功能 越多，语法规则也越多。下面的代码片段总结了这些概念：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;135&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210808202129389.png&#34; alt=&#34;image-20210808202129389&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;855-编译器选择使用哪个函数版本&#34;&gt;8.5.5 编译器选择使用哪个函数版本&lt;/h3&gt;
&lt;p&gt;对于函数重载、函数模板和函数模板重载，C++需要（且有）一个 定义良好的策略，来决定为函数调用使用哪一个函数定义，尤其是有多 个参数时。这个过程称为重载解析（overloading resolution）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1步：创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。&lt;/li&gt;
&lt;li&gt;第2步：使用候选函数列表创建可行函数列表。这些都是参数数目 正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应 的形参类型完全匹配的情况。例如，使用float参数的函数调用可以 将该参数转换为double，从而与double形参匹配，而模板可以为 float生成一个实例;&lt;/li&gt;
&lt;li&gt;第3步：确定是否有最佳的可行函数。如果有，则使用它，否则该 函数调用出错。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，编译器必须确定哪个可行函数是最佳的。它查看为使函数 调用参数与可行的候选函数的参数匹配所需要进行的转换。通常，从最 佳到最差的顺序如下所述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全匹配，但常规函数优先于模板；&lt;/li&gt;
&lt;li&gt;提升转换（例如，char和shorts自动转换为int，float自动转换为 double）；&lt;/li&gt;
&lt;li&gt;标准转换（例如，int转换为char，long转换为double）；&lt;/li&gt;
&lt;li&gt;用户定义的转换，如类声明中定义的转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;856-模板函数的发展&#34;&gt;8.5.6 模板函数的发展&lt;/h3&gt;
&lt;h2 id=&#34;86-总结&#34;&gt;8.6 总结&lt;/h2&gt;
&lt;p&gt;C++扩展了C语言的函数功能。通过将 inline 关键字用于函数定义， 并在首次调用该函数前提供其函数定义，可以使得C++编译器将该函数视为内联函数。也就是说，编译器不是让程序跳到独立的代码段，以执行函数，而是用相应的代码替换函数调用（相当于复制进去）。只有在函数很短时才能采用内联方式。&lt;/p&gt;
&lt;p&gt;引用变量是一种伪装指针，它允许为变量创建别名（另一个名称）。引用变量主要被用作处理结构和类对象的函数的参数。&lt;/p&gt;
&lt;p&gt;C++原型让您能够定义参数的默认值。如果函数调用省略了相应的参数，则程序将使用默认值；如果函数调用提供了参数值，则程序将使用这个值（而不是默认值）。只能在参数列表中从右到左提供默认参数。&lt;/p&gt;
&lt;p&gt;函数的特征标是其参数列表。程序员可以定义两个同名函数，只要其特征标不同。这被称为函数多态或函数重载。&lt;/p&gt;
&lt;h1 id=&#34;第九章-内存模型和名称空间&#34;&gt;第九章 内存模型和名称空间&lt;/h1&gt;
&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单独编译；&lt;/li&gt;
&lt;li&gt;存储持续性、作用域和链接性；&lt;/li&gt;
&lt;li&gt;定位（placement）new运算符；&lt;/li&gt;
&lt;li&gt;名称空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;91-单独编译&#34;&gt;9.1 单独编译&lt;/h2&gt;
&lt;p&gt;第1章介绍过，可以单独编译文件，然后将它们链接成可执行的程序。通常，C++编译器既编译程序，也管理链接器。如果只修改了一个文件，则可以只重新编译该文件，然后将它与其他文件的编译版本链接，这使得大程序的管理更便捷。&lt;/p&gt;
&lt;p&gt;例如，UNIX和Linux系统都具有make程 序，可以跟踪程序依赖的文件以及这些文件的最后修改时间。运行make 时，如果它检测到上次编译后修改了源文件，make将记住重新构建程序 所需的步骤。&lt;/p&gt;
&lt;p&gt;例如但需要将一个结构体在多个文件中复用时，与其将结构体声明加入到每一个文件 中，不如将其放在头文件中，然后在每一个源代码文件中包含该头文件。这样，要修改结构体声明时，只需在头文件中做一次改动即可。另外，也可以将函数原型放在头文件中。因此，可以将原来的程序分成三 部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头文件：包含结构体声明和使用这些结构体的函数的声明；&lt;/li&gt;
&lt;li&gt;源代码文件：包含与结构体有关的函数代码；&lt;/li&gt;
&lt;li&gt;源代码文件：包含调用与结构体相关的函数代码；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是一种非常有用的组织程序的策略。例如，如果编写另一个程序 时，也需要使用这些函数，则只需包含头文件，并将函数文件添加到项 目列表或make列表中即可。另外，这种组织方式也与OOP方法一致。&lt;strong&gt;一个文件（头文件）包含了用户定义类型的定义；另一个文件包含操纵用 户定义类型的函数的代码。这两个文件组成了一个软件包，可用于各种程序中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要将函数定义或变量声明放到头文件中&lt;/strong&gt;。这样做通常会引来麻烦，因为，如果在头文件包含了一个函数的定义，然后在（同一个程序的）另外两个文件中分别包含了该头文件，那么同一个程序中将包含同一个函数的两个定义，除非函数是内联的，否则这将出错。&lt;/p&gt;
&lt;p&gt;头文件常包含的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数原型（也叫函数声明）；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;#define&lt;/code&gt;或&lt;code&gt;const&lt;/code&gt;定义的符号常量；&lt;/li&gt;
&lt;li&gt;结构体声明；&lt;/li&gt;
&lt;li&gt;类声明；&lt;/li&gt;
&lt;li&gt;模板声明；&lt;/li&gt;
&lt;li&gt;内联函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将结构体声明放在头文件中是可以的，因为它们不创建变量，而只是在源代码文件中声明结构体变量时，告诉编译器如何创建该结构体变量。同样，模板声明也不是将被编译的代码，它们指示编译器如何生成与源代码中函数调用相匹配的函数定义。被声明为&lt;code&gt;const&lt;/code&gt;的常量和内联函数有特殊的链接属性（稍后将介绍），因此可以将其放在头文件中，而不会引 起问题。&lt;/p&gt;
&lt;p&gt;在包含头文件时，我们使 用&lt;code&gt;&amp;quot;coordin.h&amp;quot;&lt;/code&gt;，而不是 &lt;code&gt;&amp;lt;coodin.h&amp;gt;&lt;/code&gt;。如果文件名包含在尖括号中，则 C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号中，&lt;strong&gt;则编译器将首先查找当前的工作目录或源代码目录（取决于编译器）&lt;/strong&gt;，如果没有找到， 则将在标准位置查找。&lt;strong&gt;因此在包含自己的头文件时，应使用引号而不是 尖括号&lt;/strong&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;136&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210810163533843.png&#34; alt=&#34;image-20210810163533843&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;在同一个文件中只能将同一个头文件包含一次。记住这个规则很容易，但很可能在不知 情的情况下将头文件包含多次。例如，可能使用包含了另外一个头文件的头文件。有一种标准的C/C++技术可以避免多次包含同一个头文件。它是基于预处理器编译指令#ifndef（即if not defined）的。&lt;code&gt;#ifndef-#define-#endif&lt;/code&gt; 语句的这种方法&lt;strong&gt;并不能防止编译器将文件包含两次，而只是让它忽略除第一次包含之外的所有内容&lt;/strong&gt;。大多数标准C和C++头文件都使用这种防护 （guarding）方案。否则，可能在一个文件中定义同一个结构体、函数、类等两次，这将导致编译错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;92-存储持续性-作用域和链接性&#34;&gt;9.2 存储持续性、作用域和链接性&lt;/h2&gt;
&lt;p&gt;存储类别如何影响信息在文件间的共享？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动存储持续性：在&lt;strong&gt;函数定义中声明的变量&lt;/strong&gt;（包括函数参数）的存 储持续性为自动的。在程序开始执行其所属的函数或代码块时 被创建，在执行完函数或代码块时，它们使用的内存被释放；&lt;/li&gt;
&lt;li&gt;静态存储持续性：在函数&lt;strong&gt;定义外&lt;/strong&gt;定义的变量和使用关键字&lt;code&gt;static&lt;/code&gt;定义 的变量的存储持续性都为静态。它们在程序整个运行过程中都存在；&lt;/li&gt;
&lt;li&gt;线程存储持续性（C++11）：如果变量是使用关键字&lt;code&gt;thread_local&lt;/code&gt;声明的，则其生命 周期与所属的线程一样长；&lt;/li&gt;
&lt;li&gt;动态存储持续性：用&lt;code&gt;new&lt;/code&gt;运算符分配的内存将一直存在，直到使用 &lt;code&gt;delete&lt;/code&gt;运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储（free store）或堆（heap）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;921-作用域和链接&#34;&gt;9.2.1 作用域和链接&lt;/h3&gt;
&lt;p&gt;作用域（scope）描述了名称在文件（翻译单元）的多大范围内可见。链接性（linkage）描述了名称如何在不同单元间共享。链接性为外部的 名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共 享。自动变量的名称没有链接性，因为它们不能共享。&lt;/p&gt;
&lt;p&gt;作用域为局部的变量只在定义它的代码 块中可用。&lt;strong&gt;代码块是由花括号括起的一系列语句&lt;/strong&gt;。例如函数体就是代码块，但可以在函数体中嵌入其他代码块。作用域为全局（也叫文件作用域）的变量在定义位置到文件结尾之间都可用。自动变量的作用域为局部，静态变量的作用域是全局还是局部取决于它是如何被定义的。在函数原型作用域（function prototype scope）中使用的名称只在包含参数列表的括号内可用（&lt;strong&gt;这就是为什么这些名称是什么以及是否出现都不重要的原因&lt;/strong&gt;）。在类中声明的成员的作用域为整个类。在名 称空间中声明的变量的作用域为整个名称空间&lt;/p&gt;
&lt;h3 id=&#34;922-自动存储持续性&#34;&gt;9.2.2 自动存储持续性&lt;/h3&gt;
&lt;p&gt;在默认情况下，在函数中声明的函数参数和变量的存储持续性为自 动，作用域为局部，没有链接性。&lt;/p&gt;
&lt;p&gt;如果在代码块中定义了变量，则该变量的存在时间和作用域将被限 制在该代码块内。例子：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;137&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811100416035.png&#34; alt=&#34;image-20210811100416035&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;138&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811100534389.png&#34; alt=&#34;image-20210811100534389&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;1．自动变量的初始化&lt;br&gt;
2．自动变量和栈&lt;/p&gt;
&lt;p&gt;由于自动变量的数目随函数的开始和结束而增减，因此程序必须 在运行时对自动变量进行管理。常用的方法是留出一段内存，并将其视为栈，以管理变量的增减。之所以被称为栈，是由于新数据被象征性地放在原有数据的上面（也就是说，在相邻的内存单元中，而不是在同一 个内存单元中），当程序使用完后，将其从栈中删除。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;139&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811110310770.png&#34; alt=&#34;image-20210811110310770&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;3．寄存器变量&lt;br&gt;
这旨在提高访问变量的速度。&lt;/p&gt;
&lt;h3 id=&#34;923-静态持续变量&#34;&gt;9.2.3 静态持续变量&lt;/h3&gt;
&lt;p&gt;要想创建链接性为外部的静态持续变量，必须在代码块的外面声明它；&lt;br&gt;
要创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用 &lt;code&gt;static&lt;/code&gt; 限定符；&lt;br&gt;
要创建没有链接性的静态持续变量，必须在代码块内声明它，并使用 &lt;code&gt;static&lt;/code&gt; 限定符。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;140&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811110632232.png&#34; alt=&#34;image-20210811110632232&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;正如前面指出的，所有静态持续变量（上述示例中的&lt;code&gt;global&lt;/code&gt;、 &lt;code&gt;one_file&lt;/code&gt;和 &lt;code&gt;count&lt;/code&gt;）在整个程序执行期间都存在。在 &lt;code&gt;funct1()&lt;/code&gt; 中声明的变量 &lt;code&gt;count&lt;/code&gt; 的作用域为局部，没有链接性，这意味着只能在&lt;code&gt;funct1()&lt;/code&gt; 函数中使用它，就像自动变量 &lt;code&gt;llama&lt;/code&gt; 一样。然而，与&lt;code&gt;llama&lt;/code&gt; 不同的是，即使在 &lt;code&gt;funct1()&lt;/code&gt; 函数没有被执行时，&lt;code&gt;count&lt;/code&gt; 也留在内存中。&lt;code&gt;global&lt;/code&gt; 和 &lt;code&gt;one_file&lt;/code&gt; 的作用域都为整个文件，即在从声明位置到文件结尾的范围内都可以被使 用。具体地说，可以在 &lt;code&gt;main()&lt;/code&gt;、&lt;code&gt;funct1()&lt;/code&gt; 和 &lt;code&gt;funct2()&lt;/code&gt; 中使用它们。由于&lt;code&gt;one_file&lt;/code&gt; 的链接性为内部，因此只能在包含上述代码的文件中使用它； 由于 &lt;code&gt;global&lt;/code&gt; 的链接性为外部，因此可以在程序的其他文件中使用它。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;应少用静态外部变量，如使用最好都声明为内部连接性的静态变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;141&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811111319645.png&#34; alt=&#34;image-20210811111319645&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;924-静态持续性-外部链接性&#34;&gt;9.2.4 静态持续性、外部链接性&lt;/h3&gt;
&lt;p&gt;链接性为外部的变量通常简称为外部变量，它们的存储持续性为静 态，作用域为整个文件。外部变量是在函数外部定义的，因此对所有函 数而言都是外部的。&lt;/p&gt;
&lt;p&gt;1．单定义规则&lt;br&gt;
C++有“单定义规则”（One Definition Rule，ODR），该规则指出， 变量只能有一次定义。请注意，单定义规则并非意味着不能有多个变量的名称相同。例 如，在不同函数中声明的同名自动变量是彼此独立的，它们都有自己的 地址。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;142&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811111827133.png&#34; alt=&#34;image-20210811111827133&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;925-静态持续性-内部链接性&#34;&gt;9.2.5 静态持续性、内部链接性&lt;/h3&gt;
&lt;p&gt;将static限定符用于作用域为整个文件的变量时，该变量的链接性将 为内部的。在多文件程序中，内部链接性和外部链接性之间的差别很有 意义。链接性为内部的变量只能在其所属的文件中使用；但常规外部变 量都具有外部链接性，即可以在其他文件中使用。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;143&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811112129019.png&#34; alt=&#34;image-20210811112129019&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;在多文件程序中，可以在一个文件（且只能在一个文件）中定义一个外部变量。使用该变量的其他文件必须使用关键字 &lt;code&gt;extern&lt;/code&gt; 声明它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可使用外部变量在多文件程序的不同部分之间共享数据；可使用链接性为内部的静态变量在同一个文件中的多个函数之间共享数据（名称空间提供了另外一种共享数据的方法）。另外，如果将作用域为整个文 件的变量变为静态的，就不必担心其名称与其他文件中的作用域为整个 文件的变量发生冲突。&lt;/p&gt;
&lt;h3 id=&#34;926-静态存储持续性-无链接性&#34;&gt;9.2.6 静态存储持续性、无链接性&lt;/h3&gt;
&lt;p&gt;这种变量是这样创建的，将static限定符用于在代码块中定义的变 量。在代码块中使用static时，将导致局部变量的存储持续性为静态的。 这意味着虽然该变量只在该代码块中可用，但它在该代码块不处于活动 状态时仍然存在。因此在两次函数调用之间，静态局部变量的值将保持 不变。（静态变量适用于再生——可以用它们将瑞士银行的秘密账号传 递到下一个要去的地方）。另外，如果初始化了静态局部变量，则程序 只在启动时进行一次初始化。以后再调用函数时，将不会像自动变量那样再次被初始化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// static.cpp -- using a static local variable
#include &amp;lt;iostream&amp;gt;
// constants
const int ArSize = 10;

// function prototype
void strcount(const char * str);

int main()
{
    using namespace std;
    char input[ArSize];
    char next;

    cout &amp;lt;&amp;lt; &amp;quot;Enter a line:\n&amp;quot;;
    cin.get(input, ArSize);
    while (cin)
    {
        cin.get(next);
        while (next != &#39;\n&#39;)    // string didn&#39;t fit!
            cin.get(next);      // dispose of remainder
        strcount(input);
        cout &amp;lt;&amp;lt; &amp;quot;Enter next line (empty line to quit):\n&amp;quot;;
        cin.get(input, ArSize);
    }
    cout &amp;lt;&amp;lt; &amp;quot;Bye\n&amp;quot;;
// code to keep window open for MSVC++
/*
cin.clear();
    while (cin.get() != &#39;\n&#39;)
        continue;
    cin.get();
*/
    return 0;
}

void strcount(const char * str)
{
    using namespace std;
    static int total = 0;        // static local variable
    int count = 0;               // automatic local variable

    cout &amp;lt;&amp;lt; &amp;quot;\&amp;quot;&amp;quot; &amp;lt;&amp;lt; str &amp;lt;&amp;lt;&amp;quot;\&amp;quot; contains &amp;quot;;
    while (*str++)               // go to end of string
        count++;
    total += count;
    cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; &amp;quot; characters\n&amp;quot;;
    cout &amp;lt;&amp;lt; total &amp;lt;&amp;lt; &amp;quot; characters total\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;144&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811112939105.png&#34; alt=&#34;image-20210811112939105&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;注意，在这个程序中，由于数组长度为10，因此程序从每行读取的字符数都不超过 9个。另外还需要注意的是，每次函数被调用时，自动变量count都被重 置为0。然而，静态变量total只在程序运行时被设置为0，以后在两次函 数调用之间，其值将保持不变，因此能够记录读取的字符总数。&lt;/p&gt;
&lt;h3 id=&#34;927-说明符和限定符&#34;&gt;9.2.7 说明符和限定符&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;145&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811113430209.png&#34; alt=&#34;image-20210811113430209&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;再谈const&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在C++（但不是在C语言）中，&lt;code&gt;const&lt;/code&gt;限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部的，&lt;strong&gt;但&lt;code&gt;const&lt;/code&gt;全局变量的链接性为内部的&lt;/strong&gt;。也就是说，在C++看来，全局 &lt;code&gt;const&lt;/code&gt; 定义就像使用了 &lt;code&gt;static&lt;/code&gt; 说明符一样。&lt;/p&gt;
&lt;p&gt;C++修改了常量类型的规则，让程序员更轻松。例如，假设将一组 常量放在头文件中，并在同一个程序的多个文件中使用该头文件。那 么，预处理器将头文件的内容包含到每个源文件中后，所有的源文件都 将包含类似下面这样的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;const int fingers = 10;
const char *waring = &amp;quot;wak!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果全局const声明的链接性像常规变量那样是外部的，则根据单定 义规则，这将出错（幸亏不是）。&lt;/p&gt;
&lt;p&gt;由于外部定义的&lt;code&gt;const&lt;/code&gt;数据的链接性为内部的，因此可以在所有文件中使用相同的声明。&lt;/p&gt;
&lt;h3 id=&#34;928-函数和链接性&#34;&gt;9.2.8 函数和链接性&lt;/h3&gt;
&lt;p&gt;和变量一样，函数也有链接性，虽然可选择的范围比变量小。和C 语言一样，C++不允许在一个函数中定义另外一个函数，因此所有函数 的存储持续性都自动为静态的，即在整个程序执行期间都一直存在。在 默认情况下，函数的链接性为外部的，即可以在文件间共享。实际上， 可以在函数原型中使用关键字extern来指出函数是在另一个文件中定义 的，不过这是可选的。&lt;strong&gt;还可以使用关键字&lt;code&gt;static&lt;/code&gt;将函数的链接性设置为内部的，使之只能在一个文件中使用&lt;/strong&gt;，但必须同时在原型和函数定义中使用该关键字。&lt;/p&gt;
&lt;h3 id=&#34;929-语言链接性&#34;&gt;9.2.9 语言链接性&lt;/h3&gt;
&lt;p&gt;在 C++中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的 符号名称。因此，C++编译器执行名称矫正或名称修饰（参见第8 章），为重载函数生成不同的符号名称。例如，可能将&lt;code&gt;spiff(int)&lt;/code&gt;转换 为 &lt;code&gt;_spoff_i&lt;/code&gt;，而将 &lt;code&gt;spiff(double，double)&lt;/code&gt; 转换为 &lt;code&gt;_spiff_d_d&lt;/code&gt;。这种方法被称为C++语言链接（C++ language linkage）。&lt;/p&gt;
&lt;h3 id=&#34;9210-存储方案和动态分配&#34;&gt;9.2.10 存储方案和动态分配&lt;/h3&gt;
&lt;p&gt;动态内存由运算符 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 控制，而不是由作用域和链接性规则控制。因此，&lt;strong&gt;可以在一个函数中分配动态内存，而在另一个函数中将其释放&lt;/strong&gt;。与自动内存不同，动态内存不是LIFO，其分配和释放顺序要取决于 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 在何时以何种方式被使用。通常，编译器使用三块独立的内存：一块用 于静态变量（可能再细分），一块用于自动变量，另外一块用于动态存 储。&lt;/p&gt;
&lt;h2 id=&#34;93-名称空间&#34;&gt;9.3 名称空间&lt;/h2&gt;
&lt;p&gt;名称可以是变量、函数、结构体、枚举、类以及类和结构体的成员。C++标准提供了名称空间工具，以便更好地控制名称的作用域。&lt;/p&gt;
&lt;h3 id=&#34;931-传统的c名称空间&#34;&gt;9.3.1 传统的C++名称空间&lt;/h3&gt;
&lt;p&gt;C++关于全局变量和局部变量的规则定义了一种名称空间层次。每 个声明区域都可以声明名称，这些名称独立于在其他声明区域中声明的 名称。在一个函数中声明的局部变量不会与在另一个函数中声明的局部 变量发生冲突。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;146&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811114957087.png&#34; alt=&#34;image-20210811114957087&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;147&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811115021641.png&#34; alt=&#34;image-20210811115021641&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;932-新的名称空间特性&#34;&gt;9.3.2 新的名称空间特性&lt;/h3&gt;
&lt;p&gt;C++新增了这样一种功能，即通过定义一种新的声明区域来创建命 名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名 称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允 许程序的其他部分使用该名称空间中声明的东西。&lt;/p&gt;
&lt;p&gt;名称空间可以是全局的，也可以位于另一个名称空间中，&lt;strong&gt;但不能位于代码块中&lt;/strong&gt;。因此，在默认情况下，在名称空间中声明的名称的链接性 为外部的（除非它引用了常量）。&lt;/p&gt;
&lt;p&gt;1．using声明和using编译指令&lt;/p&gt;
&lt;p&gt;using声明由被限定的名称和它前面的关键字using组成：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;using Jill::fetch;        // a using declaration
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;using&lt;/code&gt; 声明将特定的名称添加到它所属的声明区域中。例如 &lt;code&gt;main()&lt;/code&gt; 中的 &lt;code&gt;using&lt;/code&gt; 声明 &lt;code&gt;Jill::fetch&lt;/code&gt; 将 &lt;code&gt;fetch&lt;/code&gt; 添加到 &lt;code&gt;main()&lt;/code&gt; 定义的声明区域中。完成该声明后，便可以使用名称 &lt;code&gt;fetch&lt;/code&gt; 代替 &lt;code&gt;Jill::fetch&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;using声明使一个名称可用，而using编译指令使所有的名称都可 用。using编译指令由名称空间名和它前面的关键字using namespace组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符。在全局声明区域中使用using编译指令，将使该名称空间的名称全局可用。&lt;/p&gt;
&lt;p&gt;2．using编译指令和using声明之比较&lt;/p&gt;
&lt;p&gt;一般说来，使用&lt;code&gt;using&lt;/code&gt;声明比使用&lt;code&gt;using&lt;/code&gt;编译指令更安全，这是由于它只导入指定的名称。如果该名称与局部名称发生冲突，编译器将发出 指示。&lt;code&gt;using&lt;/code&gt; 编译指令导入所有名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。&lt;/p&gt;
&lt;p&gt;3．名称空间的其他特性&lt;br&gt;
可以将名称空间声明进行嵌套。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;148&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811135518193.png&#34; alt=&#34;image-20210811135518193&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这里，flame指的是element:🔥:flame。同样，可以使用下面的 using编译指令使内部的名称可用。&lt;/p&gt;
&lt;p&gt;4．未命名的名称空间&lt;/p&gt;
&lt;p&gt;可以通过省略名称空间的名称来创建未命名的名称空间。&lt;/p&gt;
&lt;p&gt;该名称空间中声明的名称的潜在作用域为：从声明点到该声明区域末尾，这与全局变量相似。然而，这种名称空间没有名称，因此不能显式地使用 &lt;code&gt;using&lt;/code&gt; 编译指令或 &lt;code&gt;using&lt;/code&gt; 声明来使它在其他位置都可用。也就是说，不能在未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称。这相当于是一个链接性为内部的静态变量的替代品。&lt;/p&gt;
&lt;h3 id=&#34;934-名称空间及其前途&#34;&gt;9.3.4 名称空间及其前途&lt;/h3&gt;
&lt;p&gt;使用名称空间的原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用在已命名的名称空间中声明的变量，而不是使用外部全局变量；&lt;/li&gt;
&lt;li&gt;使用在已命名的名称空间中声明的变量，而不是使用静态全局变量；&lt;/li&gt;
&lt;li&gt;如果开发了一个函数库或类库，将其放在一个名称空间中；&lt;/li&gt;
&lt;li&gt;仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计；&lt;/li&gt;
&lt;li&gt;不要在头文件中使用 &lt;code&gt;using&lt;/code&gt; 编译指令。首先，这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令 &lt;code&gt;using&lt;/code&gt;，应将其放在所有预处理器编译指令 &lt;code&gt;#include&lt;/code&gt; 之后；&lt;/li&gt;
&lt;li&gt;导入名称时，首选使用作用域解析运算符或using声明的方法；&lt;/li&gt;
&lt;li&gt;对于using声明，首选将其作用域设置为局部而不是全局。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;94-总结&#34;&gt;9.4 总结&lt;/h2&gt;
&lt;p&gt;C++提倡在开发程序时使用多个文件。一种有效的组织策略 是，使用头文件来定义用户类型，为操纵用户类型的函数提供函数原 型；并将函数定义放在一个独立的源代码文件中。头文件和源代码文件 一起定义和实现了用户定义的类型及其使用方式。&lt;/p&gt;
&lt;p&gt;C++的存储方案决定了变量保留在内存中的时间（储存持续性）以 及程序的哪一部分可以访问它（作用域和链接性）。&lt;/p&gt;
&lt;p&gt;动态内存分配和释放是使用new和delete进行的，它使用自由存储区 或堆来存储数据。调用new占用内存，而调用delete释放内存。程序使用 指针来跟踪这些内存单元。&lt;/p&gt;
&lt;p&gt;名称空间允许定义一个可在其中声明标识符的命名区域。这样做的 目的是减少名称冲突，尤其当程序非常大，并使用多个厂商的代码时。可以通过使用作用域解析运算符、using声明或using编译指令，来使名 称空间中的标识符可用。&lt;/p&gt;
&lt;h1 id=&#34;第十章-对象和类&#34;&gt;第十章 对象和类&lt;/h1&gt;
&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过程性编程和面向对象编程；&lt;/li&gt;
&lt;li&gt;类概念；&lt;/li&gt;
&lt;li&gt;如何定义和实现类；&lt;/li&gt;
&lt;li&gt;公有类访问和私有类访问；&lt;/li&gt;
&lt;li&gt;类的数据成员；&lt;/li&gt;
&lt;li&gt;类方法（类成员函数）；&lt;/li&gt;
&lt;li&gt;创建和使用类对象；&lt;/li&gt;
&lt;li&gt;类的构造函数和析构函数；&lt;/li&gt;
&lt;li&gt;const 成员函数；&lt;/li&gt;
&lt;li&gt;this 指针；&lt;/li&gt;
&lt;li&gt;创建对象数组；&lt;/li&gt;
&lt;li&gt;类作用域；&lt;/li&gt;
&lt;li&gt;抽象数据类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面向对象编程（OOP）是一种特殊的、设计程序的概念性方法，OOP的最终特性是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象；&lt;/li&gt;
&lt;li&gt;封装和数据隐藏；&lt;/li&gt;
&lt;li&gt;多态；&lt;/li&gt;
&lt;li&gt;继承；&lt;/li&gt;
&lt;li&gt;代码的可重用性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了实现这些特性并将它们组合在一起，C++所做的最重要的改进 是提供了类。&lt;/p&gt;
&lt;h2 id=&#34;101-过程性编程和面向对象编程&#34;&gt;10.1 过程性编程和面向对象编程&lt;/h2&gt;
&lt;p&gt;采用过程性编程方法时，首先考虑要遵循的步骤，然后考虑 如何表示这些数据。&lt;br&gt;
如果换成一位OOP程序员，又将如何呢？首先考虑数据——不仅要 考虑如何表示数据，还要考虑如何使用数据。&lt;br&gt;
用户与数据交互的方式有三种：初始化、更新和报告——这就是用户接口。&lt;/p&gt;
&lt;p&gt;总之，采用OOP方法时，首先从用户的角度考虑对象——描述对象 所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述 后，需要确定如何实现接口和数据存储。最后，使用新的设计方案创建 出程序。&lt;/p&gt;
&lt;h2 id=&#34;102-抽象和类&#34;&gt;10.2 抽象和类&lt;/h2&gt;
&lt;p&gt;生活中充满复杂性，处理复杂性的方法之一是简化和抽象。&lt;/p&gt;
&lt;h3 id=&#34;1021-类型是什么&#34;&gt;10.2.1 类型是什么&lt;/h3&gt;
&lt;p&gt;首先，倾向于根 据数据的外观（在内存中如何存储）来考虑数据类型。但是稍加思索就会 发现，也可以根据要对它执行的操作来定义数据类型。总之，指定基本类型完成了三项工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;决定数据对象需要的内存数量；&lt;/li&gt;
&lt;li&gt;决定如何解释内存中的位（&lt;code&gt;long&lt;/code&gt; 和 &lt;code&gt;float&lt;/code&gt;在内存中占用的位数相同，但将它们转换为数值的方法不同）；&lt;/li&gt;
&lt;li&gt;决定可使用数据对象执行的操作或方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1022-c中的类&#34;&gt;10.2.2 C++中的类&lt;/h3&gt;
&lt;p&gt;类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和 操纵数据的方法组合成一个整洁的包。&lt;/p&gt;
&lt;p&gt;定义类时，一般来说，类规范由两个部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类声明：以数据成员的方式描述数据部分，以成员函数（称为方法）的方式描述共有接口；&lt;/li&gt;
&lt;li&gt;类方法定义：描述如何类成员函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单地说，类声明提供了类的蓝图，而方法定义则提供了细节。例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// stock00.h -- Stock class interface
// version 00
#ifndef STOCK00_H_
#define STOCK00_H_

#include &amp;lt;string&amp;gt;

class Stock  // class declaration
{
private:
    std::string company;
    long shares;
    double share_val;
    double total_val;
    void set_tot() { total_val = shares * share_val; }
public:
    void acquire(const std::string &amp;amp; co, long n, double pr);
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    void show();
};    // note semicolon at the end

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先， C++关键字class指出这些代码定义了一个类设计。&lt;/p&gt;
&lt;p&gt;1．访问控制&lt;/p&gt;
&lt;p&gt;关键字 &lt;code&gt;private&lt;/code&gt; 和 &lt;code&gt;public&lt;/code&gt; 也是新的，它们描述了对类成员的访问控制。使用类对象的程序都可以直接访问公有部分，但只能通过公有成员 函数（或友元函数，参见第11章）来访问对象的私有成员。&lt;/p&gt;
&lt;p&gt;因此，公有成员函 数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏（参见图10.1）。C++还提 供了第三个访问控制关键字protected，第13章介绍类继承时将讨论该关 键字。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;149&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811220839703.png&#34; alt=&#34;image-20210811220839703&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;类设计尽可能将公有接口与实现细节分开。公有接口表示设计的抽 象组件。**将实现细节放在一起并将它们与抽象分开被称为封装。**数据隐藏（将数据放在类的私有部分中）是一种封装，将实现的细节隐藏在私 有部分中，就像&lt;code&gt;Stock&lt;/code&gt;类对&lt;code&gt;set_tot()&lt;/code&gt; 所做的那样，也是一种封装。封装的 另一个例子是，将类函数定义和类声明放在不同的文件中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OOP是一种编程风格，从某种程度说，它用于任何一种语言中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据隐藏不仅可以防止直接访问数据，还让开发者（类的用户）无需了解数据是如何被表示的。从使用类的角度看，使用哪种方 法没有什么区别。所需要知道的只是各种成员函数的功能；也就是说，需要知道成员函数接受什么样的参数以及返回什么类型的值。原则是将实现细节从接口设计中分离出来。如果以后找到了更好的、实现数据表 示或成员函数细节的方法，可以对这些细节进行修改，而无需修改程序接口，这使程序维护起来更容易。&lt;/p&gt;
&lt;p&gt;2．控制对成员的访问：公有还是私有&lt;/p&gt;
&lt;p&gt;无论类成员是数据成员还是成员函数，都可以在类的公有部分或私 有部分中声明它。但由于隐藏数据是OOP主要的目标之一，因此数据项 通常放在私有部分，组成类接口的成员函数放在公有部分；否则，就无 法从程序中调用这些函数。&lt;/p&gt;
&lt;h3 id=&#34;1023-实现类成员函数&#34;&gt;10.2.3 实现类成员函数&lt;/h3&gt;
&lt;p&gt;还需要创建类描述的第二部分：为那些由类声明中的原型表示的成 员函数提供代码。成员函数定义与常规函数定义非常相似，它们有函数 头和函数体，也可以有返回类型和参数。但是它们还有两个特殊的特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义成员函数时，使用作用域解析运算符 &lt;code&gt;::&lt;/code&gt; 来标识函数所属的类；&lt;/li&gt;
&lt;li&gt;类方法可以访问类的 &lt;code&gt;private&lt;/code&gt; 组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;void Stock::update(double price) {
    ....
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作用域解析运算符确定了方法定义对应的类的身份。&lt;/p&gt;
&lt;p&gt;类方法的第二个特点是，方法可以直接访问类的私有成员，&lt;strong&gt;如同访问一个已经声明好的常用变量一样&lt;/strong&gt;。例如，show( ) 方法可以使用这样的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;
void Stock::show()
{
    std::cout &amp;lt;&amp;lt; &amp;quot;Company: &amp;quot; &amp;lt;&amp;lt; company
              &amp;lt;&amp;lt; &amp;quot;  Shares: &amp;quot; &amp;lt;&amp;lt; shares &amp;lt;&amp;lt; &#39;\n&#39;
              &amp;lt;&amp;lt; &amp;quot;  Share Price: $&amp;quot; &amp;lt;&amp;lt; share_val
              &amp;lt;&amp;lt; &amp;quot;  Total Worth: $&amp;quot; &amp;lt;&amp;lt; total_val &amp;lt;&amp;lt; &#39;\n&#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，company、shares等都是Stock类的私有数据成员。&lt;/p&gt;
&lt;p&gt;另外，类声明常将短小的成员函数作为内联函数在头文件中随类声明一起定义。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内联函数的特殊规则要求在每个使用它们的文件中都对其进行定 义。确保内联定义对多文件程序中的所有文件都可用的、最简便的方法是：&lt;strong&gt;将内联定义放在定义类的头文件中&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;所创建的每个新对象都有自己的存储空间，用于存储其内部变量和 类成员；但同一个类的所有对象共享同一组类方法，即每种方法只有一 个副本&lt;/strong&gt;。例如，假设 &lt;code&gt;kate&lt;/code&gt; 和 &lt;code&gt;joe&lt;/code&gt; 都是 &lt;code&gt;Stock&lt;/code&gt; 对象，则 &lt;code&gt;kate.shares&lt;/code&gt; 将占据一个 内存块，而 &lt;code&gt;joe.shares&lt;/code&gt; 占用另一个内存块，但&lt;code&gt;kate.show()&lt;/code&gt; 和 &lt;code&gt;joe.show()&lt;/code&gt; 都调用同一个方法，也就是说，&lt;strong&gt;它们将执行同一个代码块&lt;/strong&gt;，只是将这些代码用于不同的数据。在OOP中，调用成员函数被称为发送消息，因此将 同样的消息发送给两个不同的对象将调用同一个方法，但该方法被用于两个不同的对象。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;150&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811222542618.png&#34; alt=&#34;image-20210811222542618&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1024-使用类&#34;&gt;10.2.4 使用类&lt;/h3&gt;
&lt;p&gt;使用类与使用基本的内置类型（如int和char）尽可能相同。要创建类对象，可以声明类变量，也可以使用 &lt;code&gt;new&lt;/code&gt; 为类对象分配存储空间。可以将对象作为函数的参数和返回值，也可以将一个对象赋给另一个。&lt;/p&gt;
&lt;p&gt;要使用新类型，最关键的是要了解成员函数的功能，而不必考虑 其实现细节。&lt;/p&gt;
&lt;h3 id=&#34;1025-修改实现&#34;&gt;10.2.5 修改实现&lt;/h3&gt;
&lt;h3 id=&#34;1026-小结&#34;&gt;10.2.6 小结&lt;/h3&gt;
&lt;p&gt;指定类设计的第一步是提供类声明。类声明类似结构声明，可以包 括数据成员和函数成员。声明有私有部分，在其中声明的成员只能通过 成员函数进行访问；声明还具有公有部分，在其中声明的成员可被使用 类对象的程序直接访问。通常，数据成员被放在私有部分中，成员函数 被放在公有部分中，因此典型的类声明的格式如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;151&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811223153090.png&#34; alt=&#34;image-20210811223153090&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;103-类的构造函数和析构函数&#34;&gt;10.3 类的构造函数和析构函数&lt;/h2&gt;
&lt;p&gt;C++的目标之一是让使用类对象就像使用标准类型一样。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;152&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811223501009.png&#34; alt=&#34;image-20210811223501009&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一般来说，最好是在创建对象时对它进行初始化。&lt;/p&gt;
&lt;p&gt;就Stock类当前的实现而言，gift对象的company成员是没有值的。 类设计假设用户在调用任何其他成员函数之前调用acquire( )，但无法强 加这种假设。避开这种问题的方法之一是在创建对象时，自动对它进行 初始化。为此，C++提供了一个特殊的成员函数——类构造函数，专门 用于构造新对象、将值赋给它们的数据成员。名称与类名相同。例如，Stock类一个可能的构造函数是名为Stock( )的成员函 数。&lt;strong&gt;构造函数的原型和函数头有一个有趣的特征——虽然没有返回值， 但没有被声明为void类型。实际上，构造函数没有声明类型&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// stock10.h &amp;lt;96&amp;gt; Stock class declaration with constructors, destructor added
#ifndef STOCK1_H_
#define STOCK1_H_
#include &amp;lt;string&amp;gt;
class Stock
{
private:
    std::string company;
    long shares;
    double share_val;
    double total_val;
    void set_tot() { total_val = shares * share_val; }
public:
    Stock();        // default constructor
    Stock(const std::string &amp;amp; co, long n = 0, double pr = 0.0);  // reload constructor;
    ~Stock();       // noisy destructor
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    void show();
};

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;程序声明对 象时，将自动调用构造函数。&lt;/p&gt;
&lt;h3 id=&#34;1031-声明和定义构造函数&#34;&gt;10.3.1 声明和定义构造函数&lt;/h3&gt;
&lt;p&gt;通常定义两个构造函数：一个默认空参数，在未提供显式初始值时，用来创建对象；另一个则提供对私有变量做初始化的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// stock1.cpp &amp;lt;96&amp;gt; Stock class implementation with constructors, destructor added
#include &amp;lt;iostream&amp;gt;
#include &amp;quot;stock10.h&amp;quot;

// constructors (verbose versions)
Stock::Stock()        // default constructor
{
    std::cout &amp;lt;&amp;lt; &amp;quot;Default constructor called\n&amp;quot;;
    company = &amp;quot;no name&amp;quot;;
    shares = 0;
    share_val = 0.0;
    total_val = 0.0;
}

Stock::Stock(const std::string &amp;amp; co, long n, double pr)
{
    std::cout &amp;lt;&amp;lt; &amp;quot;Constructor using &amp;quot; &amp;lt;&amp;lt; co &amp;lt;&amp;lt; &amp;quot; called\n&amp;quot;;
    company = co;

    if (n &amp;lt; 0)
    {
        std::cout &amp;lt;&amp;lt; &amp;quot;Number of shares can&#39;t be negative; &amp;quot;
                   &amp;lt;&amp;lt; company &amp;lt;&amp;lt; &amp;quot; shares set to 0.\n&amp;quot;;
        shares = 0;
    }
    else
        shares = n;
    share_val = pr;
    set_tot();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;1032-使用构造函数&#34;&gt;10.3.2 使用构造函数&lt;/h3&gt;
&lt;p&gt;C++提供了两种使用构造函数来初始化对象的方式。第一种方式是 显式地调用构造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;
Stock food = Stock(&amp;quot;World Cabbage&amp;quot;, 250, 1.25);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种方式是隐式地调用构造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;Stock garment(&amp;quot;Furry Mason&amp;quot;, 50, 2.5);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种格式更紧凑，它与下面的显式调用等价。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;Stock garment = Stock(&amp;quot;Furry Mason&amp;quot;, 50, 2.5);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每次创建类对象（包括使用 &lt;code&gt;new&lt;/code&gt; 动态分配内存）时，C++都使用类构造函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;Stock *pstock = new Stock(&amp;quot;Electrosgock Games&amp;quot;, 18. 19.0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这条语句创建一个Stock对象，将其初始化为参数提供的值，并将 该对象的地址赋给pstock指针&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但无法使用对象来调用构造函数，因为在构造函数构造出对象之 前，对象是不存在的&lt;/strong&gt;。因此构造函数被用来创建对象，而不能通过对象来调用。&lt;/p&gt;
&lt;h3 id=&#34;1033-默认构造函数&#34;&gt;10.3.3 默认构造函数&lt;/h3&gt;
&lt;p&gt;默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。如果没有提供任何构造函数，则C++将自动提供默认构造函数。它是默认构造函 数的隐式版本，不做任何工作。对于Stock类来说，默认构造函数可能 如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;Stock::Stock() {};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当且仅当没有定义任何构造函数时，编译器才会提供默 认构造函数。为类定义了构造函数后，程序员就必须为它提供默认构造 函数。如果提供了非默认构造函数（如Stock(const char * co, int n, double pr)），但没有提供默认构造函数，则下面的声明将出错：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;Stock stock1;   // 没有合适的构造函数用于构造对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定义默认构造函数的方式有两种。一种是给已有构造函数的所 有参数提供默认值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;Stock(const string &amp;amp;co = &amp;quot;Error&amp;quot;, int n=0, double pr=0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种方式是通过函数重载来定义另一个构造函数——一个没有参 数的构造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;Stock();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用户定义的默认构造函数通常给所有成员提供隐式初始值。&lt;/p&gt;
&lt;h3 id=&#34;1034-析构函数&#34;&gt;10.3.4 析构函数&lt;/h3&gt;
&lt;p&gt;用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。 对象过期时，程序将自动调用一个特殊的成员函数，该函数称为析构函数。析构函数很有用，用于对象过期时的完成清理工作。例 如，如果构造函数使用new来分配内存，则析构函数将使用delete来释放 这些内存。Stock的构造函数没有使用new，因此析构函数实际上没有需 要完成的任务。在这种情况下，只需让编译器生成一个什么要不做的隐式析构函数即可。&lt;/p&gt;
&lt;p&gt;析构函数的名称很特殊：在类名前加上&lt;code&gt;~&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此，&lt;code&gt;Stock&lt;/code&gt; 类的析构函数为 &lt;code&gt;~Stock()&lt;/code&gt;。另外，和构造函数一样，&lt;strong&gt;析构函数也可以没有返回值和声明类型。与构造函数不同的是，析构函数没有参数&lt;/strong&gt;，因此 &lt;code&gt;Stock&lt;/code&gt; 析构函数的原型 &lt;strong&gt;必须&lt;/strong&gt; 是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;~Stock();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;什么时候应调用析构函数呢？这由编译器决定，通常不应在代码中 显式地调用析构函数。如果创建的是静态存储类对象，则其析构函数将在程序结束 时自动被调用。如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时（该对象是在其中定义 的）自动被调用。如果对象是通过new创建的，则它将驻留在栈内存或 自由存储区中，当使用delete来释放内存时，其析构函数将自动被调 用。最后，程序可以创建临时对象来完成特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。&lt;/p&gt;
&lt;h3 id=&#34;1035-改进-stock-类&#34;&gt;10.3.5 改进 &lt;code&gt;Stock&lt;/code&gt; 类&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// usestok1.cpp -- using the Stock class
// compile with stock10.cpp
#include &amp;lt;iostream&amp;gt;
#include &amp;quot;stock10.h&amp;quot;

int main()
{
  {
    using std::cout;
    cout &amp;lt;&amp;lt; &amp;quot;Using constructors to create new objects\n&amp;quot;;
    Stock stock1(&amp;quot;NanoSmart&amp;quot;, 12, 20.0);            // syntax 1
    stock1.show();
    Stock stock2 = Stock (&amp;quot;Boffo Objects&amp;quot;, 2, 2.0); // syntax 2
    stock2.show();

    cout &amp;lt;&amp;lt; &amp;quot;Assigning stock1 to stock2:\n&amp;quot;;
    stock2 = stock1;
    cout &amp;lt;&amp;lt; &amp;quot;Listing stock1 and stock2:\n&amp;quot;;
    stock1.show();
    stock2.show();

    cout &amp;lt;&amp;lt; &amp;quot;Using a constructor to reset an object\n&amp;quot;;
    stock1 = Stock(&amp;quot;Nifty Foods&amp;quot;, 10, 50.0);    // temp object
    cout &amp;lt;&amp;lt; &amp;quot;Revised stock1:\n&amp;quot;;
    stock1.show();
    cout &amp;lt;&amp;lt; &amp;quot;Done\n&amp;quot;;
  }
    // std::cin.get();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面的语句表明可以将一个对象赋给同类型的另一个对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;stock2 = stock1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在默认情况下，&lt;strong&gt;将一个对象赋给同类型的另一个对象时，C++将源对象的每个数据成员的内容复制到目标对象中相应的数据成员中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;构造函数不仅仅可用于初始化新对象。例如，该程序的&lt;code&gt;main( )&lt;/code&gt; 中包含下面的语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;stock1 = Stock(&amp;quot;Nifty Foods&amp;quot;, 10, 50.0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;stock1对象已经存在，因此这条语句不是对stock1进行初始化，而 是将新值赋给它。这是通过让构造程序创建一个新的、临时的对象，然后将其内容复制给 &lt;code&gt;stock1&lt;/code&gt; 来实现的。临时对象复制完成之后，程序调用析构函数，删除该临时对象。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;153&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811230556935.png&#34; alt=&#34;image-20210811230556935&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;输出表明，下面两条语句有根本性的差别：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;Stock stock2 = Stock(&amp;quot;Boffo Objects&amp;quot;, 2, 2.0);
stock1 = Stock(&amp;quot;Nifty Foods&amp;quot;, 10, 50.0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第一条语句是初始化，它创建有指定值的对象，可能会创建临时对象（也可能不会）；第二条语句是赋值。像这样在赋值语句中使用构造函数总会导致在赋值前创建一个临时对象&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果既可以通过初始化，也可以通过赋值来设置对象的值，则应采用初始化方式。通常这种 方式的效率更高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;6．&lt;code&gt;const&lt;/code&gt; 成员函数&lt;/p&gt;
&lt;p&gt;请看下面的代码片段：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;const Stock land = Stock(&amp;quot;KP&amp;quot;, 0, 0.0);
land.show();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于当前的C++来说，编译器将拒绝第二行。这是什么原因呢？因为 &lt;code&gt;show()&lt;/code&gt; 的代码无法确保调用对象不被修改。&lt;/p&gt;
&lt;p&gt;我们以前通过将函数参数声明为 &lt;code&gt;const&lt;/code&gt; 引用或指向 &lt;code&gt;const&lt;/code&gt; 的指针来解决这种问题。但这里存在语法问题：&lt;code&gt;show()&lt;/code&gt; 方法没有任何参数。相反，它所使用的对象是由方法调用隐式地提供。&lt;/p&gt;
&lt;p&gt;需要一种新的语法来保证函数不会修改调用对象。&lt;strong&gt;C++的解决方法是将 &lt;code&gt;const&lt;/code&gt; 关键字放在函数的括号后面&lt;/strong&gt;。也就是说，&lt;code&gt;show()&lt;/code&gt; 声明应像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;void show() const;         // promise not to change invoking object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样，函数定义的开头应像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;void stock::show() const {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;以这种方式声明和定义的类函数被称为 &lt;code&gt;const&lt;/code&gt; 成员函数&lt;/strong&gt;，从而确保函数内不会修改调用对象。&lt;/p&gt;
&lt;h3 id=&#34;1036-构造函数和析构函数小结&#34;&gt;10.3.6 构造函数和析构函数小结&lt;/h3&gt;
&lt;p&gt;构造函数是一种特殊的类成员函数，在创建类对象时被调用。构造 函数的名称和类名相同，但通过函数重载，可以创建多个同名的构造函 数，条件是每个函数的特征标（参数列表）都不同。另外，构造函数没 有声明类型。通常，构造函数用于初始化类对象的成员，初始化应与构 造函数的参数列表匹配。&lt;/p&gt;
&lt;p&gt;默认构造函数没有参数，因此如果创建对象时没有进行显式地初始 化，则将调用默认构造函数。如果程序中没有提供任何构造函数，则编 译器会为程序定义一个默认构造函数；否则，必须自己提供默认构造函 数。默认构造函数可以没有任何参数；如果有，则必须给所有参数都提供默认值。&lt;/p&gt;
&lt;p&gt;当对象被删除时，程 序将调用析构函数。每个类都只能有一个析构函数。析构函数没有返回 类型（连 &lt;code&gt;void&lt;/code&gt; 都没有），也没有参数，其名称为类名称前加上 &lt;code&gt;~&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果构造函数使用了 &lt;code&gt;new&lt;/code&gt;，则必须提供使用 &lt;code&gt;delete&lt;/code&gt; 的析构函数。&lt;/p&gt;
&lt;h2 id=&#34;104-this-指针&#34;&gt;10.4 this 指针&lt;/h2&gt;
&lt;p&gt;有时候类方法可能涉及到两个对象，在这种情况下需要使用 &lt;code&gt;this&lt;/code&gt; 指针。&lt;/p&gt;
&lt;p&gt;如何将方法的答案传回给调用程序呢？最直接的方法是让方法返回一个引用，该引用指向股价总值较高的对象。因此，用于比较的类方法 &lt;code&gt;topval&lt;/code&gt; 的原型如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;const Stock &amp;amp; topval(const Stock &amp;amp;s) const;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该函数隐式地访问一个对象，而显式地访问另一个对象，并返回其 中一个对象的引用。括号中的&lt;code&gt;const&lt;/code&gt; 表明，该函数不会修改被显式地访问的对象；而括号后的 &lt;code&gt;const&lt;/code&gt; 表明，该函数不会修改被隐式地访问的对象。 由于该函数返回了两个 &lt;code&gt;const&lt;/code&gt; 对象之一的引用，因此返回类型也应为 &lt;code&gt;const&lt;/code&gt; 引用。&lt;/p&gt;
&lt;p&gt;比较之后，返回引用时有一个问题需要解决：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;154&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811232755584.png&#34; alt=&#34;image-20210811232755584&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;C++解决这种问题的方法是：使用被称为 &lt;code&gt;this&lt;/code&gt; 的特殊指针。&lt;code&gt;this&lt;/code&gt; 指针指向用来调用成员函数的对象（&lt;code&gt;this&lt;/code&gt;被作为隐藏参数传递给方法）。这样，函数调用 &lt;code&gt;stock1.topval(stock2)&lt;/code&gt; 将 &lt;code&gt;this&lt;/code&gt; 设置为 &lt;code&gt;stock1&lt;/code&gt; 对象的地址，使得这个指针可用于 &lt;code&gt;topval()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;一般来说，所有的类方法都将 &lt;code&gt;this&lt;/code&gt; 指针设置为调用它的对象的地址。而 &lt;code&gt;topval()&lt;/code&gt; 中的 &lt;code&gt;total_val&lt;/code&gt; 只不过是 &lt;code&gt;this-&amp;gt;total_val&lt;/code&gt; 的简写。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;155&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811233043535.png&#34; alt=&#34;image-20210811233043535&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;const Stock &amp;amp; Stock::topval(const Stock &amp;amp; s) const
{
    if (s.total_val &amp;gt; total_val)
        return s;
    else
        return *this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;105-对象数组&#34;&gt;10.5 对象数组&lt;/h2&gt;
&lt;p&gt;声明对象数组的方法与 声明标准类型数组相同。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;Stock mystuff[4];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以用构造函数来初始化数组元素。在这种情况下，必须为每个元 素调用构造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;/ create an array of initialized objects
    Stock stocks[4] = {
        Stock(&amp;quot;NanoSmart&amp;quot;, 12, 20.0),
        Stock(&amp;quot;Boffo Objects&amp;quot;, 200, 2.0),
        Stock(&amp;quot;Monolithic Obelisks&amp;quot;, 130, 3.25),
        Stock(&amp;quot;Fleep Enterprises&amp;quot;, 60, 6.5)
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的代码使用标准格式对数组进行初始化：用括号括起的、以逗 号分隔的值列表。其中，每次构造函数调用表示一个值。如果类包含多 个构造函数，则可以对不同的元素使用不同的构造函数。&lt;/p&gt;
&lt;h2 id=&#34;106-类作用域&#34;&gt;10.6 类作用域&lt;/h2&gt;
&lt;p&gt;在类中定义的名称（如类数据成员名和类成员函数名）的作用域都 为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可 知的。因此，可以在不同类中使用相同的类成员名而不会引起冲突。&lt;/p&gt;
&lt;p&gt;总之，在类声明或成员函数定义中，可以使用未修饰的成员名称 （未限定的名称），就像&lt;code&gt;sell( )&lt;/code&gt; 调用 &lt;code&gt;set_tot()&lt;/code&gt; 成员函数时那样。构造函数名称在被调用时，才能被识别，因为它的名称与类名相同。在其他情况下，使用类成员名时，必须根据上下文使用直接成员运算符、间接成员运算符 &lt;code&gt;-&amp;gt;&lt;/code&gt; 或作用域解析运算符 &lt;code&gt;::&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;156&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210811235956703.png&#34; alt=&#34;image-20210811235956703&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1061-作用域为类的常量&#34;&gt;10.6.1 作用域为类的常量&lt;/h3&gt;
&lt;p&gt;有时候，使符号常量的作用域为类很有用。例如，类声明可能使用 字面值30来指定数组的长度，由于该常量对于所有对象来说都是相同 的，因此创建一个由所有对象共享的常量是个不错的主意。你以为可以这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;class Bakery {
private:
    const int Months = 12;
    double costs[Months];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但&lt;strong&gt;这是不行的&lt;/strong&gt;！！ 因为声明类只是描述了对象的形式，并没有创建对象。&lt;/p&gt;
&lt;p&gt;C++提供了另一种在类中定义常量的方式——使用关键字 &lt;code&gt;static&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;class Bakery {
private:
    static const int Months = 12;
    double costs[Months];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;1062-作用域内枚举c11&#34;&gt;10.6.2 作用域内枚举（C++11）&lt;/h3&gt;
&lt;h3 id=&#34;107-抽象数据类型&#34;&gt;10.7 抽象数据类型&lt;/h3&gt;
&lt;h3 id=&#34;108-总结&#34;&gt;10.8 总结&lt;/h3&gt;
&lt;p&gt;面向对象编程强调的是程序如何表示数据。使用OOP方法解决编程问题的第一步是根据它与程序之间的接口来描述数据，从而指定如何使 用数据。然后，设计一个类来实现该接口。&lt;/p&gt;
&lt;p&gt;通常，将类声明分成两部分组成，这两部分通常保存在不同的文件 中。类声明（包括由函数原型表示的方法）应放到头文件中。定义成员 函数的源代码放在方法文件中。这样便将接口描述与实现细节分开了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类是用户定义的类型，对象是类的实例&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;每个对象都存储自己的数据，而共享类方法。&lt;/p&gt;
&lt;p&gt;如果希望成员函数对多个对象进行操作，可以将额外的对象作为参数传递给它。如果方法需要显式地引用调用它的对象，则可以使用 &lt;code&gt;this&lt;/code&gt; 指针。&lt;code&gt;this&lt;/code&gt; 指针被设置为调用对象的地址，因此&lt;code&gt;*this&lt;/code&gt; 是该对象的别名。&lt;/p&gt;
&lt;h1 id=&#34;第十一章-使用类&#34;&gt;第十一章 使用类&lt;/h1&gt;
&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运算符重载；&lt;/li&gt;
&lt;li&gt;友元函数；&lt;/li&gt;
&lt;li&gt;重载 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 运算符，以便用于输出；&lt;/li&gt;
&lt;li&gt;状态成员；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;rand()&lt;/code&gt; 生成随机值；&lt;/li&gt;
&lt;li&gt;类的自动转换和强制类型转换；&lt;/li&gt;
&lt;li&gt;类转换函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;学习C++的难点之一是需要记住大量的东西，但在拥有丰富的实践 经验之前，根本不可能全部记住这些东西。从这种意义上说，学习 C++ 就像学习功能复杂的字处理程序或电子制表程序一样。任何特性都不可怕，但多数人只掌握了那些经常使用的特性，如查找文本或设置为 斜体等。您可能在那里曾经学过如何生成替换字符或者创建目录，除非经常使用它们，否则这些技能可能根本与日常工作无关。也许，学习本 章知识的最好方法是，在我们自己开发的C++程序中使用其中的新特性。&lt;/p&gt;
&lt;h2 id=&#34;111-运算符重载&#34;&gt;11.1 运算符重载&lt;/h2&gt;
&lt;p&gt;运算符重载是一种形式的 C++ 多态。&lt;br&gt;
运算符 重载将重载的概念扩展到运算符上，允许赋予C++运算符多种含义。实 际上，很多C++（也包括C语言）运算符已经被重载。例如，将 &lt;code&gt;*&lt;/code&gt; 运算符用于地址，将得到存储在这个地址中的值；但将它用于两个数字时，得到的将是它们的乘积。C++根据操作数的数目和类型来决定采用哪种操 作。&lt;/p&gt;
&lt;p&gt;重载运算符可使代码看起来更自然。&lt;/p&gt;
&lt;p&gt;要重载运算符，需使用被称为运算符函数的特殊函数形式。运算符函数的格式为：&lt;code&gt;operatorop(argument-list)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;operator +()&lt;/code&gt; 重载 &lt;code&gt;+&lt;/code&gt; 运算符，&lt;code&gt;operator *()&lt;/code&gt; 重载 &lt;code&gt;*&lt;/code&gt; 运算符。&lt;code&gt;op&lt;/code&gt; 必须是有效的C++运算符，不能虚构一个新的符号。例如，不能有 &lt;code&gt;operator@()&lt;/code&gt; 这样的函数，因为C++中没有 &lt;code&gt;@&lt;/code&gt; 运算符。然而，&lt;code&gt;operator&lt;/code&gt; 函数可以重载 &lt;code&gt;[]&lt;/code&gt; 运算符，因为 &lt;code&gt;[]&lt;/code&gt; 是数组索引运算符。&lt;/p&gt;
&lt;h2 id=&#34;112-计算时间一个运算符重载示例&#34;&gt;11.2 计算时间：一个运算符重载示例&lt;/h2&gt;
&lt;p&gt;定义一个 &lt;code&gt;Time&lt;/code&gt; 类:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// mytime0.h -- Time class before operator overloading
#ifndef MYTIME0_H_
#define MYTIME0_H_

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time Sum(const Time &amp;amp; t) const;
    void Show() const;
};
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该类的定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;quot;mytime0.h&amp;quot;

Time::Time()
{
    hours = minutes = 0;
}

Time::Time(int h, int m )
{
    hours = h;
    minutes = m;
}

void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}

void Time::AddHr(int h)
{
    hours += h;
}

void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}

Time Time::Sum(const Time &amp;amp; t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}

void Time::Show() const
{
    std::cout &amp;lt;&amp;lt; hours &amp;lt;&amp;lt; &amp;quot; hours, &amp;quot; &amp;lt;&amp;lt; minutes &amp;lt;&amp;lt; &amp;quot; minutes&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;来看一下 &lt;code&gt;Sum()&lt;/code&gt; 函数的代码。注意参数是引用，但返回类型却不是 引用。将参数声明为引用的目的是为了提高效率。如果按值传递 &lt;code&gt;Time&lt;/code&gt; 对象，代码的功能将相同，但传递引用，速度将更快，使用的内存将更少。&lt;/p&gt;
&lt;p&gt;然而，返回值不能是引用。因为函数将创建一个新的Time对象 （sum），来表示另外两个Time对象的和。返回对象（如代码所做的那 样）将创建对象的副本，而调用函数可以使用它。然而，如果返回类型 为 &lt;code&gt;Time &amp;amp;&lt;/code&gt;，则引用的将是 &lt;code&gt;sum&lt;/code&gt; 对象。但由于 &lt;code&gt;sum&lt;/code&gt; 对象是局部变量，在函数结束时将被删除，因此引用将指向一个不存在的对象。使用返回类型 &lt;code&gt;Time&lt;/code&gt; 意味着程序将在删除 &lt;code&gt;sum&lt;/code&gt; 之前构造它的拷贝，调用函数将得到该拷贝。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不要返回指向局部变量或临时对象的引用。函数执行完毕后，局部变量和临时对象将消失， 引用将指向不存在的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但这种 sum 时间的方法看起来很傻。&lt;/p&gt;
&lt;h3 id=&#34;1121-添加加法运算符&#34;&gt;11.2.1 添加加法运算符&lt;/h3&gt;
&lt;p&gt;将Time类转换为重载的加法运算符很容易，只要将&lt;code&gt;Sum()&lt;/code&gt; 的名称改为 &lt;code&gt;operator +()&lt;/code&gt; 即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// mytime1.h -- Time class before operator overloading
#ifndef MYTIME1_H_
#define MYTIME1_H_

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time operator+ (const Time &amp;amp; t) const;
    void Show() const;
};
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类定义中改为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// mytime1.cpp  -- implementing Time methods
#include &amp;lt;iostream&amp;gt;
#include &amp;quot;mytime1.h&amp;quot;
...
Time Time::operator+(const Time &amp;amp; t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将该方法命令改为 &lt;code&gt;operator +()&lt;/code&gt; 后，就可以使用运算符表示法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;total = coding + fixing;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// usetime1.cpp -- using the second draft of the Time class
// compile usetime1.cpp and mytime1.cpp together
#include &amp;lt;iostream&amp;gt;
#include &amp;quot;mytime1.h&amp;quot;

int main()
{
    using std::cout;
    using std::endl;
    Time planning;
    Time coding(2, 40);
    Time fixing(5, 55);
    Time total;

    total = coding + fixing;
    cout &amp;lt;&amp;lt; &amp;quot;coding + fixing = &amp;quot;;
    total.Show();
    cout &amp;lt;&amp;lt; endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;1122-重载限制&#34;&gt;11.2.2 重载限制&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;157&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812010750643.png&#34; alt=&#34;image-20210812010750643&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;多数C++运算符（参见表11.1）都可以用这样的方式重载。重载的运算符（有些例外情况）不必是成员函数，但必须至少有一个操作数是 用户定义的类型。下面详细介绍C++对用户定义的运算符重载的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1．重载后的运算符&lt;strong&gt;必须至少有一个操作数是用户定义的类型&lt;/strong&gt;，这将防止用户为标准类型重载运算符；&lt;/li&gt;
&lt;li&gt;2．使用运算符时不能违反运算符原来的句法规则。例如不要将 &lt;code&gt;-&lt;/code&gt; 重载为加法运算。同样，不能修改运算符的优先级；&lt;/li&gt;
&lt;li&gt;3．不能创建新运算符。例如，不能定义 &lt;code&gt;operator **()&lt;/code&gt; 函数来表示求幂；&lt;/li&gt;
&lt;li&gt;4．不能重载下面的运算符：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;158&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812010658117.png&#34; alt=&#34;image-20210812010658117&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;5．表11.1中的大多数运算符都可以通过成员或非成员函数进行重 载，但下面的运算符只能通过成员函数进行重载。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;159&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812010824269.png&#34; alt=&#34;image-20210812010824269&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1123-其他重载运算符&#34;&gt;11.2.3 其他重载运算符&lt;/h3&gt;
&lt;p&gt;还有一些其他的操作对 &lt;code&gt;Time&lt;/code&gt; 类来说是有意义的。例如，可能要将两个时间相减或将时间乘以一个因子，这需要重载减法和乘法运算符。这 和重载加法运算符采用的技术相同，即创建 &lt;code&gt;operator –()&lt;/code&gt; 和 &lt;code&gt;operator *()&lt;/code&gt; 方法。也就是说，将下面的原型添加到类声明中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;Time operator- (const time &amp;amp; t) const;
Time operator* (double n) const;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改类定义：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// mytime2.cpp  -- implementing Time methods
#include &amp;lt;iostream&amp;gt;
#include &amp;quot;mytime2.h&amp;quot;

...
Time Time::operator-(const Time &amp;amp; t) const
{
    Time diff;
    int tot1, tot2;
    tot1 = t.minutes + 60 * t.hours;
    tot2 = minutes + 60 * hours;
    diff.minutes = (tot2 - tot1) % 60;
    diff.hours = (tot2 - tot1) / 60;
    return diff;
}

Time Time::operator*(double mult) const
{
    Time result;
    long totalminutes = hours * mult * 60 + minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;113-友元&#34;&gt;11.3 友元&lt;/h2&gt;
&lt;p&gt;通常，公有类方法提 供唯一的访问途径，但是有时候这种限制太严格，以致于不适合特定的 编程问题。在这种情况下，C++提供了另外一种形式的访问权限：友 元。友元有3种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;友元函数；&lt;/li&gt;
&lt;li&gt;友元类；&lt;/li&gt;
&lt;li&gt;友元成员函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。&lt;/p&gt;
&lt;p&gt;需要友元的原因是为了解决这样一个问题：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;160&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812011654884.png&#34; alt=&#34;image-20210812011654884&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;161&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812011808963.png&#34; alt=&#34;image-20210812011808963&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;对于非成员重载运算符函数来说，&lt;strong&gt;运算符表达式左边的操作数对应于运算符函数的第一个参数，运算符表达式右边的操作数对应于运算符函数的第二个参数&lt;/strong&gt;。而原来的成员函数则按相反的顺序处理操作数，也就是说，double值乘以Time值。&lt;/p&gt;
&lt;p&gt;使用非成员函数可以按所需的顺序获得操作数（先是double，然后 是Time），但引发了一个新问题：&lt;strong&gt;非成员函数不能直接访问类的私有数据，至少常规非成员函数不能访问&lt;/strong&gt;。然而，有一类特殊的&lt;em&gt;非成员函数&lt;/em&gt;可以访问类的私有成员，它们被称为友元函数。&lt;/p&gt;
&lt;h3 id=&#34;1131-创建友元&#34;&gt;11.3.1 创建友元&lt;/h3&gt;
&lt;p&gt;创建友元函数的第一步是将其原型放在类声明中，并在原型声明前 加上关键字 &lt;code&gt;friend&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;friend Time operator* (double m, const Time &amp;amp; t);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该原型意味着下面两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虽然 &lt;code&gt;operator *()&lt;/code&gt; 函数是在类声明中声明的，但它不是成员函数，因 此不能使用成员运算符来调用；&lt;/li&gt;
&lt;li&gt;虽然 &lt;code&gt;operator *()&lt;/code&gt; 函数不是成员函数，但它与成员函数的访问权限相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二步是编写函数定义。&lt;strong&gt;因为它不是成员函数&lt;/strong&gt;，所以不要使用 &lt;code&gt;Time::&lt;/code&gt; 限定符。另外，不要在定义中使用关键字 &lt;code&gt;friend&lt;/code&gt;，定义应该如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;Time operator*(double mult) {
    Time result;
    long totalminutes = hours * mult * 60 + minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了上述声明和定义后，语句：&lt;code&gt;A = 2.75 * B&lt;/code&gt; 就被自动转换为 &lt;code&gt;A = operator*(2.75, B)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;总之，&lt;strong&gt;类的友元函数是非成员函数，但访问权限与成员函数相同&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1132-常用的友元重载-运算符&#34;&gt;11.3.2 常用的友元：重载 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 运算符&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// mytime3.h -- Time class with friends
#ifndef MYTIME3_H_
#define MYTIME3_H_
#include &amp;lt;iostream&amp;gt;

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time operator+(const Time &amp;amp; t) const;
    Time operator-(const Time &amp;amp; t) const;
    Time operator*(double n) const;
    friend Time operator*(double m, const Time &amp;amp; t)
        { return t * m; }   // inline definition
    friend std::ostream &amp;amp; operator&amp;lt;&amp;lt;(std::ostream &amp;amp; os, const Time &amp;amp; t);

};
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码中对 &lt;code&gt;friend Time operator*(double m, const Time &amp;amp; t)&lt;/code&gt; 的重载定义非常棒，是一个相当聪明的做法！它不是重新写一段代码，而是调用已重载的 &lt;code&gt;Time operator*(double n) const&lt;/code&gt; 成员函数。&lt;/p&gt;
&lt;h2 id=&#34;114-重载运算符作为成员函数还是非成员函数&#34;&gt;11.4 重载运算符：作为成员函数还是非成员函数&lt;/h2&gt;
&lt;p&gt;一般来说，非成员函数应是友元函数，这样它才能直接访 问类的私有数据。加法运算符需要两个操作数。对于成员函数版本来说，一个操作数 通过this指针隐式地传递，另一个操作数作为函数参数显式地传递；对 于友元版本来说，两个操作数都作为参数来传递。&lt;/p&gt;
&lt;p&gt;对于某些运算符来说（如前所述），成员函数是唯一合法的选择。在其他情况下，这两种格式没有太大的区别。有时，根据类设计，使用非成员函数版本可能更好（尤其是为类定义类型 转换时）。&lt;/p&gt;
&lt;h2 id=&#34;115-再谈重载一个矢量类&#34;&gt;11.5 再谈重载：一个矢量类&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;    // subtract Vector b from a
    Vector Vector::operator-(const Vector &amp;amp; b) const
    {
        return Vector(x - b.x, y - b.y);
    }

    // reverse sign of Vector
    Vector Vector::operator-() const
    {
        return Vector(-x, -y);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;operator-( )有两种不同的定义。这是可行的，因为它们的特征标不同（两个矢量相减，或者单个矢量取反）。可以定义−运算符的一元和二元版本，因为C++提供了该运 算符的一元和二元版本。对于只有二元形式的运算符（如除法运算符），只能将其重载为二元运算符。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为运算符重载是通过函数来实现的，所以只要运算符函数的特征标不同，使用的运算符数 量与相应的内置C++运算符相同，就可以多次重载同一个运算符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;116-类的自动转换和强制类型转换&#34;&gt;11.6 类的自动转换和强制类型转换&lt;/h2&gt;
&lt;h2 id=&#34;117-总结&#34;&gt;11.7 总结&lt;/h2&gt;
&lt;p&gt;一般来说，访问私有类成员的唯一方法是使用类方法。C++使用友 元函数来避开这种限制。要让函数成为友元，需要在类声明中声明该函 数，并在声明前加上关键字friend。&lt;/p&gt;
&lt;p&gt;C++扩展了对运算符的重载，允许自定义特殊的运算符函数，这种 函数描述了特定的运算符与类之间的关系。运算符函数可以是类成员函数，也可以是友元函数（有一些运算符函数只能是类成员函数）。&lt;/p&gt;
&lt;p&gt;最常见的运算符重载任务之一是定义&amp;lt;&amp;lt;运算符，使之可与cout一起 使用，来显示对象的内容。要让ostream对象成为第一个操作数，需要将 运算符函数定义为友元；要使重新定义的运算符能与其自身拼接，需要 将返回类型声明为 &lt;code&gt;ostream &amp;amp;&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;162&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812015334769.png&#34; alt=&#34;image-20210812015334769&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然而，如果类包含这样的方法，它返回需要显示的数据成员的值， 则可以使用这些方法，无需在&lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt;中直接访问这些成员。在这种情况下，函数不必（也不应当）是友元。&lt;/p&gt;
&lt;p&gt;C++允许指定在类和基本类型之间进行转换的方式。首先，任何接 受唯一一个参数的构造函数都可被用作转换函数，将类型与该参数相同 的值转换为类。如果将类型与该参数相同的值赋给对象，则C++将自动调用该构造函数。&lt;/p&gt;
&lt;p&gt;要将类对象转换为其他类型，必须定义转换函数，指出如何进行这种转换。转换函数必须是成员函数。&lt;/p&gt;
&lt;h1 id=&#34;第十二章-类和动态内存分配&#34;&gt;第十二章 类和动态内存分配&lt;/h1&gt;
&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对类成员使用动态内存分配；&lt;/li&gt;
&lt;li&gt;隐式和显示复制构造函数；&lt;/li&gt;
&lt;li&gt;隐式和显示重载赋值运算符；&lt;/li&gt;
&lt;li&gt;在构造函数中使用 &lt;code&gt;new&lt;/code&gt; 所必须完成的工作；&lt;/li&gt;
&lt;li&gt;使用静态类成员；&lt;/li&gt;
&lt;li&gt;将定位 &lt;code&gt;new&lt;/code&gt; 运算符用于对象；&lt;/li&gt;
&lt;li&gt;使用指向对象的指针；&lt;/li&gt;
&lt;li&gt;实现队列抽象数据类型（ADT）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对类使用 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 将影响构造函数和析构函数的设计以及运算符的重载。&lt;/p&gt;
&lt;h2 id=&#34;121-动态内存和类&#34;&gt;12.1 动态内存和类&lt;/h2&gt;
&lt;h3 id=&#34;1211-复习示例和静态类成员&#34;&gt;12.1.1 复习示例和静态类成员&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// strngbad.h -- flawed string class definition
#include &amp;lt;iostream&amp;gt;
#ifndef STRNGBAD_H_
#define STRNGBAD_H_
class StringBad
{
private:
    char * str;                // pointer to string
    int len;                   // length of string
    static int num_strings;    // number of objects
public:
    StringBad(const char * s); // constructor
    StringBad();               // default constructor
    ~StringBad();              // destructor
// friend function
    friend std::ostream &amp;amp; operator&amp;lt;&amp;lt;(std::ostream &amp;amp; os,
                       const StringBad &amp;amp; st);
};
#endif

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对这个声明，需要注意的有两点。首先，它使用char指针（而不是 char数组）来表示姓名。这意味着类声明没有为字符串本身分配存储空 间，而是在构造函数中使用new来为字符串分配空间。这避免了在类声 明中预先定义字符串的长度。&lt;/p&gt;
&lt;p&gt;其次，将num_strings成员声明为静态存储类。静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，&lt;code&gt;StringBad&lt;/code&gt; 类的所有对象共享同一个 &lt;code&gt;num_strings&lt;/code&gt;。假设创建了10个 &lt;code&gt;StringBad&lt;/code&gt; 对象，将有10个 &lt;code&gt;str&lt;/code&gt; 成员和10个 &lt;code&gt;len&lt;/code&gt; 成员，但只有一个共享的 &lt;code&gt;num_strings&lt;/code&gt; 成员（参见图12.1）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;163&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812100941808.png&#34; alt=&#34;image-20210812100941808&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// strngbad.cpp -- StringBad class methods
#include &amp;lt;cstring&amp;gt;                    // string.h for some
#include &amp;quot;strngbad.h&amp;quot;
using std::cout;

// initializing static class member
int StringBad::num_strings = 0;

// class methods

// construct StringBad from C string
StringBad::StringBad(const char * s)
{
    len = std::strlen(s);             // set size
    str = new char[len + 1];          // allot storage
    std::strcpy(str, s);              // initialize pointer
    num_strings++;                    // set object count
    cout &amp;lt;&amp;lt; num_strings &amp;lt;&amp;lt; &amp;quot;: \&amp;quot;&amp;quot; &amp;lt;&amp;lt; str
         &amp;lt;&amp;lt; &amp;quot;\&amp;quot; object created\n&amp;quot;;    // For Your Information
}

StringBad::StringBad()                // default constructor
{
    len = 4;
    str = new char[4];
    std::strcpy(str, &amp;quot;C++&amp;quot;);          // default string
    num_strings++;
    cout &amp;lt;&amp;lt; num_strings &amp;lt;&amp;lt; &amp;quot;: \&amp;quot;&amp;quot; &amp;lt;&amp;lt; str
         &amp;lt;&amp;lt; &amp;quot;\&amp;quot; default object created\n&amp;quot;;  // FYI
}

StringBad::~StringBad()               // necessary destructor
{
    cout &amp;lt;&amp;lt; &amp;quot;\&amp;quot;&amp;quot; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &amp;quot;\&amp;quot; object deleted, &amp;quot;;    // FYI
    --num_strings;                    // required
    cout &amp;lt;&amp;lt; num_strings &amp;lt;&amp;lt; &amp;quot; left\n&amp;quot;; // FYI
    delete [] str;                    // required
}

std::ostream &amp;amp; operator&amp;lt;&amp;lt;(std::ostream &amp;amp; os, const StringBad &amp;amp; st)
{
    os &amp;lt;&amp;lt; st.str;
    return os;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;int StringBad::num_strings = 0;&lt;/code&gt; 这条语句将静态成员 &lt;code&gt;num_strings&lt;/code&gt; 的值初始化为零。注意：&lt;strong&gt;不能在类声明中初始化静态成员变量，这是因为类声明中只描述如何分配内存，但并不分配内存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。&lt;/p&gt;
&lt;p&gt;另外，初始化是在方法文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果 在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。&lt;/p&gt;
&lt;p&gt;上述代码中，&lt;code&gt;strlen()&lt;/code&gt;返回字符串长度，但不包括末尾的空字符，因此构造函数将&lt;code&gt;len&lt;/code&gt;加1，使分配的内存能够存储包含空字符的字符串。&lt;/p&gt;
&lt;p&gt;删除对象可以释放对象本身占用的内存，但并不能自动释放属于对象成员的指针指向的内存。因此，必须使用析构函数。在析构函数中使用delete语句可确保对象过期 时，由构造函数使用new分配的内存被释放。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在构造函数中使用 &lt;code&gt;new&lt;/code&gt; 来分配内存时，必须在相应的析构函数中使用 &lt;code&gt;delete&lt;/code&gt; 来释放内存。如果 使用 &lt;code&gt;new[]&lt;/code&gt;（包括中括号）来分配内存，则应使用&lt;code&gt;delete[]&lt;/code&gt;（包括中括号）来释放内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;StringBad&lt;/code&gt;的第一个版本有许多故意留下的缺陷，是一个很糟糕的类（找到该类的错误之处，甚至可以作为一道困难的编程题），这些缺陷使得输出是不确定的。例如，有些 编译器无法编译它。虽然输出的具体内容有所差别，但基本问题和解决方法（稍后将介绍） 是相同的。&lt;/p&gt;
&lt;p&gt;程序输出结果：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;164&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812111740343.png&#34; alt=&#34;image-20210812111740343&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;callme2()&lt;/code&gt; 按值（而不是按引用）传递 &lt;code&gt;headline2&lt;/code&gt;，结果表明这是一个严重的问题。&lt;/p&gt;
&lt;p&gt;首先，将 &lt;code&gt;headline2&lt;/code&gt; 作为函数参数来传递从而&lt;strong&gt;导致析构函数被调用&lt;/strong&gt;。这是因为函数的参数  &lt;code&gt;sb&lt;/code&gt; 是一个临时变量，当函数调用结束后会释放这个临时变量，从而导致析构函数被调用，糟糕的源头在于析构函数中恰巧就释放了字符串。 其次，虽然按值传递可以防止原始参数被修改，但实际上函数已使原始 字符串无法识别，导致显示一些非标准字符（显示的文本取决于内存中 包含的内容）。&lt;/p&gt;
&lt;p&gt;因为自动存储对象被删除的顺序与创建顺序相反，所以最先删除的 3个对象是&lt;code&gt;knots&lt;/code&gt;、&lt;code&gt;sailor&lt;/code&gt;和&lt;code&gt;sport&lt;/code&gt;。删除&lt;code&gt;knots&lt;/code&gt;和&lt;code&gt;sailor&lt;/code&gt;时是正常的，但在删 除&lt;code&gt;sport&lt;/code&gt;时，&lt;code&gt;Dollars&lt;/code&gt;变成了&lt;code&gt;Doll8&lt;/code&gt;(或其他)。对于&lt;code&gt;sport&lt;/code&gt;，程序只使用它来初始化 &lt;code&gt;sailor&lt;/code&gt;，但这种操作修改了 &lt;code&gt;sports&lt;/code&gt;（这又可以做一道题）。&lt;/p&gt;
&lt;p&gt;具体而言，程序中 &lt;code&gt;Stringbad sailor = sports;&lt;/code&gt; 这个语句既不是调用默认构造函数也不是调用参数为 &lt;code&gt;const char*&lt;/code&gt; 的构造函数，而是等价于 &lt;code&gt;StringBad sailor=StringBad(sports);&lt;/code&gt; ，又因为&lt;code&gt;sports&lt;/code&gt;的类型为&lt;code&gt;StringBad&lt;/code&gt;，因此与之相应的构造函数原型应该是 &lt;code&gt;StringBad(const String &amp;amp;);&lt;/code&gt;，&lt;strong&gt;但这个构造函数在&lt;code&gt;StringBad&lt;/code&gt;类中没有显式声明更没有定义。这时当我们使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数（称为复制构造函数，因为它创建对象的一个副本）&lt;/strong&gt;。但自动生成的复制构造函数不知道需要更新静态变量&lt;code&gt;num_string&lt;/code&gt;，因此会将计数方案搞乱（这就是复制对象带来的问题）。实际上，这个例子说明的所有问题都是由编译器自动生成的成员函数引起的。&lt;/p&gt;
&lt;p&gt;最后被删除的两个对象（&lt;code&gt;headline2&lt;/code&gt;和 &lt;code&gt;headline1&lt;/code&gt;）已经无法识别。&lt;/p&gt;
&lt;h3 id=&#34;1212-特殊成员函数&#34;&gt;12.1.2 特殊成员函数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;StringBad&lt;/code&gt;类的问题是由特殊成员函数引起的。这些成员函数是自动定义的，就&lt;code&gt;StringBad&lt;/code&gt;而言，这些函数的行为与类设计不符。具体地说， C++自动提供了下面这些成员函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认构造函数；&lt;/li&gt;
&lt;li&gt;默认析构函数；&lt;/li&gt;
&lt;li&gt;复制构造函数；&lt;/li&gt;
&lt;li&gt;复制预运算符；&lt;/li&gt;
&lt;li&gt;地址运算符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更准确地说，编译器将生成上述最后三个函数的定义——如果程序 使用对象的方式要求这样做。例如，如果您将一个对象赋给另一个对 象，编译器将提供赋值运算符的定义。&lt;/p&gt;
&lt;p&gt;结果表明，StringBad类中的问题是由隐式复制构造函数和隐式赋值运算符引起的。&lt;/p&gt;
&lt;p&gt;1．默认构造函数&lt;/p&gt;
&lt;p&gt;默认情况下，编译器将提供一个不接受任何参数，也不执行任何操作 的构造函数（默认的默认构造函数），这是因为创建对象时总是会调用 构造函数。&lt;/p&gt;
&lt;p&gt;如果定义了构造函数，C++将不会定义默认构造函数。&lt;/p&gt;
&lt;p&gt;2．复制构造函数&lt;/p&gt;
&lt;p&gt;复制构造函数用于将一个对象复制到新创建的对象中。也就是说，&lt;strong&gt;它用于初始化过程中（包括按值传递参数），而不是常规的赋值过程&lt;/strong&gt;（那赋值的时候怎么办？赋值靠赋值运算符=，见12.1.4），原型是：&lt;code&gt;Class_name(const Class_name &amp;amp;)&lt;/code&gt;。它接受一个指向类对象的常量引用作为参数。&lt;/p&gt;
&lt;p&gt;对于复制构造函数，需要知道两点：何时调用和有何功能。&lt;/p&gt;
&lt;p&gt;3．何时调用复制构造函数&lt;/p&gt;
&lt;p&gt;新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。 最常见的情况是将新对象显式地初始化为现有的对象。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;165&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812120029250.png&#34; alt=&#34;image-20210812120029250&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;其中中间的2种声明可能会使用复制构造函数直接创建metoo和 also，也可能使用复制构造函数生成一个临时对象，然后将临时对象的 内容赋给metoo和also，这取决于具体的实现。最后一种声明使用motto 初始化一个匿名对象，并将新对象的地址赋给pStringBad指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每当程序生成了对象副本时，编译器都将使用复制构造函数&lt;/strong&gt;。具体地说，当函数按值传递对象（如程序清单12.3中的 &lt;code&gt;callme2()&lt;/code&gt;）或函数返回对象时，都将使用复制构造函数。记住，&lt;strong&gt;按值传递意味着创建原始变量的一个副本&lt;/strong&gt;。编译器生成临时对象时，也将使用复制构造函数。&lt;/p&gt;
&lt;p&gt;何时生成临时对象随编译器而异，但无论是哪种编译器，&lt;strong&gt;当按值传递和返回对象时，都将调用复制构造函数&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于按值传递对象将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储新对象的空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4．默认的复制构造函数的功能&lt;/p&gt;
&lt;p&gt;默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的值。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;166&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812120710195.png&#34; alt=&#34;image-20210812120710195&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;167&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812120946029.png&#34; alt=&#34;image-20210812120946029&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1213-回到-stringbad复制构造函数的哪里出了问题&#34;&gt;12.1.3  回到 Stringbad：复制构造函数的哪里出了问题&lt;/h3&gt;
&lt;p&gt;第一个异常，num_string是负值。当&lt;code&gt;callme2()&lt;/code&gt;被调用时，复制构造函数被用来初始化 &lt;code&gt;callme2()&lt;/code&gt; 的形参，还被用来将对象 &lt;code&gt;sailor&lt;/code&gt; 初始化为对象 &lt;code&gt;sports&lt;/code&gt;。默认的复 制构造函数不说明其行为，因此它不指出创建过程，也不增加计数器 num_strings的值。但析构函数更新了计数，并且在任何对象过期时都将 被调用，而不管对象是如何被创建的。程序的输出表明，析构函数的调用次数比构造函数的调用次数多2。&lt;/p&gt;
&lt;p&gt;第二个异常之处更微妙，也更危险，其症状之一是字符串内容出现乱码。原因在于隐式复制构造函数是按值进行复制的。例如，对于程序清 单12.3，隐式复制构造函数的功能相当于：&lt;code&gt;sailor.str = sport.str;&lt;/code&gt;。这里复制的并不是字符串，而是一个指向字符串的指针。也就是 说，将sailor初始化为sports后，得到的是两个指向同一个字符串的指 针。当operator &amp;lt;&amp;lt;()函数使用指针来显示字符串时，这并不会出现问 题。但当析构函数被调用时，这将引发问题。析构函数StringBad释放str 指针指向的内存，因此释放sailor的效果如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;168&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812121546201.png&#34; alt=&#34;image-20210812121546201&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;sports.str&lt;/code&gt;指向的内存已经被 &lt;code&gt;sailor&lt;/code&gt; 的析构函数释放，这将导致不确定 的、可能有害的后果。&lt;/p&gt;
&lt;p&gt;1．定义一个显式复制构造函数以解决问题&lt;/p&gt;
&lt;p&gt;解决类设计中这种问题的方法是进行深度复制（deep copy）。也就是说，&lt;strong&gt;复制构造函数应当复制字符串并将副本的地址赋给&lt;code&gt;str&lt;/code&gt;成员，而不仅仅是复制字符串地址&lt;/strong&gt;。这样每个对象都有自己的字符串，而不是引用 另一个对象的字符串。调用析构函数时都将释放不同的字符串，而不会试图去释放已经被释放的字符串。可以这样编写&lt;code&gt;String&lt;/code&gt;的复制构造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;String::String(const char * s)     // construct String from C string
{
    len = std::strlen(s);          // set size
    str = new char[len + 1];       // allot storage
    std::strcpy(str, s);           // initialize pointer
    num_strings++;                 // set object count
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;169&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812121927440.png&#34; alt=&#34;image-20210812121927440&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1214-stringbad的其他问题赋值运算符&#34;&gt;12.1.4 Stringbad的其他问题：赋值运算符&lt;/h3&gt;
&lt;p&gt;并不是程序清单12.3的所有问题都可以归咎于默认的复制构造函 数，还需要看一看默认的赋值运算符。C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的。这种运算符 的原型如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Class_name &amp;amp; Class_name::operator=(const Class_name &amp;amp;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它接受并返回一个指向类对象的引用。&lt;/p&gt;
&lt;p&gt;1．赋值运算符的功能以及何时使用它&lt;/p&gt;
&lt;p&gt;将已有的对象赋给另一个对象时，将使用重载的赋值运算符。初始化对象时，并不一定会使用赋值运算符，而更可能是调用复制构造函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;StringBad metoo = knot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里，&lt;code&gt;metoo&lt;/code&gt; 是一个新创建的对象，被初始化为 &lt;code&gt;knot&lt;/code&gt; 的值，因此使用复制构造函数。然而，正如前面指出的，实现时&lt;strong&gt;也可能分两步来处理这条语句：使用复制构造函数创建一个临时对象，然后通过赋值将临时 对象的值复制到新对象中&lt;/strong&gt;。这就是说，初始化总是会调用复制构造函数，而使用 &lt;code&gt;=&lt;/code&gt; 运算符时也可能调用赋值运算符。&lt;/p&gt;
&lt;p&gt;与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制，静态成员不受影响。&lt;/p&gt;
&lt;p&gt;2．赋值的问题出在哪里&lt;/p&gt;
&lt;p&gt;程序清单12.3将headline1赋给knot：&lt;code&gt;knot=headline1;&lt;/code&gt;。为knot调用析构函数时，正常。为Headline1调用析构函数时，异常。&lt;strong&gt;出现的问题与隐式复制构造函数相同：数据受损。这也是成员复制 的问题，即导致headline1.str和knot.str指向相同的地址&lt;/strong&gt;。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;解决赋值的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决办法是提供赋 值运算符（进行深度复制）定义，这与复制构造函数相似，但也有 一些差别:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于目标对象可能引用了以前分配的数据，所以函数应使用&lt;code&gt;delete []&lt;/code&gt; 来释放这些数据；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数应当避免将对象赋给自身；否则，给对象重新赋值前，释放内 存操作可能删除对象的内容&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;函数返回一个指向调用对象的&lt;strong&gt;引用&lt;/strong&gt;（注意是引用，不是值也不是指针）。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// assign a String to a String
String &amp;amp; String::operator=(const String &amp;amp; st)
{
    if (this == &amp;amp;st)
        return *this;
        
    delete [] str;
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);
    return *this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;赋值操作并不创建新的对象，因此不需要调整静态数据成员 &lt;code&gt;num_strings&lt;/code&gt; 的值。&lt;/p&gt;
&lt;h2 id=&#34;122-改进后的新string类&#34;&gt;12.2 改进后的新String类&lt;/h2&gt;
&lt;p&gt;首先，添加前面介绍过的复制构造函数和赋值运算符，使类 能够正确管理类对象使用的内存。其次，由于您已经知道对象何时被创 建和释放，因此可以让类构造函数和析构函数保持沉默，不再在每次被 调用时都显示消息。另外，也不用再监视构造函数的工作情况，因此可以简化默认构造函数，使之创建一个空字符串，而不是“C++”。&lt;/p&gt;
&lt;p&gt;新默认构造函数中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;String::String()                   // default constructor
{
    len = 4;
    str = new char[1];
    str[0] = &#39;\0&#39;;                 // default string
    num_strings++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么代码为 &lt;code&gt;str=new char[1];&lt;/code&gt; 而不是 &lt;code&gt;str = new char;&lt;/code&gt;，这两个方式相同，但区别在于前者和类析构函数兼容，而后者不兼容。这是析构函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;String::~String()                     // necessary destructor
{
    --num_strings;                    // required
    delete [] str;                    // required
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 的重载很妙啊，直接利用了 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 的重载结果：&lt;br&gt;
&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812163721949.png&#34; alt=&#34;image-20210812163721949&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1223-使用中括号表示法访问字符&#34;&gt;12.2.3 使用中括号表示法访问字符&lt;/h3&gt;
&lt;p&gt;在C++中，两个中括号组成一个运算符——中括号运算符，可以使 用方法operator 来重载该运算符。通常，二元C++运算符（带两个操作 数）位于两个操作数之间，例如2 +5。但对于中括号运算符，&lt;strong&gt;一个操作数位于第一个中括号的前面，另一个操作数位于两个中括号之间&lt;/strong&gt;。例如：&lt;code&gt;city[0]&lt;/code&gt; 中，&lt;code&gt;city&lt;/code&gt;是第一个操作数，&lt;code&gt;[]&lt;/code&gt;是运算符，&lt;code&gt;0&lt;/code&gt;是第二个操作数。&lt;/p&gt;
&lt;p&gt;在重载时，C++将区分常量和非常量函数的特征标。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// read-write char access for non-const String
char &amp;amp; String::operator[](int i)
{
    return str[i];
}

// read-only char access for const String
const char &amp;amp; String::operator[](int i) const
{
    return str[i];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了上述定义后，就可以读/写常规String对象了；而对于const String对象，则只能读取其数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;重载要注意同时考虑对const 和非 const 变量进行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;170&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812165647776.png&#34; alt=&#34;image-20210812165647776&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;也可以修改内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;String means(&amp;quot;might&amp;quot;);
means[0] = &#39;r&#39;;   // 这一句相当于 means.str[0] = &#39;r&#39;, 但 str 是私有成员，实际是没法在成员函数之外这样使用的。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;1224-静态类成员函数&#34;&gt;12.2.4 静态类成员函数&lt;/h3&gt;
&lt;p&gt;首先，不能通过对象调用静态成员函数；实际上，静态成员函数甚 至不能使用this指针。&lt;/p&gt;
&lt;p&gt;其次，由于静态成员函数不与特定的对象相关联，因此只能使用静 态数据成员。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;171&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812170316128.png&#34; alt=&#34;image-20210812170316128&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1225-进一步重载赋值运算符&#34;&gt;12.2.5 进一步重载赋值运算符&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;172&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812170559987.png&#34; alt=&#34;image-20210812170559987&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;重载&amp;gt;&amp;gt;运算符提供了一种将键盘输入行读入到String对象中的简单 方法。它假定输入的字符数不多于String::CINLIM的字符数，并丢弃多 余的字符。在if条件下，如果由于某种原因（如到达文件尾或&lt;code&gt;get(char *, int)&lt;/code&gt; 读取的是一个空行）导致输入失败，istream对象的值将置为 false。&lt;/p&gt;
&lt;h2 id=&#34;123-在构造函数中使用new时应注意的事项&#34;&gt;12.3 在构造函数中使用new时应注意的事项&lt;/h2&gt;
&lt;p&gt;使用new初始化对象的指针成员时必须特别小心：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在构造函数中使用new来初始化指针成员，则应在析构函数中 使用delete；&lt;/li&gt;
&lt;li&gt;new和delete必须相互兼容。new对应于delete，new[ ]对应于delete[ ]；&lt;/li&gt;
&lt;li&gt;如果有多个构造函数，则必须以相同的方式使用new，要么都带中 括号，要么都不带。因为只有一个析构函数，所有的构造函数都必 须与它兼容。然而，可以在一个构造函数中使用new初始化指针， 而在另一个构造函数中将指针初始化为空（0或C++11中的 nullptr），这是因为delete（无论是带中括号还是不带中括号）可以用于空指针；&lt;/li&gt;
&lt;li&gt;应定义一个复制构造函数，通过深度复制将一个对象初始化为另一 个对象；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;173&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812183412719.png&#34; alt=&#34;image-20210812183412719&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;174&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812183448925.png&#34; alt=&#34;image-20210812183448925&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;具体地说，该方法应完成这些操作：&lt;strong&gt;检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不仅仅是数据的地址，并返回一个指向调用对象的引用&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1231-应该和不应该&#34;&gt;12.3.1 应该和不应该&lt;/h3&gt;
&lt;h3 id=&#34;1232-包含类成员的类的逐成员复制&#34;&gt;12.3.2 包含类成员的类的逐成员复制&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;175&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812185109539.png&#34; alt=&#34;image-20210812185109539&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果您将一个 Magazine对象复制或赋值给另一个Magazine对象，逐成员复制将使用成 员类型定义的复制构造函数和赋值运算符。也就是说，复制成员title 时，将使用String的复制构造函数，而将成员title赋给另一个Magazine对 象时，将使用String的赋值运算符，依此类推。&lt;/p&gt;
&lt;h2 id=&#34;124-有关返回对象的说明&#34;&gt;12.4 有关返回对象的说明&lt;/h2&gt;
&lt;p&gt;当成员函数或独立的函数返回对象时，有几种返回方式可供选择。 可以&lt;strong&gt;返回指向对象的引用、指向对象的const引用或const对象&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1241-返回指向const对象的引用&#34;&gt;12.4.1 返回指向const对象的引用&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;176&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812185620612.png&#34; alt=&#34;image-20210812185620612&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这里有三点需要说明。首先，返回对象将调用复制构造函数，而返回引用不会，所以版本2效率更高。其次，引用指向的对象应该在调用函数执行时存在。第 三，&lt;strong&gt;v1和v2都被声明为const引用，因此返回类型必须为const，这样才匹配&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1242-返回指向非const对象的引用&#34;&gt;12.4.2 返回指向非const对象的引用&lt;/h3&gt;
&lt;p&gt;两种常见的返回非 &lt;code&gt;const&lt;/code&gt; 对象情形是，重载赋值运算符以及重载与 &lt;code&gt;cout&lt;/code&gt; 一起使用的 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 运算符。前者这样做旨在提高效率，而后者必须这样做。&lt;/p&gt;
&lt;p&gt;Operator&amp;lt;&amp;lt;()的返回值用于串接输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;String s1(&amp;quot;Good stuff&amp;quot;);
cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; &amp;quot; is comming!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;operator&amp;lt;&amp;lt;（cout, s1）&lt;/code&gt;的返回值成为一个用于显示字符串“is coming!”的对象。返回类型必须是 &lt;code&gt;ostream &amp;amp;&lt;/code&gt;，而不能仅仅是 &lt;code&gt;ostream&lt;/code&gt;。&lt;strong&gt;如果使用返回类型&lt;code&gt;ostream&lt;/code&gt;，将要求调用&lt;code&gt;ostream&lt;/code&gt;类的复制构造 函数，而&lt;code&gt;ostream&lt;/code&gt;没有公有的复制构造函数&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1243-返回对象&#34;&gt;12.4.3 返回对象&lt;/h3&gt;
&lt;p&gt;如果被返回的对象是&lt;strong&gt;被调用函数中的局部变量，则不应按引用方式返回它，因为在被调用函数执行完毕时，局部对象将调用其析构函数&lt;/strong&gt;。因此，当控制权回到调用函数时，引用指向的对象将不再存在。&lt;strong&gt;在这种情况下，应返回对象而不是引用&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1244-返回-const-对象&#34;&gt;12.4.4 返回 &lt;code&gt;const&lt;/code&gt; 对象&lt;/h3&gt;
&lt;p&gt;前面的Vector::operator+( )定义有一个奇异的属性，它旨在让您能够 以下面这样的方式使用它：&lt;code&gt;net = force1 + force2;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然而，这种定义也允许您这样使用它：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;force1 + force2 = net;
cout &amp;lt;&amp;lt; (force1 + force2 = net).magval() &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这提出了三个问题。为何编写这样的语句？这些语句为何可行？这 些语句有何功能？&lt;strong&gt;首先，没有要编写这种语句的合理理由，但并非所有代码都是合理的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这种代码之所以可行，是因为复制构造函数将创建一个临时 对象来表示返回值。因此，在前面的代码中，表达式force1 + force2的结 果为一个临时对象。在语句1中，该临时对象被赋给net；在语句2和3 中，net被赋给该临时对象。使用完临时对象后，将把它丢弃。&lt;/p&gt;
&lt;p&gt;总之，如果方法或函数要返回局部对象，则应返回对象，而不是指 向对象的引用。在这种情况下，将使用复制构造函数来生成返回的对 象。如果方法或函数要返回一个没有公有复制构造函数的类（如ostream类）的对象，它必须返回一个指向这种对象的引用。最后，有些方法和 函数（如重载的赋值运算符）可以返回对象，也可以返回指向对象的引 用，在这种情况下，应首选引用，因为其效率更高。&lt;/p&gt;
&lt;h2 id=&#34;125-使用指向对象的指针&#34;&gt;12.5 使用指向对象的指针&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;177&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812215628088.png&#34; alt=&#34;image-20210812215628088&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1251-再谈new和delete&#34;&gt;12.5.1 再谈&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;178&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812220903934.png&#34; alt=&#34;image-20210812220903934&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1252-指针和对象小结&#34;&gt;12.5.2 指针和对象小结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用常规表示法来声明指向对象的指针；&lt;/li&gt;
&lt;li&gt;可以将指针初始化为指向已有的对象；&lt;/li&gt;
&lt;li&gt;可以使用new来初始化指针，这将创建一个新的对象；&lt;/li&gt;
&lt;li&gt;对类使用new将调用相应的类构造函数来初始化新创建的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;179&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812221115586.png&#34; alt=&#34;image-20210812221115586&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;180&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812221146826.png&#34; alt=&#34;image-20210812221146826&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;可以使用&lt;code&gt;-&amp;gt;&lt;/code&gt;运算符通过指针访问类方法；&lt;/li&gt;
&lt;li&gt;可以对对象指针应用解除引用运算符&lt;code&gt;*&lt;/code&gt;来获得对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1253-再谈定位new运算符&#34;&gt;12.5.3 再谈定位new运算符&lt;/h3&gt;
&lt;h2 id=&#34;126-复习各种技术&#34;&gt;12.6 复习各种技术&lt;/h2&gt;
&lt;h3 id=&#34;1261-重载运算符&#34;&gt;12.6.1 重载&amp;lt;&amp;lt;运算符&lt;/h3&gt;
&lt;p&gt;要重新定义 &amp;lt;&amp;lt; 运算符，以便将它和cout一起用来显示对象的内 容，请定义下面的友元运算符函数：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;181&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210812221524669.png&#34; alt=&#34;image-20210812221524669&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1262-转换函数&#34;&gt;12.6.2 转换函数&lt;/h3&gt;
&lt;p&gt;要将单个值转换为类类型，需要创建原型如下所示的类构造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;class_name(type_name value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要将类转换为其他类型，需要创建原型如下所示的类成员函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;operator type_name();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;虽然该函数没有声明返回类型，但应返回所需类型的值。&lt;/p&gt;
&lt;p&gt;使用转换函数时要小心。可以在声明构造函数时使用关键字 explicit，以防止它被用于隐式转换。&lt;/p&gt;
&lt;h3 id=&#34;1263-其构造函数使用new的类&#34;&gt;12.6.3 其构造函数使用new的类&lt;/h3&gt;
&lt;h2 id=&#34;127-队列模拟&#34;&gt;12.7 队列模拟&lt;/h2&gt;
&lt;p&gt;这里不记录了。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;const&lt;/code&gt;数据成员，必须在执行到构造函数体之前，即创建对象时进行初始化。C++提供了一种特殊的语法来完成上 述工作，它叫做成员初始化列表（member initializer list）。成员初始化 列表由逗号分隔的初始化列表组成（前面带冒号）。它位于参数列表的 右括号之后、函数体左括号之前。如果数据成员的名称为 &lt;code&gt;mdata&lt;/code&gt;，并需 要将它初始化为&lt;code&gt;val&lt;/code&gt;，则初始化器为&lt;code&gt;mdata(val)&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;182&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210814205323898.png&#34; alt=&#34;image-20210814205323898&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;只有构造函数可以使用这种初始化列表语法&lt;/strong&gt;。如上所示，对于const 类成员，必须使用这种语法。另外，&lt;strong&gt;对于被声明为引用的类成员，也必须使用这种语法&lt;/strong&gt;：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;183&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210814205737591.png&#34; alt=&#34;image-20210814205737591&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;这是因为引用与const数据类似，只能在被创建时进行初始化&lt;/strong&gt;。对于 简单数据成员（例如front和items），使用成员初始化列表和在函数体中 使用赋值没有什么区别。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;【注意】：&lt;br&gt;
这种格式只能用于构造函数；&lt;br&gt;
必须用这种格式来初始化非静态const数据成员；&lt;br&gt;
必须用这种格式来初始化引用数据成员。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;不能将成员初始化列表语法用于构造函数之外的其他类方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果我们不希望复制构造函数被调用，也不允许赋值运算，可以这样做：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;184&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210814214006080.png&#34; alt=&#34;image-20210814214006080&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这是一种禁用方法的技巧，同时可以作为一种暂时不编写这两个函数的预防措施：与其将来面对无法预料的运行故障，不如得到一个易于跟踪的编译错误，指出这些方法是不可访问的。另外，在定义其对象不允许 被复制的类时，这种方法也很有用。&lt;/p&gt;
&lt;p&gt;还有没有其他影响需要注意呢？当然有。当对象被按值传递（或返 回）时，复制构造函数将被调用。然而，如果遵循优先采用按引用传递 对象的惯例，将不会有任何问题。另外，复制构造函数还被用于创建其 他的临时对象，但Queue定义中并没有导致创建临时对象的操作，例如 重载加法运算符。&lt;/p&gt;
&lt;h2 id=&#34;128-总结&#34;&gt;12.8 总结&lt;/h2&gt;
&lt;p&gt;本章介绍了定义和使用类的许多重要方面。其中的一些方面是非常 微妙甚至很难理解的概念。&lt;/p&gt;
&lt;p&gt;在类构造函数中使用new，也可能在对象过期 时引发问题。如果对象包含成员指针，同时它指向的内存是由new分配 的，则释放用于保存对象的内存并不会自动释放对象成员指针指向的内 存。因此在类构造函数中使用new类来分配内存时，应在类析构函数中 使用delete来释放分配的内存。这样，当对象过期时，将自动释放其指 针成员指向的内存。&lt;/p&gt;
&lt;p&gt;如果对象包含指向new分配的内存的指针成员，则将一个对象初始 化为另一个对象，或将一个对象赋给另一个对象时，也会出现问题。&lt;/p&gt;
&lt;p&gt;在 默认情况下，C++逐个对成员进行初始化和赋值，这意味着被初始化或 被赋值的对象的成员将与原始对象完全相同。如果原始对象的成员指向 一个数据块，则副本成员将指向同一个数据块。当程序最终删除这两个 对象时，类的析构函数将试图删除同一个内存数据块两次，这将出错。解决方法是：&lt;strong&gt;定义一个特殊的复制构造函数来重新定义初始化，并重载赋值运算符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这样，旧对象和新对象都将引用独立 的、相同的数据，而不会重叠。由于同样的原因，必须定义赋值运算 符。对于每一种情况，最终目的都是执行深度复制，也就是说，复制实际的数据，而不仅仅是复制指向数据的指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C++允许在类中包含结构、类和枚举定义。这些嵌套类型的作用域为整个类&lt;/strong&gt;，这意味着它们被局限于类中，不 会与其他地方定义的同名结构、类和枚举发生冲突。&lt;/p&gt;
&lt;p&gt;C++为&lt;strong&gt;类构造函数&lt;/strong&gt;提供了一种可用来&lt;strong&gt;初始化数据成员的特殊语法&lt;/strong&gt;。 这种语法包括冒号和由逗号分隔的初始化列表，被放在构造函数参数的 右括号后，函数体的左括号之前。每一个初始化器都由被初始化的成员 的名称和包含初始值的括号组成。从概念上来说，这些初始化操作是在 对象创建时进行的，此时函数体中的语句还没有执行。语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;queue(int qs): qsize(qs), items(0), front(NULL), rear(NULL) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果数据成员是&lt;strong&gt;非静态const成员或引用，则必须采用这种格式&lt;/strong&gt;，但 可将C++11新增的类内初始化用于非静态const成员。&lt;/p&gt;
&lt;h1 id=&#34;第十三章-类继承&#34;&gt;第十三章 类继承&lt;/h1&gt;
&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is-a 关系的继承；&lt;/li&gt;
&lt;li&gt;如何以公有方式从一个类派生出另一个类；&lt;/li&gt;
&lt;li&gt;保护访问；&lt;/li&gt;
&lt;li&gt;构造函数成员初始化列表；&lt;/li&gt;
&lt;li&gt;向上和向下强制转换；&lt;/li&gt;
&lt;li&gt;虚成员函数；&lt;/li&gt;
&lt;li&gt;早期（静态）联编与晚期（动态）联编；&lt;/li&gt;
&lt;li&gt;抽象基类；&lt;/li&gt;
&lt;li&gt;纯虚函数；&lt;/li&gt;
&lt;li&gt;何时以及如何使用公有继承。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;面向对象编程的主要目的之一是提供可重用的代码&lt;/strong&gt;。开发新项目， 尤其是当项目十分庞大时，重用经过测试的代码比重新编写代码要好得多。另外，必须考虑的细节越少， 便越能专注于程序的整体策略。&lt;/p&gt;
&lt;p&gt;继承是一种非常好的概念，其基本实现非常简单。&lt;/p&gt;
&lt;h2 id=&#34;131-一个简单的基类&#34;&gt;13.1 一个简单的基类&lt;/h2&gt;
&lt;p&gt;从一个类派生出另一个类时，&lt;strong&gt;原始类称为基类，继承类称为派生类&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1311-派生一个类&#34;&gt;13.1.1 派生一个类&lt;/h3&gt;
&lt;p&gt;与其从零开始，不如从 TableTennisClass类派生出一个类。首先将RatedPlayer类声明为从 TableTennisClass类派生而来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class RetedPlayer: public TableTennisPlayer {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;冒号指出RatedPlayer类的基类是TableTennisplayer类。上述特殊的 声明头表明TableTennisPlayer是一个公有基类，这被称为公有派生。&lt;/p&gt;
&lt;p&gt;派生类对象包含基类对象。使用公有派生，&lt;strong&gt;基类的公有成员将成为派生类 的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基 类的公有和保护方法访问&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上述代码完成了哪些工作呢？Ratedplayer对象将具有以下特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;派生类对象存储了基类的数据成员（派生类继承了基类的实现）；&lt;/li&gt;
&lt;li&gt;派生类对象可以使用基类的方法（派生类继承了基类的接口）。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;185&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210814224752163.png&#34; alt=&#34;image-20210814224752163&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;需要在继承特性中添加什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;派生类需要自己的构造函数。&lt;/li&gt;
&lt;li&gt;派生类可以根据需要添加额外的数据成员和成员函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;构造函数必须给新成员（如果有的话）和继承的成员提供数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 第一个RatedPlayer构造函数中，每个成员对应一个形参；而第二个 Ratedplayer构造函数使用一个TableTennisPlayer参数，该参数包括 firstname、lastname和hasTable。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// simple derived class
class RatedPlayer : public TableTennisPlayer
{
private:
    unsigned int rating;
public:
    RatedPlayer (unsigned int r = 0, const string &amp;amp; fn = &amp;quot;none&amp;quot;,
                 const string &amp;amp; ln = &amp;quot;none&amp;quot;, bool ht = false);
    RatedPlayer(unsigned int r, const TableTennisPlayer &amp;amp; tp);
    unsigned int Rating() const { return rating; }
    void ResetRating (unsigned int r) {rating = r;}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;1312-构造函数访问权限的考虑&#34;&gt;13.1.2 构造函数：访问权限的考虑&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问&lt;/strong&gt;。具体地说，派生类构造函数需要使用基类构造函数。&lt;/p&gt;
&lt;p&gt;创建派生类对象时，程序首先创建基类对象。&lt;/p&gt;
&lt;p&gt;从概念上说，这意味 着基类对象应当在程序进入派生类构造函数之前被创建。C++使用成员 初始化列表语法来完成这种工作。例如，下面是第一个RatedPlayer构造 函数的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;// RatedPlayer methods
RatedPlayer::RatedPlayer(unsigned int r, const string &amp;amp; fn,
     const string &amp;amp; ln, bool ht) : TableTennisPlayer(fn, ln, ht)
{
    rating = r;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中: &lt;code&gt;TableTennisPlayer(fn,ln,ht)&lt;/code&gt; 是成员初始化列表。它是可执行的 代码，调用&lt;code&gt;TableTennisPlayer&lt;/code&gt;构造函数。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;186&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210814225744213.png&#34; alt=&#34;image-20210814225744213&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;RatedPlayer::RatedPlayer(unsigned int r, const string &amp;amp; fn,
     const string &amp;amp; ln, bool ht) {
    rating = r;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果省略成员初始化列表，情况将如何呢？首先必须创建基类对象，如果不调用基类构造函数，程序将使用默 认的基类构造函数，因此上述代码与下面等效：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;RatedPlayer::RatedPlayer(unsigned int r, const string &amp;amp; fn,
     const string &amp;amp; ln, bool ht) : TableTennisPlayer() {
    rating = r;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;除非要使用默认构造函数，否则应显式调用正确的基类构造函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果愿意，也可以对派生类成员使用成员初始化列表语法。在这种 情况下，应在列表中使用成员名，而不是类名。所以，第二个构造函数 可以按照下述方式编写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;RatedPlayer::RatedPlayer(unsigned int r, const string &amp;amp; fn,
     const string &amp;amp; ln, bool ht) : TableTennisPlayer(fn, ln, ht), rating(r) {
    rating = r;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有关派生类构造函数的要点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先创建基类对象；&lt;/li&gt;
&lt;li&gt;派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；&lt;/li&gt;
&lt;li&gt;派生类构造函数应初始化派生类新增的数据成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。&lt;/p&gt;
&lt;h3 id=&#34;1313-使用派生类&#34;&gt;13.1.3 使用派生类&lt;/h3&gt;
&lt;p&gt;要使用派生类，程序必须要能够访问基类声明。既可以将两种类的声明置于同一个头文件中。也可以将每个类放在独立的头文件 中，如果两个类是相关的，把它们的类声明放在一起更合适。&lt;/p&gt;
&lt;h3 id=&#34;1314-派生类和基类之间的特殊关系&#34;&gt;13.1.4 派生类和基类之间的特殊关系&lt;/h3&gt;
&lt;p&gt;第一，派生类对象可以使用基类的方法，条件是方法不是私有的；&lt;br&gt;
第二，基类指针可以在不进行显式类型转换的情况下指向派生类对象（基类指针可以直接指向派生类，神奇）；&lt;br&gt;
第三，基类引用可以在不进行显式类型转换的情况下引用派生类对象（基类引用可以直接应用派生类，神奇）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;187&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210814231630592.png&#34; alt=&#34;image-20210814231630592&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;不过，&lt;strong&gt;基类指针或引用只能用于调用基类方法&lt;/strong&gt;，因此，不能使用&lt;code&gt;rt&lt;/code&gt; 或&lt;code&gt;pt&lt;/code&gt;来调用派生类的&lt;code&gt;ResetRanking&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;通常，C++要求引用和指针类型与赋给的类型匹配，&lt;strong&gt;但这一规则对 继承来说是例外&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然而，这种例外只是单向的，不可以将基类对象和地 址赋给派生类引用和指针。&lt;/p&gt;
&lt;p&gt;上述规则是有道理的。允许基类引用隐式地引用派生类对象，等于是可以使用基类引用为派生类对象调用基类的方法。因为派生类 继承了基类的方法，所以这样做不会出现问题。&lt;/p&gt;
&lt;p&gt;而如果可以将基类对象赋 给派生类引用，将发生什么情况呢？派生类引用能够为基对象调用派生 类方法，这样做将出现问题。例如，将RatedPlayer::Rating( )方法用于 TableTennisPlayer对象是没有意义的，因为TableTennisPlayer对象没有 rating成员。&lt;/p&gt;
&lt;p&gt;基类引用和指针可以指向派生类对象，将出现一些很有趣的结果。其中之一是&lt;strong&gt;基类中引用定义的函数或指针参数可用于派生类对象&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;132-继承is-a关系&#34;&gt;13.2 继承：is-a关系&lt;/h2&gt;
&lt;p&gt;派生类和基类之间的特殊关系是基于C++继承的底层模型的。实际 上，C++有3种继承方式：公有继承、保护继承和私有继承。公有继承 是最常用的方式，它建立一种is-a关系，&lt;strong&gt;即派生类对象也是一个基类对象，任何可以对基类对象执行的操作，也可以对派生类对象执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为派生类可以添加特性，所以，将这种关系称为 is-a-kind-of（是一种）关系可能 更准确，但是通常使用术语 is-a。&lt;/p&gt;
&lt;h2 id=&#34;133-多态公有继承&#34;&gt;13.3 多态公有继承&lt;/h2&gt;
&lt;p&gt;派生类对象使用基类的方法，而未做 任何修改。然而，可能会遇到这样的情况，即希望同一个方法在派生类 和基类中的行为是不同的，这称为多态公有继承。有两种重要的机制可用于实现多态公有继承：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在派生类中重新定义基类的方法；&lt;/li&gt;
&lt;li&gt;使用虚方法（关键字 &lt;code&gt;virtual&lt;/code&gt;），然后在各自类中对该函数编写相关定义即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虚函数的这种行为非常方便。方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。&lt;/p&gt;
&lt;p&gt;第四点是，基类声明了一个虚析构函数。这样做是为了确保释放派 生对象时，按正确的顺序调用析构函数。&lt;/p&gt;
&lt;p&gt;为何需要虚析构函数？&lt;/p&gt;
&lt;p&gt;在程序清单13.10中，使用delete释放由new分配的对象的代码说明 了为何基类应包含一个虚析构函数。&lt;/p&gt;
&lt;p&gt;如果析构函数不是虚的，则将只调用对应于指针类型的析构函数。对于 程序清单13.10，这意味着只有Brass的析构函数被调用，即使指针指向 的是一个BrassPlus对象。如果析构函数是虚的，将调用相应对象类型的 析构函数。因此，如果指针指向的是BrassPlus对象，将调用BrassPlus的 析构函数，然后自动调用基类的析构函数。因此，使用虚析构函数可以 确保正确的析构函数序列被调用。&lt;/p&gt;
&lt;p&gt;对于程序清单13.10，这种正确的行为并不是很重要，因为析构函数没有执行任何操作。然而，如果 BrassPlus包含一个执行某些操作的析构函数，则Brass必须有一个虚析构函数，即使该析构函数不执行任何操作。&lt;/p&gt;
&lt;h2 id=&#34;134-静态联编和动态联编&#34;&gt;13.4 静态联编和动态联编&lt;/h2&gt;
&lt;p&gt;程序调用函数时，将使用哪个可执行代码块呢？编译器负责回答这 个问题。将源代码中的函数调用解释为执行特定的函数代码块被称为函 数名联编（binding）。在编译过程中进行联 编被称为静态联编（static binding），又称为早期联编（early binding）。然而，虚函数使这项工作变得更困难。正如在程序清单 13.10所示的那样，使用哪一个函数是不能在编译时确定的，因为编译 器不知道用户将选择哪种类型的对象。所以，编译器必须生成能够在程 序运行时选择正确的虚方法的代码，这被称为动态联编（dynamic binding），又称为晚期联编（late binding）。&lt;/p&gt;
&lt;h3 id=&#34;1341-指针和引用类型的兼容性&#34;&gt;13.4.1 指针和引用类型的兼容性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;将派生类引用或指针转换为基类引用或指针被称为向上强制转换 （upcasting），这使公有继承不需要进行显式类型转换&lt;/strong&gt;。该规则是is-a 关系的一部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相反的过程——将基类指针或引用转换为派生类指针或引用——称为向下强制转换（downcasting），如果不使用显式类型转换，则向下强制转换是不允许的&lt;/strong&gt;。原因是is-a关系通常是不可逆的。派生类可以新增 数据成员，因此使用这些数据成员的类成员函数不能应用于基类。&lt;/p&gt;
&lt;p&gt;对于使用基类引用或指针作为参数的函数调用，将进行向上转换。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;188&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210815000054655.png&#34; alt=&#34;image-20210815000054655&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1342-虚成员函数和动态联编&#34;&gt;13.4.2 虚成员函数和动态联编&lt;/h3&gt;
&lt;p&gt;编译器对虚方法使用动态联编。在大多数情况下，动态联编很好，因为它让程序能够选择为特定类 型设计的方法。&lt;/p&gt;
&lt;p&gt;1．为什么有两种类型的联编以及为什么默认为静态联编&lt;/p&gt;
&lt;p&gt;如果动态联编让您能够重新定义类方法，而静态联编在这方面很 差，为何不摒弃静态联编呢？原因有两个——效率和概念模型。&lt;/p&gt;
&lt;p&gt;首先来看效率。为使程序能够在运行阶段进行决策，必须采取一些 方法来跟踪基类指针或引用指向的对象类型，这增加了额外的处理开销 （稍后将介绍一种动态联编方法）。&lt;/p&gt;
&lt;p&gt;接下来看概念模型。在设计类时，可能包含一些不在派生类重新定 义的成员函数。例如，Brass::Balance( )函数返回账户结余，不应该重新 定义。不将该函数设置为虚函数，有两方面的好处：首先效率更高；其次，指出不要重新定义该函数。这表明，仅将那些预期将被重新定义的 方法声明为虚的。&lt;/p&gt;
&lt;p&gt;2．虚函数的工作原理&lt;/p&gt;
&lt;p&gt;编译器处理虚函数的方法是：给每个对象添加一个隐藏成 员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚 函数表（virtual function table，vtbl）。虚函数表中存储了为类对象进行 声明的虚函数的地址。例如，基类对象包含一个指针，该指针指向基类 中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指 针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地 址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地 址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到vtbl 中（参见图13.5）。注意，无论类中包含的虚函数是1个还是10个，都 只需要在对象中添加1个地址成员，只是表的大小不同而已。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;189&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210815000546665.png&#34; alt=&#34;image-20210815000546665&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;调用虚函数时，程序将查看存储在对象中的vtbl地址，然后转向相 应的函数地址表。如果使用类声明中定义的第一个虚函数，则程序将使 用数组中的第一个函数地址，并执行具有该地址的函数。如果使用类声 明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。&lt;/p&gt;
&lt;p&gt;总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个对象都将增大，&lt;strong&gt;增大量&lt;/strong&gt;为存储地址的空间；&lt;/li&gt;
&lt;li&gt;对于每个类，编译器都创建一个虚函数地址表（数组）；&lt;/li&gt;
&lt;li&gt;对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1343-有关虚函数注意事项&#34;&gt;13.4.3 有关虚函数注意事项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在基类方法的声明中使用关键字virtual可使该方法在基类以及所有 的派生类（包括从派生类派生出来的类）中是虚的；&lt;/li&gt;
&lt;li&gt;如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为 动态联编。这种行为非常重要，因为这样基类指针或引 用可以指向派生类对象；&lt;/li&gt;
&lt;li&gt;如果定义的类将被用作基类，则应将那些要在派生类中重新定义的 类方法声明为虚的；&lt;/li&gt;
&lt;li&gt;构造函数不能是虚函数；&lt;/li&gt;
&lt;li&gt;析构函数应当是虚函数，除非类不用做基类。这意味着，即使基类不需要显式析构函数提供服务，也不应依赖于默认构造函数，而应提供虚析构函数，即使它不执行任何操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;给类定义一个虚析构函数并非错误，即使这个类不用做基类&lt;/strong&gt;；这只是一个效率方面的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函 数。&lt;/li&gt;
&lt;li&gt;如果派生类没有重新定义函数，将使用该函数的基类版本。如果派 生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;135-访问控制protected&#34;&gt;13.5 访问控制：protected&lt;/h2&gt;
&lt;p&gt;关键字&lt;code&gt;protected&lt;/code&gt;与 &lt;code&gt;private&lt;/code&gt; 相似，在类外只能用公有类成员来访问&lt;code&gt;protected&lt;/code&gt;部分中的类成员。&lt;code&gt;private&lt;/code&gt;和&lt;code&gt;protected&lt;/code&gt;之间的区别只有在基类派生的类中才会表现出来。派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。因此，对于外部世界来说， 保护成员的行为与私有成员相似；但对于派生类来说，保护成员的行为与公有成员相似。&lt;/p&gt;
&lt;h2 id=&#34;136-抽象基类&#34;&gt;13.6 抽象基类&lt;/h2&gt;
&lt;p&gt;C++通过使用纯虚函数（pure virtual function） 提供未实现的函数。纯虚函数声明的结尾处为=0。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;virtual double Area() const = 0; // a pure virtual function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当类声明中包含纯虚函数时，则不能创建该类的对象。这里的理念 是，包含纯虚函数的类只用作基类。要成为真正的ABC，必须至少包含 一个纯虚函数。原型中的=0使虚函数成为纯虚函数。&lt;/p&gt;
&lt;p&gt;在原型中使用=0指出类是一个抽象基类，在类中可以不定义该函数。&lt;/p&gt;
&lt;p&gt;【ABC理念】如果要设计类继承层次，则只能将那些不会被用作基类的类设计 为具体的类。这种方法的设计更清晰，复杂程度更低。&lt;/p&gt;
&lt;p&gt;可以将ABC看作是一种必须实施的接口。ABC要求具体派生类覆盖 其纯虚函数——迫使派生类遵循ABC设置的接口规则。这种模型在基于 组件的编程模式中很常见，在这种情况下，使用ABC使得组件设计人员 能够制定“接口约定”，这样确保了从ABC派生的所有组件都至少支持 ABC指定的功能。&lt;/p&gt;
&lt;h2 id=&#34;137-继承和动态内存分配&#34;&gt;13.7 继承和动态内存分配&lt;/h2&gt;
&lt;p&gt;继承是怎样与动态内存分配（使用new和delete）进行互动的呢？例如，如果基类使用动态内存分配，并重新定义赋值和复制构造函数，这将怎样影响派生类的实现呢？&lt;/p&gt;
&lt;h3 id=&#34;1371-第一种情况派生类不使用new&#34;&gt;13.7.1 第一种情况：派生类不使用new&lt;/h3&gt;
&lt;p&gt;假设基类使用了动态内存分配，基类中包含了构造函数使用&lt;code&gt;new&lt;/code&gt;时需要的特殊方法：析构函数、复 制构造函数和重载赋值运算符。如例子中的 &lt;code&gt;baseDMA&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;现在，从 &lt;code&gt;baseDMA&lt;/code&gt; 派生出 &lt;code&gt;lackDMA&lt;/code&gt; 类，而后者不使用 &lt;code&gt;new&lt;/code&gt;，也未包含其他一些不常用的、需要特殊处理的设计特性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;class lacksDMA: public baseDMA {
private:
    char color[40];
public:
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是否需要为lackDMA类定义显式析构函数、复制构造函数和赋值运算符呢？不需要。&lt;/p&gt;
&lt;p&gt;首先，来看是否需要析构函数。如果没有定义析构函数，编译器将 定义一个不执行任何操作的默认构造函数。实际上，派生类的默认构造 函数总是要进行一些操作：执行自身的代码后调用基类析构函数。因为 我们假设lackDMA成员不需执行任何特殊操作，所以默认析构函数是合 适的。&lt;/p&gt;
&lt;p&gt;接着来看复制构造函数。第12章介绍过，默认复制构造函数执行成 员复制，这对于动态内存分配来说是不合适的，但对于新的lacksDMA 成员来说是合适的。因此只需考虑继承的baseDMA对象。要知道，成员 复制将根据数据类型采用相应的复制方式，因此，将long复制到long中 是通过使用常规赋值完成的；但复制类成员或继承的类组件时，则是使 用该类的复制构造函数完成的。所以，lacksDMA类的默认复制构造函 数使用显式baseDMA复制构造函数来复制lacksDMA对象的baseDMA部 分。因此，默认复制构造函数对于新的lacksDMA成员来说是合适的， 同时对于继承的baseDMA对象来说也是合适的。&lt;/p&gt;
&lt;p&gt;对于赋值来说，也是如此。类的默认赋值运算符将自动使用基类的 赋值运算符来对基类组件进行赋值。因此，默认赋值运算符也是合适的。&lt;/p&gt;
&lt;h3 id=&#34;1372-第二种情况派生类使用new&#34;&gt;13.7.2 第二种情况：派生类使用new&lt;/h3&gt;
&lt;p&gt;在这种情况下，必须为派生类定义显式析构函数、复制构造函数和 赋值运算符。&lt;/p&gt;
&lt;p&gt;总之，当基类和派生类都采用动态内存分配时，派生类的析构函 数、复制构造函数、赋值运算符都必须使用相应的基类方法来处理基类 元素。这种要求是通过三种不同的方式来满足的。对于析构函数，这是 自动完成的；对于构造函数，这是通过在初始化成员列表中调用基类的 复制构造函数来完成的；如果不这样做，将自动调用基类的默认构造函 数。对于赋值运算符，这是通过使用作用域解析运算符显式地调用基类 的赋值运算符来完成的。&lt;/p&gt;
&lt;h3 id=&#34;1373-使用动态内存分配和友元的继承示例&#34;&gt;13.7.3 使用动态内存分配和友元的继承示例&lt;/h3&gt;
&lt;h2 id=&#34;138-类设计回顾&#34;&gt;13.8 类设计回顾&lt;/h2&gt;
&lt;h3 id=&#34;1381-编译器生成的成员函数&#34;&gt;13.8.1 编译器生成的成员函数&lt;/h3&gt;
&lt;p&gt;编译器会自动生成一些公有成员函数——特殊成员 函数。这表明这些特殊成员函数很重要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;默认构造函数，要么没有参数，要么所有的参数都有默认值。如果没 有定义任何构造函数，编译器将定义默认构造函数，让我们能够创建对象；&lt;/li&gt;
&lt;li&gt;复制构造函数，接受其所属类的对象作为参数。如果程序没有使用（显式或隐式）复制构造函数，编译器将提供原型，但不提供函数定义；否则，程序将定义一个执行成员初始化的复制构造函数；&lt;/li&gt;
&lt;li&gt;赋值运算符，默认的赋值运算符用于处理同类对象之间的赋值。不要将赋值与初 始化混淆了。&lt;strong&gt;如果语句创建新的对象，则使用初始化；如果语句修改已有对象的值，则是赋值&lt;/strong&gt;；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1382-其他的类方法&#34;&gt;13.8.2 其他的类方法&lt;/h3&gt;
&lt;p&gt;定义类时，还需要注意其他几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造函数。构造函数不同于其他类方法，因为它创建新的对象，而其他类方法 只是被现有的对象调用。这是构造函数不被继承的原因之一。继承意味着派生类对象可以使用基类的方法，然而，&lt;strong&gt;构造函数在完成其工作之前，对象并不存在&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;析构函数。一定要定义显式析构函数来释放类构造函数使用new分配的所有内 存，并完成类对象所需的任何特殊的清理工作。对于基类，即使它不需 要析构函数，也应提供一个虚析构函数；&lt;/li&gt;
&lt;li&gt;转换。使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换。将可转换的类型传递给以类为参数的函数时，&lt;strong&gt;将调用转换构造函数&lt;/strong&gt;。在带一个参数的构造函数原型中使用 &lt;code&gt;explicit&lt;/code&gt;将禁止进行隐式转换， 但仍允许显式转换：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;190&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210815165206668.png&#34; alt=&#34;image-20210815165206668&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;要将类对象转换为其他类型，应定义转换函数（参见第11章）。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;按值传递对象与传递引用。编写使用对象作为参数的函数时，&lt;strong&gt;应按引用而不是按值来传递对象。这样做的原因之一是为了提高效率&lt;/strong&gt;。按值传递对象涉及到生成 临时拷贝，即调用复制构造函数，然后调用析构函数。调用这些函数需 要时间，复制大型对象比传递引用花费的时间要多得多。如果函数不修 改对象，应将参数声明为const引用。按引用传递对象的另外一个原因是，在继承使用虚函数时，被定义 为接受基类引用参数的函数可以接受派生类；&lt;/li&gt;
&lt;li&gt;返回对象和返回引用。有些成员函数直接返回对 象，而另一些则返回引用。有时方法必须返回对象，但如果可以不返回对象，则应返回引用。如果函数返回在函数中创建的临时对象，则不要使用引用，而是返回该对象。&lt;strong&gt;如果函数返回的是通过引用或指针传递给它的对象，则应按引用返回对象&lt;/strong&gt;；&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;191&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210815163426527.png&#34; alt=&#34;image-20210815163426527&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;使用const。 使用const来确保方法不修改调用它的对象。如果函数将参数声明为指向const的引用或指针，则不能将该 参数传递给另一个函数，除非后者也确保了参数不会被修改（即，确保const对const）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1383-公有继承的考虑因素&#34;&gt;13.8.3 公有继承的考虑因素&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;is-a 关系。表示is-a关系的方式之一是，无需进行显式类型转换，基类指针就可以指向派生类对象，基类引用可以引用派生类对象。另外， 反过来是行不通的，即不能在不进行显式类型转换的情况下，将派生类指针或引用指向基类对象；&lt;/li&gt;
&lt;li&gt;什么不能被继承：构造函数不能继承；析构函数不能继承；赋值运算符不能继承；&lt;/li&gt;
&lt;li&gt;赋值运算符；&lt;/li&gt;
&lt;li&gt;私有成员与保护成员；&lt;/li&gt;
&lt;li&gt;虚方法。如果希望派生类 能够重新定义方法，则应在基类中将方法定义为虚的；如果不希望重新定义方法，则不必将其声明为虚的，这样虽然无法禁止他人重新定义方法，但表达了这样的意思：您不 希望它被重新定义；&lt;/li&gt;
&lt;li&gt;析构函数；&lt;/li&gt;
&lt;li&gt;友元函数。由于友元函数并非类成员，因此不能继承。然而，您可能希望派生 类的友元函数能够使用基类的友元函数。为此，可以通过强制类型转换将派生类引用或指针转换为基类引用或指针，然后使用转换后的指针 或引用来调用基类的友元函数：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;192&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210815164304163.png&#34; alt=&#34;image-20210815164304163&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;关于使用基类方法的说明：
&lt;ul&gt;
&lt;li&gt;派生类对象自动使用继承而来的基类方法，如果派生类没有重新定 义该方法；&lt;/li&gt;
&lt;li&gt;派生类的构造函数自动调用基类的构造函数；&lt;/li&gt;
&lt;li&gt;派生类的构造函数自动调用基类的默认构造函数，如果没有在成员初始化列表中指定其他构造函数；&lt;/li&gt;
&lt;li&gt;派生类构造函数显式地调用成员初始化列表中指定的基类构造函数；&lt;/li&gt;
&lt;li&gt;派生类方法可以使用作用域解析运算符来调用公有的和受保护的基类方法；&lt;/li&gt;
&lt;li&gt;派生类的友元函数可以通过强制类型转换，将派生类引用或指针转 换为基类引用或指针，然后使用该引用或指针来调用基类的友元函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1384-类函数小结&#34;&gt;13.8.4 类函数小结&lt;/h3&gt;
&lt;p&gt;C++类函数有很多不同的变体，其中有些可以继承，有些不可以。 有些运算符函数既可以是成员函数，也可以是友元，而有些运算符函数 只能是成员函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210815164804696.png&#34; alt=&#34;image-20210815164804696&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210815164826218.png&#34; alt=&#34;image-20210815164826218&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;139-总结&#34;&gt;13.9 总结&lt;/h2&gt;
&lt;p&gt;继承通过使用已有的类（基类）定义新的类（派生类），使得能够 根据需要修改编程代码。基类的析构函数通常应当是虚的。&lt;/p&gt;
&lt;p&gt;如果要将类用作基类，则可以将成员声明为保护的，而不是私有 的，这样，派生类将可以直接访问这些成员。&lt;/p&gt;
&lt;p&gt;可以考虑定义一个ABC：只定义接口，而不涉及实现。例如，可以 定义抽象类Shape，然后使用它派生出具体的形状类，如Circle和 Square。ABC必须至少包含一个纯虚方法，可以在声明中的分号前面加 上=0来声明纯虚方法。&lt;/p&gt;
&lt;h1 id=&#34;第十四章-c中的代码重用&#34;&gt;第十四章 C++中的代码重用&lt;/h1&gt;
&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;has-a 关系；&lt;/li&gt;
&lt;li&gt;包含对象成员的类；&lt;/li&gt;
&lt;li&gt;模板类valarray&lt;/li&gt;
&lt;li&gt;私有和保护继承；&lt;/li&gt;
&lt;li&gt;多重继承；&lt;/li&gt;
&lt;li&gt;虚基类；&lt;/li&gt;
&lt;li&gt;创建类模板；&lt;/li&gt;
&lt;li&gt;使用类模板；&lt;/li&gt;
&lt;li&gt;模板的具体化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;141-包含对象成员的类&#34;&gt;14.1 包含对象成员的类&lt;/h2&gt;
&lt;h3 id=&#34;1411-valarray类简介&#34;&gt;14.1.1 valarray类简介&lt;/h3&gt;
&lt;p&gt;valarray类是由头文件 &lt;code&gt;valarray&lt;/code&gt; 支持的。&lt;strong&gt;这个类用于处理数值，它支持诸如将数组中所有元素的值相加以及在数组中找出最大和最小的值等操作&lt;/strong&gt;。valarray被定义为一个模板类，以便能够处理不同的数据类型。例子：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;193&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210815170242081.png&#34; alt=&#34;image-20210815170242081&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;从中可知，可以创建长度为零的空数组、指定长度的空数组、所有元素度被初始化为指定值的数组、用常规数组中的值进行初始化的数组。&lt;/p&gt;
&lt;p&gt;这个类有一些内置方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;operator：访问各个元素；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size()&lt;/code&gt;: 返回包含的元素数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sum()&lt;/code&gt;: 返回所有元素的总和；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max()&lt;/code&gt;: 返回最大的元素；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min()&lt;/code&gt;: 返回最小的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等等，https://cplusplus.com/reference/valarray/valarray/ 。&lt;/p&gt;
&lt;h3 id=&#34;1412-student类的设计&#34;&gt;14.1.2 Student类的设计&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;194&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210815170944251.png&#34; alt=&#34;image-20210815170944251&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;195&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210815172143416.png&#34; alt=&#34;image-20210815172143416&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;142-私有继承&#34;&gt;14.2 私有继承&lt;/h2&gt;
&lt;p&gt;C++还有另一种实现has-a关系的途径——私有继承。使用私有继 承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着 基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成 员函数中使用它们。&lt;/p&gt;
&lt;p&gt;要进行私有继承，请使用关键字 &lt;code&gt;private&lt;/code&gt; 而不是 &lt;code&gt;public&lt;/code&gt; 来定义类（实 际上，&lt;code&gt;private&lt;/code&gt;是默认值，因此省略访问限定符也将导致私有继承）。&lt;/p&gt;
&lt;p&gt;使用私有继承时，只能在派生类的方法中使用基类的方法。&lt;/p&gt;
&lt;p&gt;用类名显式地限定函数名不适合于友元函数，这是因为友元不属于 类。然而，可以通过显式地转换为基类来调用正确的函数。&lt;/p&gt;
&lt;p&gt;如果两个基类都提供了函数operator&amp;lt;&amp;lt;( )，由于这个类使用的是多重继承，编译器将无法确定 应转换成哪个基类。&lt;/p&gt;
&lt;h3 id=&#34;1422-使用包含还是私有继承&#34;&gt;14.2.2 使用包含还是私有继承&lt;/h3&gt;
&lt;p&gt;大多数C++程序员倾向于使用包含。首先，它易于理 解。类声明中包含表示被包含类的显式命名对象，代码可以通过名称引 用这些对象，而使用继承将使关系更抽象。其次，继承会引起很多问 题，尤其从多个基类继承时，可能必须处理很多问题，如包含同名方法 的独立的基类或共享祖先的独立基类。总之，使用包含不太可能遇到这 样的麻烦。另外，包含能够包括多个同类的子对象。如果某个类需要3 个string对象，可以使用包含声明3个独立的string成员。而继承则只能使 用一个这样的对象（当对象都没有名称时，将难以区分）。&lt;/p&gt;
&lt;p&gt;然而，私有继承所提供的特性确实比包含多。例如，假设类包含保 护成员（可以是数据成员，也可以是成员函数），则这样的成员在派生 类中是可用的，但在继承层次结构外是不可用的。如果使用组合将这样 的类包含在另一个类中，则后者将不是派生类，而是位于继承层次结构 之外，因此不能访问保护成员。但通过继承得到的将是派生类，因此它 能够访问保护成员。&lt;/p&gt;
&lt;p&gt;另一种需要使用私有继承的情况是需要重新定义虚函数。派生类可 以重新定义虚函数，但包含类不能。使用私有继承，重新定义的函数将 只能在类中使用，而不是公有的。&lt;/p&gt;
&lt;h3 id=&#34;1423-保护继承&#34;&gt;14.2.3 保护继承&lt;/h3&gt;
&lt;p&gt;保护继承是私有继承的变体。保护继承在列出基类时使用关键字 &lt;code&gt;protected&lt;/code&gt;。使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;196&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210815194347832.png&#34; alt=&#34;image-20210815194347832&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1424-使用using重新定义访问权限&#34;&gt;14.2.4 使用using重新定义访问权限&lt;/h3&gt;
&lt;p&gt;使用保护派生或私有派生时，基类的公有成员将成为保护成员或私 有成员。假设要让基类的方法在派生类外面可用，方法之一是定义一个使用该基类方法的派生类方法。&lt;/p&gt;
&lt;p&gt;另一种方法是，将函数调用包装在另一个函数调用中，即使用一个 using声明（就像名称空间那样）来指出派生类可以使用特定的基类成 员，即使采用的是私有派生。&lt;/p&gt;
&lt;h2 id=&#34;143-多重继承&#34;&gt;14.3 多重继承&lt;/h2&gt;
&lt;p&gt;【短期内不会用到，多重继承、模板类和虚基类等没细看。】&lt;br&gt;
&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210815202024284.png&#34; alt=&#34;image-20210815202024284&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;197&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210815202112888.png&#34; alt=&#34;image-20210815202112888&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;145-总结&#34;&gt;14.5 总结&lt;/h2&gt;
&lt;p&gt;C++提供了几种重用代码的手段。无论使用哪种继 承，基类的公有接口都将成为派生类的内部接口。这有时候被称为继承 实现，但并不继承接口，因为派生类对象不能显式地使用基类的接口。 因此，不能将派生对象看作是一种基类对象。&lt;/p&gt;
&lt;p&gt;还可以通过开发包含对象成员的类来重用类代码。这种方法被称为 包含、层次化或组合，它建立的也是has-a关系。另一方面，如果需要使用某个类的几个对象，则用包含更适合。&lt;/p&gt;
&lt;p&gt;多重继承（MI）使得能够在类设计中重用多个类的代码。&lt;/p&gt;
&lt;h1 id=&#34;第十五章-友元-异常和其他&#34;&gt;第十五章 友元、异常和其他&lt;/h1&gt;
&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;友元类；&lt;/li&gt;
&lt;li&gt;友元类方法；&lt;/li&gt;
&lt;li&gt;嵌套类；&lt;/li&gt;
&lt;li&gt;引发异常、&lt;code&gt;try&lt;/code&gt;块和&lt;code&gt;catch&lt;/code&gt;块；&lt;/li&gt;
&lt;li&gt;异常类；&lt;/li&gt;
&lt;li&gt;运行阶段类型识别（RTTI）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&lt;/code&gt; 和 &lt;code&gt;typeid&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt;、&lt;code&gt;const_cast&lt;/code&gt; 和 &lt;code&gt;reiterpret_cast&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;198&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210815204948714.png&#34; alt=&#34;image-20210815204948714&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;2．bad_alloc异常和new&lt;/p&gt;
&lt;p&gt;对于使用new导致的内存分配问题，C++的&lt;strong&gt;最新处理方式是让new引发bad_alloc异常&lt;/strong&gt;。头文件new包含bad_alloc类的声明，它是从exception 类公有派生而来的。但&lt;strong&gt;在以前，当无法分配请求的内存量时，new返回 一个空指针&lt;/strong&gt;，然后我们可以 &lt;code&gt;exit(EXIT_FAILURE)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;156-总结&#34;&gt;15.6 总结&lt;/h2&gt;
&lt;p&gt;友元使得能够为类开发更灵活的接口。类可以将其他函数、其他类 和其他类的成员函数作为友元。在某些情况下，可能需要使用前向声 明，需要特别注意类和方法声明的顺序，以正确地组合友元。&lt;/p&gt;
&lt;p&gt;嵌套类是在其他类中声明的类，它有助于设计这样的助手类，即实 现其他类，但不必是公有接口的组成部分。&lt;/p&gt;
&lt;h1 id=&#34;第十六章-string类和标准模板库&#34;&gt;第十六章 string类和标准模板库&lt;/h1&gt;
&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准C++ string类；&lt;/li&gt;
&lt;li&gt;模板auto_ptr、unique_ptr 和 shared_ptr；&lt;/li&gt;
&lt;li&gt;标准模板库；&lt;/li&gt;
&lt;li&gt;容器类；&lt;/li&gt;
&lt;li&gt;迭代器&lt;/li&gt;
&lt;li&gt;函数对象；&lt;/li&gt;
&lt;li&gt;STL算法&lt;/li&gt;
&lt;li&gt;模板initializer_list&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1641-为何使用迭代器&#34;&gt;16.4.1 为何使用迭代器&lt;/h3&gt;
&lt;p&gt;模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型。&lt;/p&gt;
&lt;h1 id=&#34;第十七章-输入-输出和文件&#34;&gt;第十七章 输入、输出和文件&lt;/h1&gt;
&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++ 角度的输入和输出；&lt;/li&gt;
&lt;li&gt;iostream 类系列；&lt;/li&gt;
&lt;li&gt;重定向；&lt;/li&gt;
&lt;li&gt;ostream；&lt;/li&gt;
&lt;li&gt;格式化输出；&lt;/li&gt;
&lt;li&gt;istream类方法；&lt;/li&gt;
&lt;li&gt;流状态；&lt;/li&gt;
&lt;li&gt;文件I/O；&lt;/li&gt;
&lt;li&gt;使用 ifstream 类从文件输入；&lt;/li&gt;
&lt;li&gt;使用 ofstream 类输出到文件；&lt;/li&gt;
&lt;li&gt;使用 fstream 类进行文件输入和输出；&lt;/li&gt;
&lt;li&gt;命令行处理；&lt;/li&gt;
&lt;li&gt;二进制文件；&lt;/li&gt;
&lt;li&gt;随机文件访问；&lt;/li&gt;
&lt;li&gt;内核格式化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;171-c输入和输出概述&#34;&gt;17.1 C++输入和输出概述&lt;/h2&gt;
&lt;p&gt;C++依赖于C++的I/O解决方案，而不是C语言的I/O解决方 案，前者是在头文件iostream（以前为iostream.h）和fstream（以前为 fstream.h）中定义一组类。&lt;/p&gt;
&lt;h3 id=&#34;1711-流和缓冲区&#34;&gt;17.1.1 流和缓冲区&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;C++程序把输入和输出看作字节流&lt;/strong&gt;。输入时，程序从输入流中抽取字节；输出时，程序将字节插入到输出流中。&lt;/p&gt;
&lt;p&gt;输入流中的字节可能来自键盘，也可能来自存储设备（如硬 盘）或其他程序。同样，输出流中的字节可以流向屏幕、打印机、存储 设备或其他程序。流充当了程序和流源或流目标之间的桥梁。&lt;/p&gt;
&lt;p&gt;C++程序只是检查字节流，而不需要知道字节来自何方。同理，通过使 用流，C++程序处理输出的方式将独立于其去向。因此管理输入包含两 步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将流与输入去向的程序关联起来；&lt;/li&gt;
&lt;li&gt;将流与文件连接起来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;换句话说，输入流需要两个连接，每端各一个。文件端部连接提供了流的来源，程序端连接将流的流出部分转储到程序中（文件端连接可以是文件，也可以是设备，如键盘）。同样，对输出的管理包括将输出流连接到程序以及将输出目标与流关联起来。这就像将字节（而不是水）引入到水管中（参见图17.1）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;199&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816095844394.png&#34; alt=&#34;image-20210816095844394&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通常，通过使用缓冲区可以更高效地处理输入和输出。缓冲区是用作中介的内存块，它是将信息从设备传输到程序或从程序传输给设备的临时存储工具。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;200&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816100336241.png&#34; alt=&#34;image-20210816100336241&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;C++程序通常在用户按下回车 键时刷新输入缓冲区。对于屏幕输出，C++程序通 常在用户发送换行符时刷新输出缓冲区。程序也可能会在其他情况下刷新输入，例如输入即将到来时，这取决于实现。&lt;/p&gt;
&lt;h3 id=&#34;1712-流-缓冲区和iostream文件&#34;&gt;17.1.2 流、缓冲区和iostream文件&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;201&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816100640816.png&#34; alt=&#34;image-20210816100640816&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;cin对象对应于标准输入流；&lt;/li&gt;
&lt;li&gt;cout对象与标准输出流相对应；&lt;/li&gt;
&lt;li&gt;cerr对象与标准错误流相对应，可用于显示错误消息。这个流没有 被缓冲，这意味着信息将被直接发送给屏幕，而不会等到缓冲区填 满或新的换行符；&lt;/li&gt;
&lt;li&gt;clog对象也对应着标准错误流。在默认情况下，这个流被关联到标 准输出设备（通常为显示器），这个流被缓冲；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1713-重定向&#34;&gt;17.1.3 重定向&lt;/h3&gt;
&lt;p&gt;标准输入和输出流通常连接着键盘和屏幕。重定向这个方法可以改变标准输入和标准输出。通过输入重定向（&lt;code&gt;&amp;lt;&lt;/code&gt;）和输出重定向（&lt;code&gt;&amp;gt;&lt;/code&gt;）可以将输入和输出重置为文件。在 UNIX和Linux中，运算符 &lt;code&gt;2&amp;gt;&lt;/code&gt; 重定向标准错误。&lt;/p&gt;
&lt;h2 id=&#34;172-使用cout进行输出&#34;&gt;17.2 使用cout进行输出&lt;/h2&gt;
&lt;h3 id=&#34;1722-其他ostream方法&#34;&gt;17.2.2 其他ostream方法&lt;/h3&gt;
&lt;p&gt;除了各种 &lt;code&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt; 函数外，&lt;code&gt;ostream&lt;/code&gt; 类还提供了 &lt;code&gt;put()&lt;/code&gt; 方法和&lt;code&gt;write()&lt;/code&gt; 方法，前者用于显示字符，后者用于显示字符串。&lt;/p&gt;
&lt;p&gt;在程序清单17.3的输出中各列并没有对齐，这是因为数字的字段宽度不相同。可以使用width成员函数将长度不同的数字放到宽度相同的字段中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;width()&lt;/code&gt; 方法只影响将显示的下一个项目，然后字段宽度将恢复为默认值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;cout &amp;lt;&amp;lt; &amp;quot;#&amp;quot;;
cout.width(12);

cout &amp;lt;&amp;lt; 12 &amp;lt;&amp;lt; &amp;quot;#&amp;quot; &amp;lt;&amp;lt; 24 &amp;lt;&amp;lt; &amp;quot;#\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;202&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816104442007.png&#34; alt=&#34;image-20210816104442007&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;12被放到宽度为12个字符的字段的最右边，这被称为右对齐。然后，字段宽度恢复为默认值，并将两个#符号以及24放在宽度与它们的长度相等的字段中。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;设置填充字符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在默认情况下，cout用空格填充字段中未被使用的部分，可以用 fill( )成员函数来改变填充字符。例如，下面的函数调用将填充字符改为星号：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;cout.fill(&#39;*&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;设置浮点数的显示精度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;C++的默认精度为6位（但末尾的0将不显 示）。&lt;code&gt;precision()&lt;/code&gt; 成员函数使得能够选择其他值。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;在谈 &lt;code&gt;setf()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;203&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816105318255.png&#34; alt=&#34;image-20210816105318255&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;173-使用-cin-进行输入&#34;&gt;17.3 使用 &lt;code&gt;cin&lt;/code&gt; 进行输入&lt;/h2&gt;
&lt;h3 id=&#34;1733-其他istream类方法&#34;&gt;17.3.3 其他istream类方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;get( )&lt;/code&gt; 和 &lt;code&gt;getline( )&lt;/code&gt; 方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数 &lt;code&gt;get(char&amp;amp;)&lt;/code&gt; 和 &lt;code&gt;get(void)&lt;/code&gt; 提供不跳过空白的单字符输入功能；&lt;/li&gt;
&lt;li&gt;函数 &lt;code&gt;get(char*, int, char)&lt;/code&gt; 和 &lt;code&gt;getline(char*, int, char)&lt;/code&gt; 在默认情况下读取整行而不是一个单词。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;204&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816110518509.png&#34; alt=&#34;image-20210816110518509&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这里的重点是，&lt;strong&gt;通过使用 &lt;code&gt;get(ch)&lt;/code&gt;，代码读取、显示并考虑空格和可打印字符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设程序使用的是 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;，那么代码将跳过空格，因此最后的输出就压缩成了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IC++clearly.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并且程序由于&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;运算符跳过了最后的换行符，所以 &lt;code&gt;while&lt;/code&gt; 循环不会结束。&lt;/p&gt;
&lt;p&gt;到达文件尾后（不管是真正的文件尾还是模拟的文件尾）， &lt;code&gt;cin.get(void)&lt;/code&gt; 都将返回值 &lt;code&gt;EOF&lt;/code&gt;——头文件 &lt;code&gt;iostream&lt;/code&gt; 提供的一个符号常量。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;205&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816113232207.png&#34; alt=&#34;image-20210816113232207&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这里应将 &lt;code&gt;ch&lt;/code&gt; 的类型声明为 &lt;code&gt;int&lt;/code&gt;，而不是 &lt;code&gt;char&lt;/code&gt;，因为值 &lt;code&gt;EOF&lt;/code&gt; 可能无法使 用 &lt;code&gt;char&lt;/code&gt; 类型来表示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;206&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816113531629.png&#34; alt=&#34;image-20210816113531629&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;2．采用哪种单字符输入形式&lt;/p&gt;
&lt;p&gt;假设可以选择 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;get(char &amp;amp;)&lt;/code&gt; 或 &lt;code&gt;get(void)&lt;/code&gt;，应使用哪一个呢？ 首先，应确定是否希望跳过空白。&lt;strong&gt;如果跳过空白更方便，则使用抽取运算符 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果希望程序检查每个字符，则使用 &lt;code&gt;get()&lt;/code&gt; 方法，例如，计算字数的程序可以使用空格来判断单词何时结束。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;get()&lt;/code&gt; 方法中，&lt;strong&gt;&lt;code&gt;get(char &amp;amp;)&lt;/code&gt;的接口更佳&lt;/strong&gt;。&lt;code&gt;get(void)&lt;/code&gt;的主要优点是，它与标准C语言中的 &lt;code&gt;getchar()&lt;/code&gt; 函数极其类似，这意味着可以通过包含&lt;code&gt;iostream&lt;/code&gt;（而不是 &lt;code&gt;stdio.h&lt;/code&gt;），并用 &lt;code&gt;cin.get()&lt;/code&gt; 替换所有的 &lt;code&gt;getchar()&lt;/code&gt;，用 &lt;code&gt;cout.put(ch)&lt;/code&gt; 替换所有的 &lt;code&gt;putchar(ch)&lt;/code&gt;，来将C程序转换为C++程序。&lt;/p&gt;
&lt;p&gt;3．字符串输入：&lt;code&gt;getline()&lt;/code&gt;、&lt;code&gt;get()&lt;/code&gt; 和 &lt;code&gt;ignore()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;getline( )成员函 数和get( )的字符串读取版本都读取字符串，它们的函数特征标相同（这 是从更为通用的模板声明简化而来的）：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;207&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816114047447.png&#34; alt=&#34;image-20210816114047447&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;第一个参数是用于放置输入字符串的内存单元的地址。第二个参数比要读取的最大字符数大1（额外的一个字符用于存储结尾的空字符， 以便将输入存储为一个字符串）。&lt;strong&gt;第三个参数指定用作分界符的字符， 只有两个参数的版本将换行符用作分界符&lt;/strong&gt;。上述函数都在读取最大数目的字符或遇到换行符后为止。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get()&lt;/code&gt; 和 &lt;code&gt;getline()&lt;/code&gt; 之间的主要区别在于，&lt;strong&gt;&lt;code&gt;get()&lt;/code&gt; 将换行符留在输入流中，这样接下来的输入操作首先看到是将是换行符， 而 &lt;code&gt;gerline()&lt;/code&gt; 抽取并丢弃输入流中的换行符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;第三个参数用于指定分界符，遇到分界字符后， 输入将停止，即使还未读取最大数目的字符。在默认情况下，如果在读取指定数目的字符之前到达行尾，这两种方法都将停止读取输 入。并且，&lt;code&gt;get()&lt;/code&gt; 将分界字符留在输入队列中，而&lt;code&gt;getline()&lt;/code&gt; 不保留。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ignore()&lt;/code&gt; 成员函数，该函数接受两个参数：一个是数字，指定要读取的最大字符数；另一个是字符，用作输入分界符。下面的函数调用&lt;strong&gt;读取并丢弃接下来的255个字符或直到到达第一个换行符&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;cin.ignore(255, &#39;\n&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原型为两个参数提供的默认值为1和 &lt;code&gt;EOF&lt;/code&gt;， 该函数的返回类型为 &lt;code&gt;istream &amp;amp;&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;意外字符串输入&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;get(char *, int)&lt;/code&gt; 和 &lt;code&gt;getline( )&lt;/code&gt; 的某些输入形式将影响流状态。与其他输 入函数一样，这两个函数在遇到文件尾时将设置 &lt;code&gt;eofbit&lt;/code&gt;，&lt;strong&gt;遇到流被破坏 （如设备故障）时将设置 &lt;code&gt;badbit&lt;/code&gt;&lt;/strong&gt;。另外两种特殊情况是无输入以及输入到达或超过函数调用指定的最大字符数。&lt;/p&gt;
&lt;p&gt;假设输入队列中的字符数等于或超过了输入方法指定的最大字 符数。首先，来看&lt;code&gt;getline()&lt;/code&gt; 和下面的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;char temp[30];
while (cin.getline(temp, 30))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getline( )方法将从输入队列中读取字符，将它们放到temp数组的元 素中，直到（按测试顺序）到达文件尾、将要读取的字符是换行符或存 储了29个字符为止。如果遇到文件尾，则设置eofbit；如果将要读取的 字符是换行符，则该字符将被读取并丢弃；&lt;strong&gt;如果读取了29个字符，并且下一个字符不是换行符，则设置failbit&lt;/strong&gt;。因此，包含30个或更多字符的输入行将终止输入。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get(char *, int)&lt;/code&gt; 方法首先测试字符数，然后测试是否为 文件尾以及下一个字符是否是换行符。如果它读取了最大数目的字符，则不设置 &lt;code&gt;failbit&lt;/code&gt; 标记。然而，由此可以知道终止读取是否是由于输入字 符过多引起的。可以用 &lt;code&gt;peek()&lt;/code&gt;（下一节）来查看下一个输入字符。 如果它是换行符，则说明 &lt;code&gt;get()&lt;/code&gt; 已读取了整行；如果不是换行符，则说明  &lt;code&gt;get()&lt;/code&gt; 是在到达行尾前停止的。这种技术对&lt;code&gt;getline()&lt;/code&gt; 不适用，因为 &lt;code&gt;getline()&lt;/code&gt; 读取并丢弃换行符，因此查看下一个字符无法知道任何情况。然而， 如果使用的是 &lt;code&gt;get()&lt;/code&gt;，则可以知道是否读取了整个一行。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;208&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816120636318.png&#34; alt=&#34;image-20210816120636318&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;与 &lt;code&gt;getline()&lt;/code&gt; 和 &lt;code&gt;get()&lt;/code&gt; 不同的是，&lt;strong&gt;&lt;code&gt;read()&lt;/code&gt; 不会在输入后加上空值字符， 因此不能将输入转换为字符串&lt;/strong&gt;。&lt;code&gt;read()&lt;/code&gt; 方法不是专为键盘输入设计的， 它最常与 &lt;code&gt;ostream write()&lt;/code&gt; 函数结合使用，来完成文件输入和输出。该方法的返回类型为 &lt;code&gt;istream &amp;amp;&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;209&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816145101989.png&#34; alt=&#34;image-20210816145101989&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;174-文件输入和输出&#34;&gt;17.4 文件输入和输出&lt;/h2&gt;
&lt;p&gt;重定向虽然可以提供一些文件 支持，但它比显式程序中的文件I/O的局限性更大。另外，重定向来自操作系统，而非C++，因此并非所有系统都有这样的功能。&lt;/p&gt;
&lt;p&gt;要写入文件，需要创建一个&lt;code&gt;ofstream&lt;/code&gt;对象，并使用 &lt;code&gt;ostream&lt;/code&gt; 方法，如 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 插入运算符或 &lt;code&gt;write()&lt;/code&gt;。要读取文件，需要创建一个 &lt;code&gt;ifstream&lt;/code&gt; 对象，并使用 &lt;code&gt;istream&lt;/code&gt; 方法，如 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 抽取运算符或 &lt;code&gt;get()&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;1741-简单的文件-io&#34;&gt;17.4.1 简单的文件 I/O&lt;/h3&gt;
&lt;p&gt;程序写文件需要包含头文件 &lt;code&gt;fstream&lt;/code&gt;，并这样做：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明并创建一个 &lt;code&gt;ofstream&lt;/code&gt; 对象来管理输出流；&lt;/li&gt;
&lt;li&gt;将该对象和特定文件关联起来，&lt;code&gt;open&lt;/code&gt; 方法；&lt;/li&gt;
&lt;li&gt;以 cout 的方式使用该对象，区别是输出将进入文件，而不是屏幕。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ostream&lt;/code&gt; 是 &lt;code&gt;ofstream&lt;/code&gt; 类的基类，因此可以使用所有的 &lt;code&gt;ostream&lt;/code&gt; 方法，包括各种插入运算符定义、格式化方法和控制符。&lt;code&gt;ofstream&lt;/code&gt; 类使用被缓冲的输出，因此程序在创建像 &lt;code&gt;fout&lt;/code&gt; 这样的 &lt;code&gt;ofstream&lt;/code&gt; 对象时，将为输出缓冲区分配空间。如果创建了两个 &lt;code&gt;ofstream&lt;/code&gt; 对象，程序将创建两个缓冲区，每个对象各一个。&lt;/p&gt;
&lt;p&gt;程序读取文件的要求与写入文件相似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个 &lt;code&gt;ifstream&lt;/code&gt; 对象来管理输入流；&lt;/li&gt;
&lt;li&gt;将该对象与特定的文件关联起来，&lt;code&gt;open()&lt;/code&gt;方法；&lt;/li&gt;
&lt;li&gt;以使用 &lt;code&gt;cin&lt;/code&gt; 的方式使用该对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入和输出一样，也是被缓冲的，因此创建ifstream对象与fin一 样，将创建一个由fin对象管理的输入缓冲区。与输出一样，通过缓冲， 传输数据的速度比逐字节传输要快得多。&lt;/p&gt;
&lt;p&gt;当输入和输出流对象过期（如程序终止）时，到文件的连接将自动 关闭。另外，也可以使用 &lt;code&gt;close()&lt;/code&gt; 方法来显式地关闭到文件的连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关闭这样的连接并不会删除流，而只是断开流到文件的连接&lt;/strong&gt;，但流管理装置仍被保留。关闭文件将刷新缓冲区，从而确保文件被更新。&lt;/p&gt;
&lt;h3 id=&#34;1742-流状态检查和-is_open&#34;&gt;17.4.2 流状态检查和 &lt;code&gt;is_open()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果一切顺利，则流状态为零（没有消息就是好消息）。其他状态都是通过将特定位设置为1来记录的。试图打开一个不存在的文件进行 输入时，将设置failbit位，因此可以这样进行检查：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;fin.open(argv[file]);
if (fin.fail()) {...}  // open attempt failed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于ifstream对象和istream对象一样，被放在需要bool类型的地方 时，将被转换为bool值，因此您也可以这样做：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;fin.open(argv[file]);
if (!fin) {...} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;较新的C++实现提供了一种更好的检查文件是否被打开的方 法——&lt;code&gt;is_open()&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;if (!fin.is_open()) {...}  // open attempt failed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种方式之所以更好，是因为它能够检测出其他方式不能检测出的 微妙问题：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;210&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816152004401.png&#34; alt=&#34;image-20210816152004401&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1743-打开多个文件&#34;&gt;17.4.3 打开多个文件&lt;/h3&gt;
&lt;p&gt;可能要依次处理一组文件。例如，可能要计算某个名称在10 个文件中出现的次数。在这种情况下，可以打开一个流，并将它依次关 联到各个文件。这在节省计算机资源方面，比为每个文件打开一个流的效率高。 使用这种方法，首先需要声明一个&lt;code&gt;ifstream&lt;/code&gt; 对象（不对它进行初始化），然后使用 &lt;code&gt;open()&lt;/code&gt; 方法将这个流与文件关联起来。例如，下面 是依次读取两个文件的代码：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;211&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816152403503.png&#34; alt=&#34;image-20210816152403503&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1744-命令行处理技术&#34;&gt;17.4.4 命令行处理技术&lt;/h3&gt;
&lt;p&gt;文件处理程序通常使用命令行参数来指定文件。命令行参数是用户 在输入命令时，在命令行中输入的参数。&lt;/p&gt;
&lt;p&gt;C++有一种让在命令行环境中运行的程序能够访问命令行参数的机制，方法是使用下面的 &lt;code&gt;main()&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;int main(int argc, char *argv[])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;argc&lt;/code&gt; 为命令行中的参数个数，其中&lt;strong&gt;包括命令名本身&lt;/strong&gt;。&lt;code&gt;argv&lt;/code&gt; 变量为一个指针，它指向一个指向 &lt;code&gt;char&lt;/code&gt; 的指针。例如：&lt;code&gt;argv[0]&lt;/code&gt; 是一个指针，指向存储第一个命令行参数的字符串的第一个字符，依此类推。也就是说， &lt;code&gt;argv[0]&lt;/code&gt;是命令行中的第一个字符串，依此类推。例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;wc report1 report2 report3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;则 &lt;code&gt;argc&lt;/code&gt; 为4，&lt;code&gt;argv[0]&lt;/code&gt; 为 &lt;code&gt;wc&lt;/code&gt;，&lt;code&gt;argv[1]&lt;/code&gt; 为 &lt;code&gt;report1&lt;/code&gt;，依此类推。&lt;/p&gt;
&lt;h3 id=&#34;1745-文件模式&#34;&gt;17.4.5 文件模式&lt;/h3&gt;
&lt;p&gt;文件模式描述的是文件将被如何使用：读、写、追加等。将流与文件关联时（无论是使用文件名初始化文件流对象，还是使用 &lt;code&gt;open()&lt;/code&gt; 方法），都可以提供指定文件模式的第二个参数，下表给出了第二个参数的具体信息。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;212&#34;&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816154243582.png&#34; alt=&#34;image-20210816154243582&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;ofstream fout(&amp;quot;text&amp;quot;, ios_base::out);                // 新写入
ofstream fout(&amp;quot;text&amp;quot;, ios_base::out|ios_base::app);  // 追加
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，C++ mode 是一个open mode值，如 &lt;code&gt;ios_base::in&lt;/code&gt;；而 c mode是相 应的 C模式字符串，如“r”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816163125203.png&#34; alt=&#34;image-20210816163125203&#34; loading=&#34;lazy&#34;&gt; &lt;img src=&#34;https://static.fungenomics.com/images/2021/08/image-20210816163153980.png&#34; alt=&#34;image-20210816163153980&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1746-随机存取&#34;&gt;17.4.6 随机存取&lt;/h3&gt;
&lt;p&gt;随机存取指的是直接移 动（不是依次移动）到文件的任何位置。&lt;/p&gt;
&lt;h4 id=&#34;使用临时文件&#34;&gt;使用临时文件&lt;/h4&gt;
&lt;p&gt;开发应用程序时，经常需要使用临时文件，这种文件的存在是短暂的，必须受程序控制。创建临时文件、复制另一个文件的内容并 删除文件其实都很简单。首先，需要为临时文件制定一个命名方案，但如何确保每个文件都 被指定了独一无二的文件名呢？&lt;code&gt;cstdio&lt;/code&gt; 中声明的 &lt;code&gt;tmpnam()&lt;/code&gt; 标准函数可以帮助您。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;char * tmpnam(char* pszName);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tmpnam()&lt;/code&gt; 函数创建一个临时文件名，将它放在 &lt;code&gt;pszName&lt;/code&gt; 指向的C-风格字符串中。常量  &lt;code&gt;L_tmpnam&lt;/code&gt; 和 &lt;code&gt;TMP_MAX&lt;/code&gt;（二者都是在cstdio中定义的）限制了文件名包含的字符数以及在确保当前目录中不生成重复文件名的情况下 &lt;code&gt;tmpnam()&lt;/code&gt; 可被调用的最多次数。下面是生成10个临时 文件名的代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Cpp&#34;&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;iostream&amp;gt;

int main() {
    using namespace std;
    cout &amp;lt;&amp;lt; &amp;quot;This system can generate up to &amp;quot; &amp;lt;&amp;lt; TMP_MAX
         &amp;lt;&amp;lt; &amp;quot; temporary names of up to &amp;quot; &amp;lt;&amp;lt; L_tmpnam
         &amp;lt;&amp;lt; &amp;quot; characters.\n&amp;quot;;
    char pszName[L_tmpnam] = {&#39;\0&#39;};
    cout &amp;lt;&amp;lt; &amp;quot;Here are ten names:\n&amp;quot;;
    for (int i=0; i&amp;lt;10; i++) {
        tmpnam(pszName);
        cout &amp;lt;&amp;lt; pszName &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更具体地说，使用tmpnam( )可以生成TMP_NAM个不同的文件名，其中每个文件名包含 的字符不超过L_tmpnam个。生成什么样的文件名取决于实现。&lt;/p&gt;
&lt;h2 id=&#34;175-内核格式化&#34;&gt;17.5 内核格式化&lt;/h2&gt;
&lt;h2 id=&#34;176-总结&#34;&gt;17.6 总结&lt;/h2&gt;
&lt;p&gt;流是进出程序的字节流。缓冲区是内存中的临时存储区域，是程序 与文件或其他I/O设备之间的桥梁。&lt;/p&gt;
&lt;p&gt;istream类定义了多个版本的抽取 运算符（&amp;gt;&amp;gt;），用于识别所有基本的C++类型，并将字符输入转换为这 些类型。get( )方法族和getline( )方法为单字符输入和字符串输入提供了 进一步的支持。同样，ostream类定义了多个版本的插入运算符 （&amp;lt;&amp;lt;），用于识别所有的C++基本类型，并将它们转换为相应的字符输 出。put( )方法对单字符输出提供了进一步的支持。wistream和wostream 类对宽字符提供了类似的支持。&lt;/p&gt;
&lt;p&gt;fstream文件提供了将iostream方法扩展到文件I/O的类定义。ifstream 类是从istream类派生而来的。通过将ifstream对象与文件关联起来，可 以使用所有的istream方法来读取文件。同样，通过将ofstream对象与文 件关联起来，可以使用ostream方法来写文件；通过将fstream对象与文件 关联起来，可以将输入和输出方法用于文件。&lt;/p&gt;
&lt;p&gt;要将文件与流关联起来，可以在初始化文件流对象时提供文件名， 也可以先创建一个文件流对象，然后用open( )方法将这个流与文件关联 起来。close( )方法终止流与文件之间的连接。类构造函数和open( )方法 接受可选的第二个参数，该参数提供文件模式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;seekg()&lt;/code&gt; 和 &lt;code&gt;seekp()&lt;/code&gt; 函数提供对文件的随机存取。这些类方法使得能够将文件指针放置到相对于文件开头、文件尾和当前位置的某个位置。&lt;code&gt;tellg()&lt;/code&gt; 和&lt;code&gt;tellp()&lt;/code&gt; 方法报告当前的文件位置。&lt;/p&gt;
">C++笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/linux-xi-tong-bian-cheng-bi-ji/"" data-c="
          &lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-ipv4流媒体广播项目分析&#34;&gt;1、IPv4流媒体广播项目分析&lt;/h3&gt;
&lt;h4 id=&#34;s端&#34;&gt;S端&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;多线程或多进程并发&lt;/li&gt;
&lt;li&gt;引入数据库或者使用&lt;/li&gt;
&lt;li&gt;解析文件系统存储&lt;/li&gt;
&lt;li&gt;流量控制&lt;/li&gt;
&lt;li&gt;网络套接字socket&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;c端&#34;&gt;c端&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;解码（avi、mp3）&lt;/li&gt;
&lt;li&gt;创建一个子进程（父进程用来接收数据，传递数据给子进程，子进程用来播放数据）&lt;/li&gt;
&lt;li&gt;进程间通信（多进程的实现以及多进程的关系）&lt;/li&gt;
&lt;li&gt;大量的I/O操作&lt;/li&gt;
&lt;li&gt;守护进程（系统日志的实现）&lt;/li&gt;
&lt;li&gt;典型I/O操作&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;参考书目&#34;&gt;参考书目&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;UNIX环境高级编程&lt;/li&gt;
&lt;li&gt;UNIX网络编程&lt;/li&gt;
&lt;li&gt;TCP/IP详解（卷一）&lt;/li&gt;
&lt;li&gt;深入理解计算机系统&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;br&gt;
&lt;h3 id=&#34;2-学习方法介绍&#34;&gt;2、学习方法介绍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;I/O（3,5章）&lt;/li&gt;
&lt;li&gt;文件系统（4,6,7章）&lt;/li&gt;
&lt;li&gt;并发(多进程，多线程、信号)&lt;/li&gt;
&lt;li&gt;IPC（Inter-Process Communication，进程间通信）&lt;br&gt;
第8章进程基础（涉及到多进程）&lt;br&gt;
13章守护进程&lt;br&gt;
15、16章&lt;/li&gt;
&lt;li&gt;注意事项：&lt;br&gt;
 1、弃用root用户&lt;br&gt;
 2、重构&lt;br&gt;
 3、课堂重点：项目，课堂代码，面试题，实验性题目&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;标准io介绍&#34;&gt;标准IO介绍&lt;/h3&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h3 id=&#34;fopen函数&#34;&gt;fopen函数&lt;/h3&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h3 id=&#34;fclose函数和文件权限问题&#34;&gt;fclose函数和文件权限问题&lt;/h3&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h3 id=&#34;fgetc和fputc&#34;&gt;fgetc和fputc&lt;/h3&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;h3 id=&#34;fread和fwrite&#34;&gt;fread和fwrite&lt;/h3&gt;
">Linux系统编程笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/xshell-bao-cuo-qing-kuang/"" data-c="
          &lt;p&gt;1、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WARNING! The remote SSH server rejected X11 forwarding request.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解决办法：（1）编辑文件：/etc/ssh/sshd_config，设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;X11Forwarding yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）配置Xshell 6连接属性，如下图，取消勾取即可&lt;br&gt;
SSH-隧道-x11转移去掉勾选&lt;/p&gt;
">xshell报错情况</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/c-yu-yan-zhi-zhen/"" data-c="
          &lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E7%90%86%E8%A7%A3%E6%95%B0%E7%BB%84&#34;&gt;一、理解数组&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%95%B0%E7%BB%84&#34;&gt;1.1 为什么要有数组？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89&#34;&gt;1.2 数组定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%BF%E7%94%A8&#34;&gt;1.3 数组元素的使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83&#34;&gt;二、内存分布&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C&#34;&gt;三、常见操作&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E9%81%8D%E5%8E%86&#34;&gt;3.1 数组元素的遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%E6%95%B0%E7%BB%84%E8%B5%8B%E5%88%9D%E5%80%BC&#34;&gt;3.2 数组赋初值&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84&#34;&gt;四、二维数组&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41-%E6%9C%AC%E8%B4%A8&#34;&gt;4.1 本质&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42-%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F%E5%9B%BE&#34;&gt;4.2 内存映像图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%B5%8B%E5%88%9D%E5%80%BC&#34;&gt;4.3 二维数组赋初值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#44-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86&#34;&gt;4.4 二维数组的遍历&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2&#34;&gt;五、字符数组与字符串&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51-%E5%AD%97%E7%AC%A6%E4%B8%B2&#34;&gt;5.1 字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52-%E8%BF%90%E7%AE%97%E7%AC%A6sizeof&#34;&gt;5.2 运算符：sizeof()&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#521-sizeof%E7%9A%84%E7%94%A8%E6%B3%95&#34;&gt;5.2.1 sizeof()的用法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#5211-sizeof%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%A7%B0&#34;&gt;5.2.1.1 sizeof(数据类型名称)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5212-sizeof%E5%8F%98%E9%87%8F%E5%90%8D%E7%A7%B0%E6%88%96%E6%95%B0%E7%BB%84%E5%90%8D%E7%A7%B0&#34;&gt;5.2.1.2 sizeof(变量名称或数组名称)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5213-sizeof%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F&#34;&gt;5.2.1.3 sizeof(字符串常量)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#53-strlen%E5%87%BD%E6%95%B0&#34;&gt;5.3 strlen()函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#54-%E6%80%BB%E7%BB%93&#34;&gt;5.4 总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AD%E8%AF%B4%E6%98%8E&#34;&gt;六、说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三步走战略的打法，五大能力培养体系的构建。&lt;/p&gt;
&lt;p&gt;数组、指针、函数，并列 C 语言三大重点，尤其 C 指针，堪称 C 之灵魂，从 C 数组开始，勤思苦练，必须多敲、搞清楚底层原理，系统设计，从宏观、哲学上理解 C 之精髓。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;强烈建议：b 站郝斌 C 视频结合着看。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;一-理解数组&#34;&gt;一、理解数组&lt;/h2&gt;
&lt;h3 id=&#34;11-为什么要有数组&#34;&gt;1.1 为什么要有数组？&lt;/h3&gt;
&lt;p&gt;数组：多个内存变量元素，共同使用一个变量名称，并用下标加以区分。&lt;/p&gt;
&lt;p&gt;数组与变量一样，必需先定义，再使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[10]; //定义了一个名称为 a 的，拥有 10 个 int 类型元素的数组；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;定义数组时，[] 里的内容不能是浮点数据，也不能是变量或者含有变量的表达式。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[1+2*2], b[&#39;a&#39;]; //这种定义是正确的；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-数组定义&#34;&gt;1.2 数组定义&lt;/h3&gt;
&lt;p&gt;int ar[10];&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这只能表示存在一个拥有 10 个 int 类型的元素的数组 ar，在这条定义语句之外的其他地方，ar 不表示数组的任何一个元素，也不表示数组的所有元素，它仅仅是数组名称而已。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;13-数组元素的使用&#34;&gt;1.3 数组元素的使用&lt;/h3&gt;
&lt;p&gt;数组元素的定义、与使用，是完全不一样的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;设有如下数组：int a[10];

a 数组的 10 个元素分别是：a[0]，a[1],  a[2]......a[9]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组元素下标范围取值范围在[0, n)之间，其中 n 为数组元素个数，这个数组将在内存中占用 40B 的连续存储空间。&lt;/p&gt;
&lt;h2 id=&#34;二-内存分布&#34;&gt;二、内存分布&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数组在内存中的存储方式&lt;/strong&gt;&lt;/p&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_jpg/iaumSdLKJXtQ8QIPf25Hcygz3eCYWcjuyASEUSQh4JdDYZPKtm92AaxBQLQLNXrWZPWGcuxXLhut1dpPV2tG6qw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39;&gt;&lt;/div&gt;
&lt;p align=center&gt;(一维数组存储方式)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int array[5];

array 数组应该有 5 个元素：array[0]、array[1]、array[2]、array[3]、array[4];

此时，我们的考虑，array[0]、array[4] 的前面 array[-1]、后面 array[5] 是否还有内存空间，还能访问到吗？
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;逻辑上不存在，物理上存在！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数组的定义仅仅约束的是人的思想，根本无法约束计算机的行为，关于数组下标越界，只是一个传说！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;C 语言编译软件是不能发现“下标越界”的错误的！这意味着：“下标越界”这种错误完全需要靠程序员非常高的编程素养来避免！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;三-常见操作&#34;&gt;三、常见操作&lt;/h2&gt;
&lt;h3 id=&#34;31-数组元素的遍历&#34;&gt;3.1 数组元素的遍历&lt;/h3&gt;
&lt;p&gt;对于数组中的元素，进行不重复、无遗漏的一次性访问。&lt;/p&gt;
&lt;p&gt;下面几种错误的输出方式：&lt;/p&gt;
&lt;p&gt;int a[10]; 元素有：a[0]......a[9]，打算输出 a 数组中的所有值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&amp;quot;%d\n&amp;quot;, int a[10]);  //错误
printf(&amp;quot;%d\n&amp;quot;, a[10]);  //这条语句被 C 语言认为，输出的是数组 a 的，下标为 10 的，第 11 个元素的值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于已经定义了一个拥有 n 个元素的数组 ar；对于这个数组所有元素进行遍历的程序框架是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for(i = 0; i &amp;lt; n; i++)
{
    ...ar[i]...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;总是从下标为 0 的元素开始遍历；&lt;/li&gt;
&lt;li&gt;下标总是连续变化，这意味着，对数据的遍历是连续的，不跳跃，不重复；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据存储在数组中需要满足的 3 个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从下标为 0 的第一个元素（首元素）开始存放；&lt;/li&gt;
&lt;li&gt;连续存放；&lt;/li&gt;
&lt;li&gt;上述两个特点必须保持动态满足（意思是：无论删除还是插入数据，在删除或插入数据后，依然要满足上述两个基本条件）；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对于数组的编程，主要考虑的是下标，或者可以说：玩数组就是玩下标。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;32-数组赋初值&#34;&gt;3.2 数组赋初值&lt;/h3&gt;
&lt;p&gt;数组赋初值操作仅能发生在数组定义语句未结束时。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[5] = {1, 2, 3, 4, 5};
int a[5] = {1, 2, 3, 4, 5, 6}; //语法错误
int a[5] = {1, 2, 3}; //不完全赋初值：初值个数少于所申请的数组元素个数，则从下标为 0 的元素开始，前面连续若干个元素被赋初值，其余元素的值被 C 语言统一赋值为 0(不是垃圾数据)
int a[100] = {1};
int a[5] = {}; //语法错误
int a[]; //语法错误，不能形成有效的数据类型（长度不定）
int a[] = {1, 2, 3, 4, 5, 6, 7}; //定义数组，不明确声明数组元素个数，但赋初值；则，数组元素个数取决于初值个数
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四-二维数组&#34;&gt;四、二维数组&lt;/h2&gt;
&lt;h3 id=&#34;41-本质&#34;&gt;4.1 本质&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[3][4]; //3行4列；
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;计算机内存根本就没有二维及多维数组，因为内存是一维，线性管理的。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;42-内存映像图&#34;&gt;4.2 内存映像图&lt;/h3&gt;
&lt;div align=center&gt;&lt;img src=&#39;https://mmbiz.qpic.cn/mmbiz_jpg/iaumSdLKJXtQ8QIPf25Hcygz3eCYWcjuyVuwWHcQYXYc4OEt3YCk4uiaBYN2vhtLibiaVQ3UaskYYX52YeIo2ib1x2Q/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&#39;&gt;&lt;/div&gt;
&lt;p align=center&gt;(二维数组存储方式)&lt;/p&gt;
&lt;h3 id=&#34;43-二维数组赋初值&#34;&gt;4.3 二维数组赋初值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
};  //二维数组是集合的集合；

int a[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}; //二维数组的本质还是一维的了；
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int a[3][4] = {{1}, {2}, {3}, {4}}; //语法错误，初始化数据个数过多；
int a[3][4] = {{}, {1}}; //语法错误；

int a[][4] = {...};
int a[][4][5] = {...};  //这种缺省的数组初始化是正确的；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;44-二维数组的遍历&#34;&gt;4.4 二维数组的遍历&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for(i = 0; i &amp;lt; row; i++){
    for(j = 0; j &amp;lt; col; j++){
            ...a[i][j]...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;五-字符数组与字符串&#34;&gt;五、字符数组与字符串&lt;/h2&gt;
&lt;h3 id=&#34;51-字符串&#34;&gt;5.1 字符串&lt;/h3&gt;
&lt;p&gt;以 0 结束的字符数组,&lt;strong&gt;这里的 0，就是数字 0，不是字符零 &#39;0&#39;，其ASCII 码值为 48。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;&amp;quot;abcdef&amp;quot;
012345
printf(&amp;quot;%c\n&amp;quot;, &amp;quot;abcdef&amp;quot;[3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char s[5] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;}; //字符数组
char s[5] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;0&#39;}; //字符数组
char s[5] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, 0}; //字符串
char s[5] = &amp;quot;ABCD&amp;quot;; //字符串
char s[5] = {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;}; //字符串
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;字符串常量（&amp;quot;&amp;quot;，所括起来的内容）的最后，一定存在着一个看不见的 0 结束标志！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char s[6] = &amp;quot;abcdef&amp;quot;;  //语法错误，最后有一个 0 结束标志；
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;52-运算符sizeof&#34;&gt;5.2 运算符：sizeof()&lt;/h3&gt;
&lt;p&gt;它是一个运算符，而非函数！！！，是一个单目运算符，其运算优先级在单目运算符中最低。&lt;/p&gt;
&lt;h4 id=&#34;521-sizeof的用法&#34;&gt;5.2.1 sizeof()的用法&lt;/h4&gt;
&lt;h5 id=&#34;5211-sizeof数据类型名称&#34;&gt;5.2.1.1 sizeof(数据类型名称)&lt;/h5&gt;
&lt;p&gt;sizeof(int)、sizeof(float)、sizeof(char)，其计算结果：&lt;strong&gt;相关数据类型所占用的内存空间的字节数。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;5212-sizeof变量名称或数组名称&#34;&gt;5.2.1.2 sizeof(变量名称或数组名称)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char a;
double b;
short c[100];

sizeof(a) ==&amp;gt; 1B
sizeof(b) ==&amp;gt; 8B
sizeof(c) ==&amp;gt; 200B
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;5213-sizeof字符串常量&#34;&gt;5.2.1.3 sizeof(字符串常量)&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;sizeof(&amp;quot;abcde&amp;quot;) ==&amp;gt; 6B;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其运算结果：&lt;strong&gt;该字符串常量在内存中所占用的字节数（该数值是字符串长度+1，这个 1B 就是 0 结束标志！）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;53-strlen函数&#34;&gt;5.3 strlen()函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;是用来计算字符串长度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若要调用 strlen() 函数，则必须在程序的最开始加上：#include&amp;lt;string.h&amp;gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&amp;quot;%d\n&amp;quot;, strlen(&amp;quot;abcdefg&amp;quot;));  //结果为7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于字符串的处理：&lt;strong&gt;遇 0 则止（调用字符串函数）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;54-总结&#34;&gt;5.4 总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;sizeof() 是计算所占用的空间字节大小；&lt;/li&gt;
&lt;li&gt;strlen() 是计算字符串数组的长度，遇 0 则止；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章仅仅是数组入门，对于数组的本质掌握是非常的关键，尤其在跟指针的结合，理解，打好基础，进阶提升。&lt;/p&gt;
">（C语言）指针</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/linux-chang-yong-ming-ling/"" data-c="
          &lt;!-- GFM-TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86&#34;&gt;一.文件管理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BEfind&#34;&gt;1.文件查找：find&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9Dcp&#34;&gt;2.文件拷贝：cp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E6%89%93%E5%8C%85%E8%A7%A3%E5%8C%85tar&#34;&gt;3.打包解包：tar&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86&#34;&gt;二.文本处理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6nl&#34;&gt;1.(显示行号)查看文件：nl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E6%96%87%E6%9C%AC%E6%9F%A5%E6%89%BEgrep&#34;&gt;2.文本查找：grep&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E6%8E%92%E5%BA%8Fsort&#34;&gt;3.排序：sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%E8%BD%AC%E6%8D%A2tr&#34;&gt;4.转换：tr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5%E5%88%87%E5%88%86%E6%96%87%E6%9C%ACcut&#34;&gt;5.切分文本：cut&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6%E6%8B%BC%E6%8E%A5%E6%96%87%E6%9C%ACpaste&#34;&gt;6.拼接文本：paste&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7%E7%BB%9F%E8%AE%A1wc&#34;&gt;7.统计：wc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86sed&#34;&gt;8.数据处理：sed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86awk&#34;&gt;9.数据处理：awk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90&#34;&gt;三.性能分析&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E8%BF%9B%E7%A8%8B%E6%9F%A5%E8%AF%A2ps&#34;&gt;1.进程查询：ps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E8%BF%9B%E7%A8%8B%E7%9B%91%E6%8E%A7top&#34;&gt;2.进程监控：top&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%9F%A5%E8%AF%A2lsof&#34;&gt;3.打开文件查询：lsof&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%87%8Ffree&#34;&gt;4.内存使用量：free&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5shell%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6ulimit&#34;&gt;5.shell进程的资源限制：ulimit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7&#34;&gt;四.网络工具&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E7%BD%91%E5%8D%A1%E9%85%8D%E7%BD%AEifconfig&#34;&gt;1.网卡配置：ifconfig&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5netstat&#34;&gt;2.查看当前网络连接：netstat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E6%9F%A5%E7%9C%8B%E8%B7%AF%E7%94%B1%E8%A1%A8route&#34;&gt;3.查看路由表：route&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%E6%A3%80%E6%9F%A5%E7%BD%91%E7%BB%9C%E8%BF%9E%E9%80%9A%E6%80%A7ping&#34;&gt;4.检查网络连通性：ping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5%E8%BD%AC%E5%8F%91%E8%B7%AF%E5%BE%84traceroute&#34;&gt;5.转发路径：traceroute&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6%E7%BD%91%E7%BB%9Cdebug%E5%88%86%E6%9E%90nc&#34;&gt;6.网络Debug分析：nc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8A%93%E5%8C%85tcpdump&#34;&gt;7.命令行抓包：tcpdump&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7dig&#34;&gt;8.域名解析工具：dig&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82curl&#34;&gt;9.网络请求：curl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%94%E5%BC%80%E5%8F%91%E5%8F%8A%E8%B0%83%E8%AF%95&#34;&gt;五.开发及调试&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E7%BC%96%E8%BE%91%E5%99%A8vim&#34;&gt;1.编辑器：vim&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E7%BC%96%E8%AF%91%E5%99%A8gcc%E5%92%8Cg++&#34;&gt;2.编译器：gcc和g++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7gdb&#34;&gt;3.调试工具：gdb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%E6%9F%A5%E7%9C%8B%E4%BE%9D%E8%B5%96%E5%BA%93ldd&#34;&gt;4.查看依赖库：ldd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90objdump&#34;&gt;5.二进制文件分析：objdump&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90readelf&#34;&gt;6.ELF文件格式分析：readelf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7%E8%B7%9F%E8%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8strace&#34;&gt;7.跟踪进程中系统调用：strace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8%E8%B7%9F%E8%B8%AA%E8%BF%9B%E7%A8%8B%E6%A0%88pstack&#34;&gt;8.跟踪进程栈：pstack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84pmap&#34;&gt;9.进程内存映射：pmap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AD%E5%85%B6%E4%BB%96&#34;&gt;六.其他&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8Bkill&#34;&gt;1.终止进程：kill&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90chmod&#34;&gt;2.修改文件权限：chmod&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E5%88%9B%E5%BB%BA%E9%93%BE%E6%8E%A5ln&#34;&gt;3.创建链接：ln&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E5%B0%BEtail&#34;&gt;4.显示文件尾：tail&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git&#34;&gt;5.版本控制：git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6%E8%AE%BE%E7%BD%AE%E5%88%AB%E5%90%8Dalias&#34;&gt;6.设置别名：alias&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- GFM-TOC --&gt;
&lt;br&gt;
&lt;h1 id=&#34;一文件管理&#34;&gt;一.文件管理&lt;/h1&gt;
&lt;h2 id=&#34;1文件查找find&#34;&gt;1.文件查找：find&lt;/h2&gt;
&lt;h4 id=&#34;使用方法&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;find [查找目录] [查找条件]

查找目录：
    .：在当前目录及子目录下查找（默认）
    A：在目录A及A的子目录下查找
查找条件：
    -name：根据文件名查找
    -regex：使用正则表达式匹配
    -type：按类型查找（f:文件，d:目录，l:链接...）
    -atime：按访问时间查找（n:n天前的一天内，+n:n天前(不含n天本身)，-n:n天内(不含n天)）
    -mtime：按修改时间查找（n:n天前的一天内，+n:n天前(不含n天本身)，-n:n天内(不含n天)）
    -size：按大小查找（单位k，+nk:&amp;quot;比nk更大&amp;quot;，-nk:&amp;quot;比nk更小&amp;quot;）
    -perm：按权限查找（644：权限等于644的文件）
    -user/-nouser：用户名等于/用户名不等于
    -group/-nogroup：组名等于/组名不等于
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#1.在当前目录及子目录下查找后缀为cpp的文件
find . -name *.cpp

#2.使用正则表达式查找
find -regex &amp;quot;.*.cpp$&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2文件拷贝cp&#34;&gt;2.文件拷贝：cp&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-2&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp [选项] 源路径 目的路径

选项：
    -a：将所有属性一起复制（包括拥有者、时间等信息）
    -i：目标文件存在时，进行询问
    -r：递归复制
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3打包解包tar&#34;&gt;3.打包解包：tar&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-3&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;tar [-j|-z] [cv] [-f 压缩包名] 目录
tar [-j|-z] [xv] [-f 解压包名] [-C 解压路径]

选项：
    -c/-x：打包/解包
    -j/-z：bzip2格式/gzip格式
    -v：显示过程
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二文本处理&#34;&gt;二.文本处理&lt;/h1&gt;
&lt;h2 id=&#34;1显示行号查看文件nl&#34;&gt;1.(显示行号)查看文件：nl&lt;/h2&gt;
&lt;p&gt;行号计算不包括空行&lt;/p&gt;
&lt;h2 id=&#34;2文本查找grep&#34;&gt;2.文本查找：grep&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-4&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;grep [选项] 模式串 文件
输出 | grep [选项] 模式串

选项
    -e：使用多个模式串
    -i：忽略大小写
    -n：打印行号
    -c：统计次数（一行算一次）
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例-2&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#1.在test.c中搜索包含字符串”printf“或”count“的行
grep -e &amp;quot;printf&amp;quot; -e &amp;quot;count&amp;quot; test.c
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3排序sort&#34;&gt;3.排序：sort&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-5&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sort [选项] 文件
输出 | sort [选项]

选项
    -d：按字典序排序（默认）
    -n：按数字排序
    -k：&amp;quot;-k n&amp;quot;表示按各行第n列进行排序
    -r：反序
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4转换tr&#34;&gt;4.转换：tr&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-6&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#set1、set2为字符集，可以是单个字符，也可以是字符串
输出 | tr [选项] set1 set2

选项：
    -d：删除字符
    -s：字符压缩
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例-3&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#1.删除字符&#39;:&#39;
cat /etc/passwd | tr -d &#39;:&#39;

#2.将小写字母替换成大写字母
last | tr &#39;[a-z]&#39; &#39;A-Z&#39;

#3.将&#39;a&#39;、&#39;b&#39;、&#39;c&#39;替换成&#39;z&#39;
cat test | tr “abc” &#39;z&#39;

#4.将连续的&#39;a&#39;压缩成&#39;b&#39;（单个或连续出现的多个‘a’会压缩成一个‘b’）
cat test | tr -s &#39;a&#39; &#39;b&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5切分文本cut&#34;&gt;5.切分文本：cut&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-7&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cut [选项] 文件
输出 | cut [选项]

选项：
    -d：分隔符（-d &#39;:&#39; 以’:‘为分隔符）
    -f：选择域（-f 1,2 输出分隔后第1列和第2列）
    -c：字符范围（-c n-m 输出第n到m个字符。如果没有m，输出到末尾）
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例-4&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#1.按’:‘分隔$PATH，输出第3个和第5个
echo $PATH | cut -d &#39;:&#39; -f 3,5

#2.输出export运行结果每行的第12-20个字符
export | cut -c 12-20
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6拼接文本paste&#34;&gt;6.拼接文本：paste&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-8&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;paste [选项] file1 file2

选项：
    -d：指定拼接时使用的分隔符（默认使用tab作为分隔符）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7统计wc&#34;&gt;7.统计：wc&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-9&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wc [选项] 文件
输出 | wc [选项]

选项：
    -c：统计字符数
    -w：统计单词数
    -l：统计行数
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8数据处理sed&#34;&gt;8.数据处理：sed&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;sed常用于一整行的处理。如果有一个100万行的文件，要在第100行加某些文字，此时由于文件太大，不适合用vim处理。因此使用sed是个很好的选择&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;使用方法-10&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sed [选项] &#39;[动作]&#39; 文件
输入 | sed [选项] &#39;[动作]&#39;

选项：
    -n：安静模式，只输出sed处理过的行（否则未处理行也会输出）
    -i：结果直接作用到文件（没指定时不会修改文件）
    -e：在命令行模式上输入动作
    -f：从文件中读取动作

动作：[n1[,n2]] function
function:
    a/i：在后插入/在前插入
    d：删除
    p：打印
    s：替换
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例-5&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#1.插入
nl /etc/passwd | sed &#39;2a drink tea&#39; #在第2行后插入一行：&amp;quot;drink tea&amp;quot;
nl /etc/passwd | sed &#39;2a aaa \
&amp;gt; bbb&#39; #在第2行后插入两行：&amp;quot;aaa&amp;quot;和&amp;quot;bbb&amp;quot;

#2.删除
nl /etc/passwd | sed &#39;2,5d&#39; #删除2~5行
sed &#39;/^$/d&#39; ip #将ip文件中的空行删除

#3.打印2~5行（安静模式，不使用安静模式2~5行会打印2次）
nl /etc/passwd | sed -n &#39;2,5p&#39;

#4.替换
nl /etc/passwd | sed &#39;2s/daemon/root/g&#39; #将第二行的daemon替换成root
ifconfig | grep &#39;inet addr&#39; | sed &#39;s/^.*addr://g&#39; #将所有开头的“inet addr:”删除
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9数据处理awk&#34;&gt;9.数据处理：awk&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;相比于sed常用于一整行的处理，awk则比较倾向于将一行分成数个“字段”来处理。因此，相当适合小型的数据处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;awk处理步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读入第一行，并将第一行的数据填入$0,$1,$2等变量当中&lt;/li&gt;
&lt;li&gt;依据条件类型的限制，判断是否需要进行后面的动作&lt;/li&gt;
&lt;li&gt;做完所有的动作与条件类型&lt;/li&gt;
&lt;li&gt;若还有后续的“行”的数据，则重复1~3步，直到所有的数据都读完为止&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;使用方法-11&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;awk &#39;条件类型1{动作1} 条件类型2{动作2} ...&#39; filename
输出 | awk &#39;条件类型1{动作1} 条件类型2{动作2} ...&#39;

变量：
    $0：整行
    $1：按分隔符分隔后的第1列
    $2：按分隔符分隔后的第2列
    $k：按分隔符分隔后的第k列
    NF：每一行拥有的字段数
    NR：目前所处理的行数
    FS：目前的分隔字符（默认是空格或tab）
条件判断：&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=、==、!=
命令分隔：使用&#39;;&#39;或Enter
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例-6&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#1.打印last -n 5结果中每行经过分隔符(默认情况下为空格或tab)分隔后的第1列和第3列
last -n 5 | awk &#39;{print $1 &amp;quot;\t&amp;quot; $3}&#39;

#2.以&#39;:&#39;作为分隔符，打印第3列小于10的所有行的第1列和第3列
cat /etc/passwd | awk &#39;{FS=&amp;quot;:&amp;quot;} $3&amp;lt;10{print $1 &amp;quot;\t&amp;quot; $3}&#39;      #（第一行不会处理）
cat /etc/passwd | awk &#39;BEGIN{FS=&amp;quot;:&amp;quot;} $3&amp;lt;10{print $1 &amp;quot;\t&amp;quot; $3}&#39; #（第一行会处理）

#3.假设test文件由3列数字组成，以空格分隔。该命令会计算每行的和然后打印
awk &#39;{total=$1+$2+$3;printf &amp;quot;%10d %10d %10d %10.2f\n&amp;quot;,$1,$2,$3,total}&#39; test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意上面的示例2，awk首先是读取一行，分隔后的数据填入$0,$1,$2等变量中才开始进行条件判断和执行动作。因此第一条命令在按空格或tab分隔后才将分隔符换成&#39;:&#39;，所以第一行显示结果不对&lt;/p&gt;
&lt;h1 id=&#34;三性能分析&#34;&gt;三.性能分析&lt;/h1&gt;
&lt;h2 id=&#34;1进程查询ps&#34;&gt;1.进程查询：ps&lt;/h2&gt;
&lt;p&gt;man ps手册非常庞大，不是很好查阅，因此主要记住几个命令&lt;/p&gt;
&lt;h4 id=&#34;示例-7&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#1.列出仅与自身环境有关的进程，最上层的父进程是允许该ps命令的bash而没有扩展到init进程中去
ps -l

#2.列出系统所有进程的信息
ps aux
ps -ef    #aux会截断COMMAND列，-ef不会。aux是BSD风格，-ef是System V风格
ps axjf   #以&amp;quot;进程树&amp;quot;的方式显示所有进程
ps -lA    #输出格式同ps -l
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;../pic/linux-ps-1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;F&lt;/strong&gt;：进程标志，说明进程的权限
&lt;ul&gt;
&lt;li&gt;4：root权限&lt;/li&gt;
&lt;li&gt;1：仅能fork而不能exec&lt;/li&gt;
&lt;li&gt;0：既非4也非1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;S&lt;/strong&gt;：进程的状态
&lt;ul&gt;
&lt;li&gt;R(running)：正在运行&lt;/li&gt;
&lt;li&gt;S(Sleep)：可被唤醒的睡眠&lt;/li&gt;
&lt;li&gt;D：不可被唤醒的睡眠（通常可能在等待I/O）&lt;/li&gt;
&lt;li&gt;T：停止，可能是在后台暂停&lt;/li&gt;
&lt;li&gt;Z(Zombie)：僵尸进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;：CPU使用率&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PRI/NI&lt;/strong&gt;：Priority/Nice的缩写，CPU优先级(越小越高)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ADDR/SZ/WCHAN&lt;/strong&gt;：内存相关，ADDR指出进程在内存的哪个部分，running进程一般显示&#39;-&#39;。SZ为进程使用的内存。WCHAN表示进程当前是否运行中&#39;-&#39;，当进程睡眠时，指出进程等待的事件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TTY&lt;/strong&gt;：进程运行的终端机&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TIME&lt;/strong&gt;：进程用掉的CPU时间&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;../pic/linux-ps-2.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;USER&lt;/strong&gt;：进程所属用户&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;%CPU/%MEM&lt;/strong&gt;：进程消耗的CPU百分比和内存百分比&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VSZ&lt;/strong&gt;：进程用掉的虚拟内存(KB)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RSS&lt;/strong&gt;：进程占用的固定内存(KB)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TTY&lt;/strong&gt;：进程运行的终端机，与终端机无关则显示&#39;?&#39;。tty1~tty6是本机的登陆者程序，pts/0等表示由网络连接进主机的进程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;STAT&lt;/strong&gt;：进程目前的状态，与&lt;code&gt;ps -l&lt;/code&gt;结果中的&lt;strong&gt;S&lt;/strong&gt;等同&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;START&lt;/strong&gt;：进程启动的时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TIME&lt;/strong&gt;：进程实际使用的CPU运行时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2进程监控top&#34;&gt;2.进程监控：top&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-12&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;top [选项]

选项：
    -d：跟秒数指定更新间隔
    -n：与-b搭配，指定需要进行几次top输出，重定向时常用
    -p：指定PID，监控特定进程
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;top模式下的命令&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;?&lt;/strong&gt;：显示可用的命令&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P&lt;/strong&gt;：以CPU使用情况排序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;M&lt;/strong&gt;：以内存使用情况排序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;N&lt;/strong&gt;：以PID排序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;q&lt;/strong&gt;：退出&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1&lt;/strong&gt;：多核情况下切换CPU&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;%Cpu(s)后面的“wa”表示I/O wait，过高说明长时间等待I/O，I/O存在瓶颈&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3打开文件查询lsof&#34;&gt;3.打开文件查询：lsof&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-13&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;lsof [选项]

选项：
    -i：-i:端口号查看端口被占用的情况
    -u：后跟用户名查看具体用户打开的文件
    -p：后跟PID查看指定进程打开的文件
    +d：后跟目录查看指定目录下被进程打开的文件，&amp;quot;+D&amp;quot;递归
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4内存使用量free&#34;&gt;4.内存使用量：free&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-14&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;free [选项]

选项：
    -b|-k|-m|-g：单位
    -t：列出物理内存与swap的汇总情况    
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;../pic/linux-free-1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;buffers&lt;/strong&gt;：主要缓存dentry和inode等元数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cached&lt;/strong&gt;：主要缓存文件内容，即page cache&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;- buffers/cache&lt;/strong&gt;：实际使用的内存。used-buffers-cached&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;+ buffers/cache&lt;/strong&gt;：可用内存。free+buffers+cached（在内存紧张时，buffers和cached可以回收）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://fixatom.com/linux-free-cmd-buffers-and-cached/&#34;&gt;详细结果说明&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;5shell进程的资源限制ulimit&#34;&gt;5.shell进程的资源限制：ulimit&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-15&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ulimit [选项]       #查看
ulimit [选项] 新值  #修改

选项：
    -a：列出shell进程的所有资源限制情况（-a命令会列出查看某一资源限制的选项参数）
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;ulimit&lt;/code&gt;修改资源限制只会对当前终端环境有效，如果想永久生效，可以修改文件&lt;code&gt;/etc/security/limits.conf&lt;/code&gt;，该文件的内容如下；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# /etc/security/limits.conf
#
#Each line describes a limit for a user in the form:
#
#&amp;lt;domain&amp;gt;        &amp;lt;type&amp;gt;  &amp;lt;item&amp;gt;  &amp;lt;value&amp;gt;
#
#Where:
#&amp;lt;domain&amp;gt; can be:
#        - a user name
#        - a group name, with @group syntax
#        - the wildcard *, for default entry
#        - the wildcard %, can be also used with %group syntax,
#                 for maxlogin limit
#        - NOTE: group and wildcard limits are not applied to root.
#          To apply a limit to the root user, &amp;lt;domain&amp;gt; must be
#          the literal username root.
#
#&amp;lt;type&amp;gt; can have the two values:
#        - &amp;quot;soft&amp;quot; for enforcing the soft limits
#        - &amp;quot;hard&amp;quot; for enforcing hard limits
#
#&amp;lt;item&amp;gt; can be one of the following:
#        - core - limits the core file size (KB)
#        - data - max data size (KB)
#        - fsize - maximum filesize (KB)
#        - memlock - max locked-in-memory address space (KB)
#        - nofile - max number of open files
#        - rss - max resident set size (KB)
#        - stack - max stack size (KB)
#        - cpu - max CPU time (MIN)
#        - nproc - max number of processes
#        - as - address space limit (KB)
#        - maxlogins - max number of logins for this user
#        - maxsyslogins - max number of logins on the system
#        - priority - the priority to run user process with
#        - locks - max number of file locks the user can hold
#        - sigpending - max number of pending signals
#        - msgqueue - max memory used by POSIX message queues (bytes)
#        - nice - max nice priority allowed to raise to values: [-20, 19]
#        - rtprio - max realtime priority
#        - chroot - change root to directory (Debian-specific)
#
#&amp;lt;domain&amp;gt;      &amp;lt;type&amp;gt;  &amp;lt;item&amp;gt;         &amp;lt;value&amp;gt;
#

#*               soft    core            0
#root            hard    core            100000
#*               hard    rss             10000
#@student        hard    nproc           20
#@faculty        soft    nproc           20
#@faculty        hard    nproc           50
#ftp             hard    nproc           0
#ftp             -       chroot          /ftp
#@student        -       maxlogins       4

# End of file
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例-8&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@068ca8da6d06:/# ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7863
max locked memory       (kbytes, -l) 82000
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1048576
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) unlimited
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;四网络工具&#34;&gt;四.网络工具&lt;/h1&gt;
&lt;h2 id=&#34;1网卡配置ifconfig&#34;&gt;1.网卡配置：ifconfig&lt;/h2&gt;
&lt;h2 id=&#34;2查看当前网络连接netstat&#34;&gt;2.查看当前网络连接：netstat&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;netstat [选项]

选项：
    -a：将所有的连接、监听、Socket数据都列出来（如，默认情况下，不会列出监听状态的连接）
    -t：列出tcp连接
    -u：列出udp连接
    -n：将连接的进程服务名称以端口号显示（如下图中Local Address会换成10.0.2.15:22）
    -l：列出处于监听状态的连接
    -p：添加一列，显示网络服务进程的PID（需要root权限）
    -i：显示网络接口列表，可以配合ifconfig一起分析
    -s：打印网络统计数据，包括某个协议下的收发包数量
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;../pic/linux-netstat-1.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Active Internet connections（w/o servers）：网络相关的连接&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Recv-Q&lt;/strong&gt;：接收队列(已接收还未递交给应用)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Send-Q&lt;/strong&gt;：发送队列(接收方未确认的数据)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Local Address&lt;/strong&gt;：本地IP(主机):端口(服务名)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Foreign Address&lt;/strong&gt;：远端IP:端口&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;Recv-Q和Send-Q通常应该为0，如果长时间不为0可能存在问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Active UNIX domain sockets（w/o servers）：本地相关的套接字&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RefCnt&lt;/strong&gt;：连接到此socket的进程数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flags&lt;/strong&gt;：连接标识&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Type&lt;/strong&gt;：socket访问的类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Path&lt;/strong&gt;：连接到此socket的相关程序的路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://linux.cn/article-2434-1.html&#34;&gt;netstat的10个基本用法&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;3查看路由表route&#34;&gt;3.查看路由表：route&lt;/h2&gt;
&lt;h2 id=&#34;4检查网络连通性ping&#34;&gt;4.检查网络连通性：ping&lt;/h2&gt;
&lt;h2 id=&#34;5转发路径traceroute&#34;&gt;5.转发路径：traceroute&lt;/h2&gt;
&lt;h2 id=&#34;6网络debug分析nc&#34;&gt;6.网络Debug分析：nc&lt;/h2&gt;
&lt;h2 id=&#34;7命令行抓包tcpdump&#34;&gt;7.命令行抓包：tcpdump&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-16&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo tcpdump [选项] ...

选项：
    -D/-i：查看/指定网卡
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;示例-9&#34;&gt;示例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#抓取本地9877号端口的TCP数据包
sudo tcpdump -i lo tcp port 9877
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下图为tcp回射服务器，客户端分别键入&amp;quot;hello&amp;quot;和“world”时，使用tcpdump抓取到的数据包&lt;/p&gt;
&lt;div align=&#34;center&#34;&gt; &lt;img src=&#34;../pic/linux-tcpdump-1.png&#34;/&gt; &lt;/div&gt;
&lt;h2 id=&#34;8域名解析工具dig&#34;&gt;8.域名解析工具：dig&lt;/h2&gt;
&lt;h2 id=&#34;9网络请求curl&#34;&gt;9.网络请求：curl&lt;/h2&gt;
&lt;h1 id=&#34;五开发及调试&#34;&gt;五.开发及调试&lt;/h1&gt;
&lt;h2 id=&#34;1编辑器vim&#34;&gt;1.编辑器：vim&lt;/h2&gt;
&lt;h2 id=&#34;2编译器gcc和g&#34;&gt;2.编译器：gcc和g++&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/CarpenterLee/p/5994681.html&#34;&gt;C程序的编译过程&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;使用方法-17&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gcc/g++ [选项] 源文件

选项：
    -E：让编译器在预处理之后停止，不进行后续编译过程，得到.i文件
    -S：让编译器在编译之后停止 ，不进行后续过程，得到.s文件
    -c：生成机器码即二进制.o文件
    -o：指定目标文件名
    -g：在编译的时候生成调试信息
    -Wall：生成所有警告信息
    -I 目录：指定头文件的查找目录
    生成动态链接库：
        1. gcc/g++ -c -fPIC 源文件 -o 目标文件名
        2. gcc -shared 目标文件名 -o 动态链接库名.so
    生成静态链接库：
        1. gcc/g++ -c 源文件 -o 目标文件名
        2. ar -crv 静态链接库名.a 目标文件名
    -l库名 -L 目录：引入链接库，-L指定查找该库的目录。如-lm表示引入libm.so
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3调试工具gdb&#34;&gt;3.调试工具：gdb&lt;/h2&gt;
&lt;h4 id=&#34;使用方法-18&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#第一步：得到可执行文件
gcc/g++ -o 可执行文件 -g 源文件

#第二步：启动gdb
gdb #启动gdb

#第三步：执行gdb命令进行调试
(gdb) gdb命令

gdb命令：
    file 可执行文件：导入需要调试的文件
    r：运行程序
    q：退出gdb
    b：设置断点
        b 行号
        b 函数名称
        b *函数名
        b *代码地址
        b 编号
    c：继续执行，直到下一断点或程序结束
    s：执行一行代码，如果此行代码有函数调用则进入函数
    n：执行一行代码，如果此行代码有函数调用，不进入函数，直接执行函数
    i(info) 子命令：查看某些信息（只输入info或i可以查看有哪些子命令）
        info thread：查看进程的所有线程，会显示每个线程的序号（1~n）
    thread 线程序号：切换到相应的线程（线程序号可以由info thread得到）
    f(frame) 函数栈帧号：切换到相应的函数栈帧（函数栈帧号可以由where等命令得到）
    list：查看源码
        list 行号：查看指定行号附近的源码
        list 函数：查看指定函数附近的源码
        list 文件:行号：查看指定文件中指定行附近的代码
    where：查看当前位置
    p(print) /格式 表达式
        格式：
            x：按十六进制格式显示变量
            d：按十进制格式显示变量
            u：按十六进制格式显示无符号整形
            o：按八进制格式显示变量
            t：按二进制格式显示变量
            a：按十六进制格式显示变量
            c：按字符格式显示变量
            f：按浮点数格式显示变量
        表达式中可用的操作符：
            @：一个和数组有关的操作符，左边是起始地址，右边是长度（p *arr@3）
            ::：指定一个在文件或是函数中的变量（p &#39;f2.c&#39;::x）
            {&amp;lt;type&amp;gt;}&amp;lt;addr&amp;gt;：一个指向内存&amp;lt;addr&amp;gt;的类型为type的一个对象
    x(examine) &amp;lt;n/f/u&amp;gt; &amp;lt;addr&amp;gt;：查看内存
        n：正整数，表示需要显示的内存单元个数
        f：显示的格式（格式字母同上面的print）
        u：每个单元的字节数
            b：1字节
            h：2字节
            w：4字节（默认）
            g：8字节
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4查看依赖库ldd&#34;&gt;4.查看依赖库：ldd&lt;/h2&gt;
&lt;h2 id=&#34;5二进制文件分析objdump&#34;&gt;5.二进制文件分析：objdump&lt;/h2&gt;
&lt;h2 id=&#34;6elf文件格式分析readelf&#34;&gt;6.ELF文件格式分析：readelf&lt;/h2&gt;
&lt;h2 id=&#34;7跟踪进程中系统调用strace&#34;&gt;7.跟踪进程中系统调用：strace&lt;/h2&gt;
&lt;h2 id=&#34;8跟踪进程栈pstack&#34;&gt;8.跟踪进程栈：pstack&lt;/h2&gt;
&lt;h2 id=&#34;9进程内存映射pmap&#34;&gt;9.进程内存映射：pmap&lt;/h2&gt;
&lt;h1 id=&#34;六其他&#34;&gt;六.其他&lt;/h1&gt;
&lt;h2 id=&#34;1终止进程kill&#34;&gt;1.终止进程：kill&lt;/h2&gt;
&lt;h2 id=&#34;2修改文件权限chmod&#34;&gt;2.修改文件权限：chmod&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;w权限不具有删除文件的能力&lt;/li&gt;
&lt;li&gt;目录的x权限表示能否进入目录&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;使用方法-19&#34;&gt;使用方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;chmod [选项] [u|g|o|a][+|-][r|w|x] 文件或目录
chmod [选项] 权限的数字表示 文件或目录

选项：
    -R：递归式的修改
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3创建链接ln&#34;&gt;3.创建链接：ln&lt;/h2&gt;
&lt;h2 id=&#34;4显示文件尾tail&#34;&gt;4.显示文件尾：tail&lt;/h2&gt;
&lt;h2 id=&#34;5版本控制git&#34;&gt;5.版本控制：git&lt;/h2&gt;
&lt;h2 id=&#34;6设置别名alias&#34;&gt;6.设置别名：alias&lt;/h2&gt;
">Linux常用命令</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/zhi-mian-shi-bu-zhao-ren/"" data-c="
          &lt;h3 id=&#34;只面试不招人&#34;&gt;只面试不招人&lt;/h3&gt;
&lt;h4 id=&#34;1-面试地点诡异的&#34;&gt;1、面试地点诡异的&lt;/h4&gt;
&lt;p&gt;一般的正规公司，不是写字楼就是在商业场所，除去近几年新兴的创业园，工作室确实会在商住一体，或是居民楼内，大部分还是会有相对正规的，商业办公地址。写着面试地点比较偏僻，或者是某酒店的，建议查询下其工商注册信息，不符的，不建议贸然尝试。&lt;/p&gt;
&lt;p&gt;如果真的要去，可以在楼下和保安打个招呼，提前询问几零几是否是XX公司，自己约了去面试，如果半小时没有下来，请对方上门查看，甚至有紧急情况，代为报警。&lt;/p&gt;
&lt;h4 id=&#34;2-面试场所诡异的&#34;&gt;2、面试场所诡异的&lt;/h4&gt;
&lt;p&gt;面试地点没有异常，如约而至，坐在办公场所。那么一般会被安置在会议室或者接待区，在等待的时候请别闲着，可以环顾四周，看看是否有和异常，前台的状态，员工的状态，出现大量的空置，那么多半是有问题的，除了初创阶段，正常的公司不可能大量的空置。如果员工状态懒散，那么多半是公司制度不完善，效益不好，甚至是有不良的劳动用工，恶意欠薪的隐患。这种情况，也不建议继续面试下去。&lt;/p&gt;
&lt;h4 id=&#34;3-面试邀约诡异的&#34;&gt;3、面试邀约诡异的&lt;/h4&gt;
&lt;p&gt;非正常工作时段打电话邀约的，邀约的时候语气特别殷切的，需要特别注意。非上班时间还在电话邀约，那么至少说明在加班，经常加班。语气特别殷切，说明招人难，为什么招人难？大多是公司不咋地。&lt;/p&gt;
&lt;h4 id=&#34;4-要收取费用的&#34;&gt;4、要收取费用的&lt;/h4&gt;
&lt;p&gt;如果是在网上投递简历，通知你面试，然后在面试过程中交押金培训费等各种费用时，这些可能都是骗人的。如果到人才市场去找工作，也要找正规的人才市场，就比如：深圳兴达人才市场就是正规的，应聘者可以到兴达人才市场找工作。&lt;/p&gt;
&lt;h4 id=&#34;5-一次性招聘很多人&#34;&gt;5、一次性招聘很多人&lt;/h4&gt;
&lt;p&gt;如果一个公司招聘很多人，从高层到底层，除非这家公司是新建的公司，否则就是骗人的。求职者们在找工作时一定要注意不要被虚假的招聘信息给欺骗了，一定要到正规的网站投递简历，或者是到正规的人才市场找工作。&lt;/p&gt;
&lt;h3 id=&#34;保护个人-亲人-前雇主情报&#34;&gt;保护个人、亲人、前雇主情报&lt;/h3&gt;
&lt;h4 id=&#34;来源&#34;&gt;来源&lt;/h4&gt;
&lt;p&gt;作者：简秀才&lt;br&gt;
链接：https://www.zhihu.com/question/301031210/answer/1356127992&lt;br&gt;
来源：知乎&lt;br&gt;
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h4 id=&#34;1不是真的招人而是打广告或者应对考核&#34;&gt;1.不是真的招人，而是打广告或者应对考核&lt;/h4&gt;
&lt;p&gt;企业通过这个招聘的借口想表达一个消息，比如这个岗位缺人，让上级领导知道其他员工工作量饱满而不是混日子。比如领导在暗示一些人可以走动走动得到这个岗位。或者想通过这件事传达出某些信息，这个信息可能不是为了招聘，可能只有小范围内部的员工才知道实情，不是真的招人，就是打打广告等等。对很多公司的HR来说，在他们的KPI考核指标中都有很关键的一点就是人员稳定性和人员招聘指标的考核。于是一些HR为了完成招人的需求，他们就会定期的发一些招聘广告来收集一些简历，定期的邀请一些人来他们公司面试。但是对这些公司来说，他们一般都是只邀请人过来走个过场，做做样子，或者从求职者那边得到当前求职市场状况，以及竞争对手情况，还有行业水平等，其实他们公司在那段时间是根本没有招人需求的。这样做或许对公司来说是有一些好处，但是对求职者来说，这可苦了那些从大老远过来面试的人。这时候你可以试想一下，你从大老远过来面试，你不仅需要自掏交通费，路途遥远你过来还要吃一顿饭，最后这么一折腾或许一天就过去了，最终公司给你回复一句：您的情况我们已经了解了，下来有需要我们会通知你。你还在真切等待对方给你的回复，也发邮件催了，但是或许他们永远都不会通知你。对此，当知道真相的你会不会感到很崩溃？&lt;/p&gt;
&lt;h4 id=&#34;2收集同行业情报&#34;&gt;2.收集同行业情报&lt;/h4&gt;
&lt;p&gt;有时候公司想了解竞争对手情况或者同业情况，最好的办法就是放出相应的岗位，然后在面试候选人的时候提问，获取相应信息。由于公司考虑业务扩张或者转型涉及新领域，对涉足新领域的行情不太了解，邀候选人来其实就是通过面试了解更好业内信息，探底，实际未必招人。假招聘真收集情报。他们收到简历后只让竞争对手公司员工进入面试环节，面试时问题大多数敏感的，如你们公司销售额是多少?你的绩效考核有哪些?top客户情况等。可以发现面试官不停的在记录，这就是典型的搜集情报式招聘。很多公司的中低层员工不但没有保护雇主秘密的意识，甚至面试时为讨好面试官反而会和盘托出……&lt;/p&gt;
&lt;h4 id=&#34;3增加&#34;&gt;3，增加&lt;/h4&gt;
&lt;p&gt;面试只透露个人技能，荣誉，反对一切需要父母，学校，朋友，兄弟等信息的收集。保护雇主信息，用不着讨好HR，反正也不录取你。拒绝不问你详细情况，直接开口就面试的公司。&lt;br&gt;
大企业不不会不招，但是招得特别少；校招主要是企业宣传，让你感觉这个企业文化很好，信任他们的产品/服务，培养潜在消费者；社招算是储备简历库&lt;/p&gt;
&lt;h3 id=&#34;因果&#34;&gt;因果&lt;/h3&gt;
&lt;p&gt;公司的人事部细分为很多岗位，每个岗位的考核标准不同。通过打电话让求职者过来面试的，就是招聘专员的主要职责，只负责电话邀约，面试是人事专员或经理负责。如果邀约的面试未完成，那么招聘专员的绩效就有影响，进一步影响工资。因此，招聘专员为了完成自己那部分的KPI就要想尽办法让人过来面试销售岗比较难招到人，如果正常挂出职位，那么对求职者缺乏吸引力，甚至没有人投简历。&lt;br&gt;
因此公司会采用“挂羊头卖狗肉”的方法用其他岗位来吸引求职者面试。面试成功后会告诉求职者挂出的这个岗位不确认，建议求职者考虑销售岗，之后就是一个洗脑的过程。也有可能是面试者能力不行，所以婉拒说“岗位不招人”，这个就需要求职者自己判断了有的公司是利用招聘平台打广告，所以岗位会一直挂着不下架。到这种公司面试之前一定要先自己查明情况，比如通过招聘网站看看发布的日期之类的&lt;/p&gt;
&lt;h3 id=&#34;招聘的评判标准就是一句话说你行你就行不行也行说不行就不行行也不行&#34;&gt;招聘的评判标准就是一句话：“说你行你就行，不行也行！说不行就不行，行也不行。”&lt;/h3&gt;
&lt;p&gt;从应聘者的角度讲：&lt;/p&gt;
&lt;p&gt;1.招聘方对于招聘需求不明晰&lt;br&gt;
很多企业的HR都是拿到了需求部门的招聘需求之后，在网站上搜索相应职位的需求和岗位描述，而不是从需求部门那里了解到来自一线的岗位职责和需求。这样一来就出现了，HR看到合适的简历，可是到了企业面试层面却不符合企业一线的用工需求。&lt;/p&gt;
&lt;p&gt;2.HR对于应聘者的简历要求虚高&lt;br&gt;
很多企业的HR是按照有一说一的工作方式去筛选应聘者简历的。比如需求部门要求会PS、会AE等技术，但是如果应聘者写的是熟练使用Adobe平面、视频软件，就会被过滤掉。当然，如果应聘者写photoshop软件，有很大概率也会被Pass掉。&lt;/p&gt;
&lt;p&gt;3.招聘方打着招聘的旗号干别的事&lt;br&gt;
这一点是从18年以后开始大行其道的。很多企业纷纷打着招聘的旗号，以企业现有的项目问题、管理问题、运营问题等问题作为面试的“测试”，来让应聘者解答。美其名曰检验应聘者的实际能力，其实却是拿应聘当做行业调研或者免费的企业咨询。当然了，更有甚者，拿着应聘者提交上来的面试测试题回复（有的企业是跟应聘者要项目策划案或者某个项目的执行案），直接用在了企业自己的项目上，省去了把业务外包的烦恼。&lt;/p&gt;
&lt;p&gt;4.招聘方对于企业现有状态的保护&lt;br&gt;
这一点就相对比较隐晦了，说白了就是招聘方的人能力不足，面对高能力值的应聘者捉襟见肘。在面试的时候就露出了招聘方人员对于业务的不熟悉或者不了解。无法回答应聘者关于应聘职位的相关问题。对于招聘方来说，这样的“刺儿头”硬茬子肯定不能招啊，如果应聘者进入企业，对于招聘他的人来说就是“自己打造一把随时可能杀死自己的利刃啊！”所谓的死海现象大抵如此了。&lt;/p&gt;
&lt;p&gt;5.招聘方企业对于招聘的岗位规划不足&lt;br&gt;
有些企业，尤其是有些线上或者线下有些成就的企业，在扩展现有业务的时候，比如线下扩展到线上，或者线上落地到线下的时候，对于新的招聘岗位没有相关深入的了解，甚至只是人云亦云的了解了一些皮毛。用半瓶子的水平去面试行业内有相关经验的应聘者，结局可想而知。如果幸运的他们找对了大咖可以入职，因为企业对于业务的不了解，大咖不能按照原有的行业经验进行落实执行，比如申请费用、扩充团队、标定业务方向等，每走一步都要想外行的领导进行汇报申请。这种外行不懂，还要硬指导的情况使得双方都觉得难做。企业觉得应聘者的能力言过其实，应聘者觉得企业在画饼。于是就开始了恶性循环。&lt;/p&gt;
">（经验积累）只面试不招人</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/markdown-xue-xi-bi-ji/"" data-c="
          &lt;p&gt;&lt;strong&gt;一、标题：&lt;/strong&gt;&lt;br&gt;
1、markdown标题用=和-表示一级和二级标题&lt;br&gt;
2、&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;二、段落格式：&lt;/strong&gt;&lt;br&gt;
Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。&lt;br&gt;
字体：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*斜体文本*
_斜体文本_
**粗体文本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;三、分隔线&lt;/strong&gt;&lt;br&gt;
你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;***
* * *
*****
- - -
----------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;四、删除线&lt;/strong&gt;&lt;br&gt;
如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RUNOOB.COM
GOOGLE.COM
~~BAIDU.COM~~
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下划线&lt;/p&gt;
">markdown学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://bingery111.github.io/post/git-xue-xi-bi-ji/"" data-c="
          &lt;p&gt;学习git之前，我们需要先明白一个概念：版本控制！&lt;/p&gt;
&lt;h1 id=&#34;版本控制&#34;&gt;版本控制&lt;/h1&gt;
&lt;p&gt;版本控制：版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现跨区域多人协同开发&lt;/li&gt;
&lt;li&gt;追踪和记载一个或者多个文件的历史记录&lt;/li&gt;
&lt;li&gt;组织和保护你的源代码和文档&lt;/li&gt;
&lt;li&gt;统计工作量&lt;/li&gt;
&lt;li&gt;并行开发、提高开发效率&lt;/li&gt;
&lt;li&gt;跟踪记录整个软件的开发过程&lt;/li&gt;
&lt;li&gt;减轻开发人员的负担，节省时间，同时降低人为错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单说就是用于管理多人协同开发项目的技术。&lt;/p&gt;
&lt;p&gt;没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。&lt;/p&gt;
&lt;p&gt;无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！&lt;br&gt;
多人开发就必须要使用版本控制！&lt;/p&gt;
&lt;h1 id=&#34;常见的版本控制工具&#34;&gt;常见的版本控制工具&lt;/h1&gt;
&lt;p&gt;我们学习的东西，一定是当下最流行的！&lt;/p&gt;
&lt;p&gt;主流的版本控制器有如下这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;li&gt;SVN（Subversion）&lt;/li&gt;
&lt;li&gt;CVS（Concurrent Versions System）&lt;/li&gt;
&lt;li&gt;VSS（Micorosoft Visual SourceSafe）&lt;/li&gt;
&lt;li&gt;TFS（Team Foundation Server）&lt;/li&gt;
&lt;li&gt;Visual Studio Online&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN&lt;/p&gt;
&lt;h1 id=&#34;版本控制分类&#34;&gt;版本控制分类&lt;/h1&gt;
&lt;h2 id=&#34;1-本地版本控制&#34;&gt;1、本地版本控制&lt;/h2&gt;
&lt;p&gt;记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。&lt;/p&gt;
&lt;h2 id=&#34;2-集中版本控制-svn&#34;&gt;2、集中版本控制  SVN&lt;/h2&gt;
&lt;p&gt;所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改&lt;br&gt;
所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS&lt;/p&gt;
&lt;h2 id=&#34;3-分布式版本控制-git&#34;&gt;3、分布式版本控制 	Git&lt;/h2&gt;
&lt;p&gt;每个人都拥有全部的代码！安全隐患！&lt;/p&gt;
&lt;p&gt;所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。&lt;/p&gt;
&lt;p&gt;不会因为服务器损坏或者网络问题，造成不能工作的情况！&lt;/p&gt;
&lt;p&gt;Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！&lt;/p&gt;
&lt;h1 id=&#34;git与svn的主要区别&#34;&gt;Git与SVN的主要区别&lt;/h1&gt;
&lt;p&gt;SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。&lt;br&gt;
Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！&lt;br&gt;
Git是目前世界上最先进的分布式版本控制系统。&lt;/p&gt;
&lt;h1 id=&#34;聊聊git的历史&#34;&gt;聊聊Git的历史&lt;/h1&gt;
&lt;p&gt;同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。&lt;/p&gt;
&lt;p&gt;Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。&lt;/p&gt;
&lt;p&gt;Linux社区中存在很多的大佬！破解研究 BitKeeper ！&lt;/p&gt;
&lt;p&gt;到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！&lt;/p&gt;
&lt;p&gt;Git是目前世界上最先进的分布式版本控制系统。&lt;/p&gt;
&lt;p&gt;Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！&lt;/p&gt;
&lt;h1 id=&#34;常用的linux命令&#34;&gt;常用的Linux命令&lt;/h1&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;cd : 改变目录。&lt;/li&gt;
&lt;li&gt;cd . . 回退到上一个目录，直接cd进入默认目录&lt;/li&gt;
&lt;li&gt;pwd : 显示当前所在的目录路径。&lt;/li&gt;
&lt;li&gt;ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。&lt;/li&gt;
&lt;li&gt;touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。&lt;/li&gt;
&lt;li&gt;rm:  删除一个文件, rm index.js 就会把index.js文件删除。&lt;/li&gt;
&lt;li&gt;mkdir:  新建一个目录,就是新建一个文件夹。&lt;/li&gt;
&lt;li&gt;rm -r :  删除一个文件夹, rm -r src 删除src目录&lt;/li&gt;
&lt;li&gt;rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！&lt;/li&gt;
&lt;li&gt;mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;reset 重新初始化终端/清屏。&lt;/li&gt;
&lt;li&gt;clear 清屏。&lt;/li&gt;
&lt;li&gt;history 查看命令历史。&lt;/li&gt;
&lt;li&gt;help 帮助。&lt;/li&gt;
&lt;li&gt;exit 退出。&lt;/li&gt;
&lt;li&gt;#表示注释&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;git配置&#34;&gt;Git配置&lt;/h1&gt;
&lt;p&gt;所有的配置文件，其实都保存在本地！&lt;br&gt;
查看配置 git config -l&lt;br&gt;
查看不同级别的配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#查看系统config
git config --system --list
　　
#查看当前用户（global）配置
git config --global  --list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Git相关的配置文件：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Git\etc\gitconfig  ：Git 安装目录下的 gitconfig     --system 系统级&lt;/li&gt;
&lt;li&gt;C:\Users\Administrator\ .gitconfig    只适用于当前登录用户的配置  --global 全局&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;设置用户名与邮箱用户标识必要&#34;&gt;设置用户名与邮箱（用户标识，必要）&lt;/h1&gt;
&lt;p&gt;当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name &amp;quot;kuangshen&amp;quot;  #名称
git config --global user.email 24736743@qq.com   #邮箱
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只需要做一次这个设置，如果你传递了--global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要--global选项。总之--global为全局配置，不加为某个项目的特定配置。&lt;/p&gt;
&lt;h1 id=&#34;git基本理论重要&#34;&gt;Git基本理论（重要）&lt;/h1&gt;
&lt;h2 id=&#34;三个区域&#34;&gt;三个区域&lt;/h2&gt;
&lt;p&gt;Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Workspace：工作区，就是你平时存放项目代码的地方&lt;/li&gt;
&lt;li&gt;Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息&lt;/li&gt;
&lt;li&gt;Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本&lt;/li&gt;
&lt;li&gt;Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;本地的三个区域确切的说应该是git仓库中HEAD指向的版本：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;+Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。&lt;br&gt;
+WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。&lt;br&gt;
+.git：存放Git管理信息的目录，初始化仓库的时候自动创建。&lt;br&gt;
+Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。&lt;br&gt;
+Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。&lt;br&gt;
+Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;工作流程&#34;&gt;工作流程&lt;/h2&gt;
&lt;p&gt;git的工作流程一般是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;１、在工作目录中添加、修改文件；&lt;/li&gt;
&lt;li&gt;２、将需要进行版本管理的文件放入暂存区域；&lt;/li&gt;
&lt;li&gt;３、将暂存区域的文件提交到git仓库。&lt;br&gt;
因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;git项目搭建&#34;&gt;Git项目搭建&lt;/h1&gt;
&lt;h2 id=&#34;创建工作目录与常用指令&#34;&gt;创建工作目录与常用指令&lt;/h2&gt;
&lt;p&gt;工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。&lt;/p&gt;
&lt;h2 id=&#34;本地仓库搭建&#34;&gt;本地仓库搭建&lt;/h2&gt;
&lt;p&gt;创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。&lt;br&gt;
1、创建全新的仓库，需要用GIT管理的项目的根目录执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 在当前目录新建一个Git代码库
$ git init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。&lt;/p&gt;
&lt;h2 id=&#34;克隆远程仓库&#34;&gt;克隆远程仓库&lt;/h2&gt;
&lt;p&gt;1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 克隆一个项目和它的整个代码历史(版本信息)
$ git clone [url]  # https://gitee.com/kuangstudy/openclass.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;git文件操作&#34;&gt;Git文件操作&lt;/h1&gt;
&lt;h2 id=&#34;文件的四种状态&#34;&gt;文件的四种状态&lt;/h2&gt;
&lt;p&gt;版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.&lt;/li&gt;
&lt;li&gt;Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件&lt;/li&gt;
&lt;li&gt;Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !&lt;/li&gt;
&lt;li&gt;Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;查看文件状态&#34;&gt;查看文件状态&lt;/h2&gt;
&lt;p&gt;上面说文件有4种状态，通过如下命令可以查看到文件的状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#查看指定文件状态
git status [filename]

#查看所有文件状态
git status

# git add .                  添加所有文件到暂存区
# git commit -m &amp;quot;消息内容&amp;quot;    提交暂存区中的内容到本地仓库 -m 提交信息
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;忽略文件&#34;&gt;忽略文件&lt;/h2&gt;
&lt;p&gt;有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等&lt;br&gt;
在主目录下建立&amp;quot;.gitignore&amp;quot;文件，此文件有如下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;忽略文件中的空行或以井号（#）开始的行将会被忽略。&lt;/li&gt;
&lt;li&gt;可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,...}）代表可选的字符串等。&lt;/li&gt;
&lt;li&gt;如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。&lt;/li&gt;
&lt;li&gt;如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。&lt;/li&gt;
&lt;li&gt;如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;git分支&#34;&gt;GIT分支&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;# 列出所有本地分支
git branch

# 列出所有远程分支
git branch -r

# 新建一个分支，但依然停留在当前分支
git branch [branch-name]

# 新建一个分支，并切换到该分支
git checkout -b [branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
&lt;/code&gt;&lt;/pre&gt;
">git学习笔记</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>






</html>