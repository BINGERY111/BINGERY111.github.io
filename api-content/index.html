{"posts":[{"title":"Linux常用命令","content":" 一.文件管理 1.文件查找：find 2.文件拷贝：cp 3.打包解包：tar 二.文本处理 1.(显示行号)查看文件：nl 2.文本查找：grep 3.排序：sort 4.转换：tr 5.切分文本：cut 6.拼接文本：paste 7.统计：wc 8.数据处理：sed 9.数据处理：awk 三.性能分析 1.进程查询：ps 2.进程监控：top 3.打开文件查询：lsof 4.内存使用量：free 5.shell进程的资源限制：ulimit 四.网络工具 1.网卡配置：ifconfig 2.查看当前网络连接：netstat 3.查看路由表：route 4.检查网络连通性：ping 5.转发路径：traceroute 6.网络Debug分析：nc 7.命令行抓包：tcpdump 8.域名解析工具：dig 9.网络请求：curl 五.开发及调试 1.编辑器：vim 2.编译器：gcc和g++ 3.调试工具：gdb 4.查看依赖库：ldd 5.二进制文件分析：objdump 6.ELF文件格式分析：readelf 7.跟踪进程中系统调用：strace 8.跟踪进程栈：pstack 9.进程内存映射：pmap 六.其他 1.终止进程：kill 2.修改文件权限：chmod 3.创建链接：ln 4.显示文件尾：tail 5.版本控制：git 6.设置别名：alias 一.文件管理 1.文件查找：find 使用方法 find [查找目录] [查找条件] 查找目录： .：在当前目录及子目录下查找（默认） A：在目录A及A的子目录下查找 查找条件： -name：根据文件名查找 -regex：使用正则表达式匹配 -type：按类型查找（f:文件，d:目录，l:链接...） -atime：按访问时间查找（n:n天前的一天内，+n:n天前(不含n天本身)，-n:n天内(不含n天)） -mtime：按修改时间查找（n:n天前的一天内，+n:n天前(不含n天本身)，-n:n天内(不含n天)） -size：按大小查找（单位k，+nk:&quot;比nk更大&quot;，-nk:&quot;比nk更小&quot;） -perm：按权限查找（644：权限等于644的文件） -user/-nouser：用户名等于/用户名不等于 -group/-nogroup：组名等于/组名不等于 示例 #1.在当前目录及子目录下查找后缀为cpp的文件 find . -name *.cpp #2.使用正则表达式查找 find -regex &quot;.*.cpp$&quot; 2.文件拷贝：cp 使用方法 cp [选项] 源路径 目的路径 选项： -a：将所有属性一起复制（包括拥有者、时间等信息） -i：目标文件存在时，进行询问 -r：递归复制 3.打包解包：tar 使用方法 tar [-j|-z] [cv] [-f 压缩包名] 目录 tar [-j|-z] [xv] [-f 解压包名] [-C 解压路径] 选项： -c/-x：打包/解包 -j/-z：bzip2格式/gzip格式 -v：显示过程 二.文本处理 1.(显示行号)查看文件：nl 行号计算不包括空行 2.文本查找：grep 使用方法 grep [选项] 模式串 文件 输出 | grep [选项] 模式串 选项 -e：使用多个模式串 -i：忽略大小写 -n：打印行号 -c：统计次数（一行算一次） 示例 #1.在test.c中搜索包含字符串”printf“或”count“的行 grep -e &quot;printf&quot; -e &quot;count&quot; test.c 3.排序：sort 使用方法 sort [选项] 文件 输出 | sort [选项] 选项 -d：按字典序排序（默认） -n：按数字排序 -k：&quot;-k n&quot;表示按各行第n列进行排序 -r：反序 4.转换：tr 使用方法 #set1、set2为字符集，可以是单个字符，也可以是字符串 输出 | tr [选项] set1 set2 选项： -d：删除字符 -s：字符压缩 示例 #1.删除字符':' cat /etc/passwd | tr -d ':' #2.将小写字母替换成大写字母 last | tr '[a-z]' 'A-Z' #3.将'a'、'b'、'c'替换成'z' cat test | tr “abc” 'z' #4.将连续的'a'压缩成'b'（单个或连续出现的多个‘a’会压缩成一个‘b’） cat test | tr -s 'a' 'b' 5.切分文本：cut 使用方法 cut [选项] 文件 输出 | cut [选项] 选项： -d：分隔符（-d ':' 以’:‘为分隔符） -f：选择域（-f 1,2 输出分隔后第1列和第2列） -c：字符范围（-c n-m 输出第n到m个字符。如果没有m，输出到末尾） 示例 #1.按’:‘分隔$PATH，输出第3个和第5个 echo $PATH | cut -d ':' -f 3,5 #2.输出export运行结果每行的第12-20个字符 export | cut -c 12-20 6.拼接文本：paste 使用方法 paste [选项] file1 file2 选项： -d：指定拼接时使用的分隔符（默认使用tab作为分隔符） 7.统计：wc 使用方法 wc [选项] 文件 输出 | wc [选项] 选项： -c：统计字符数 -w：统计单词数 -l：统计行数 8.数据处理：sed sed常用于一整行的处理。如果有一个100万行的文件，要在第100行加某些文字，此时由于文件太大，不适合用vim处理。因此使用sed是个很好的选择 使用方法 sed [选项] '[动作]' 文件 输入 | sed [选项] '[动作]' 选项： -n：安静模式，只输出sed处理过的行（否则未处理行也会输出） -i：结果直接作用到文件（没指定时不会修改文件） -e：在命令行模式上输入动作 -f：从文件中读取动作 动作：[n1[,n2]] function function: a/i：在后插入/在前插入 d：删除 p：打印 s：替换 示例 #1.插入 nl /etc/passwd | sed '2a drink tea' #在第2行后插入一行：&quot;drink tea&quot; nl /etc/passwd | sed '2a aaa \\ &gt; bbb' #在第2行后插入两行：&quot;aaa&quot;和&quot;bbb&quot; #2.删除 nl /etc/passwd | sed '2,5d' #删除2~5行 sed '/^$/d' ip #将ip文件中的空行删除 #3.打印2~5行（安静模式，不使用安静模式2~5行会打印2次） nl /etc/passwd | sed -n '2,5p' #4.替换 nl /etc/passwd | sed '2s/daemon/root/g' #将第二行的daemon替换成root ifconfig | grep 'inet addr' | sed 's/^.*addr://g' #将所有开头的“inet addr:”删除 9.数据处理：awk 相比于sed常用于一整行的处理，awk则比较倾向于将一行分成数个“字段”来处理。因此，相当适合小型的数据处理 awk处理步骤： 读入第一行，并将第一行的数据填入$0,$1,$2等变量当中 依据条件类型的限制，判断是否需要进行后面的动作 做完所有的动作与条件类型 若还有后续的“行”的数据，则重复1~3步，直到所有的数据都读完为止 使用方法 awk '条件类型1{动作1} 条件类型2{动作2} ...' filename 输出 | awk '条件类型1{动作1} 条件类型2{动作2} ...' 变量： $0：整行 $1：按分隔符分隔后的第1列 $2：按分隔符分隔后的第2列 $k：按分隔符分隔后的第k列 NF：每一行拥有的字段数 NR：目前所处理的行数 FS：目前的分隔字符（默认是空格或tab） 条件判断：&gt;、&lt;、&gt;=、&lt;=、==、!= 命令分隔：使用';'或Enter 示例 #1.打印last -n 5结果中每行经过分隔符(默认情况下为空格或tab)分隔后的第1列和第3列 last -n 5 | awk '{print $1 &quot;\\t&quot; $3}' #2.以':'作为分隔符，打印第3列小于10的所有行的第1列和第3列 cat /etc/passwd | awk '{FS=&quot;:&quot;} $3&lt;10{print $1 &quot;\\t&quot; $3}' #（第一行不会处理） cat /etc/passwd | awk 'BEGIN{FS=&quot;:&quot;} $3&lt;10{print $1 &quot;\\t&quot; $3}' #（第一行会处理） #3.假设test文件由3列数字组成，以空格分隔。该命令会计算每行的和然后打印 awk '{total=$1+$2+$3;printf &quot;%10d %10d %10d %10.2f\\n&quot;,$1,$2,$3,total}' test 注意上面的示例2，awk首先是读取一行，分隔后的数据填入$0,$1,$2等变量中才开始进行条件判断和执行动作。因此第一条命令在按空格或tab分隔后才将分隔符换成':'，所以第一行显示结果不对 三.性能分析 1.进程查询：ps man ps手册非常庞大，不是很好查阅，因此主要记住几个命令 示例 #1.列出仅与自身环境有关的进程，最上层的父进程是允许该ps命令的bash而没有扩展到init进程中去 ps -l #2.列出系统所有进程的信息 ps aux ps -ef #aux会截断COMMAND列，-ef不会。aux是BSD风格，-ef是System V风格 ps axjf #以&quot;进程树&quot;的方式显示所有进程 ps -lA #输出格式同ps -l F：进程标志，说明进程的权限 4：root权限 1：仅能fork而不能exec 0：既非4也非1 S：进程的状态 R(running)：正在运行 S(Sleep)：可被唤醒的睡眠 D：不可被唤醒的睡眠（通常可能在等待I/O） T：停止，可能是在后台暂停 Z(Zombie)：僵尸进程 C：CPU使用率 PRI/NI：Priority/Nice的缩写，CPU优先级(越小越高) ADDR/SZ/WCHAN：内存相关，ADDR指出进程在内存的哪个部分，running进程一般显示'-'。SZ为进程使用的内存。WCHAN表示进程当前是否运行中'-'，当进程睡眠时，指出进程等待的事件 TTY：进程运行的终端机 TIME：进程用掉的CPU时间 USER：进程所属用户 %CPU/%MEM：进程消耗的CPU百分比和内存百分比 VSZ：进程用掉的虚拟内存(KB) RSS：进程占用的固定内存(KB) TTY：进程运行的终端机，与终端机无关则显示'?'。tty1~tty6是本机的登陆者程序，pts/0等表示由网络连接进主机的进程 STAT：进程目前的状态，与ps -l结果中的S等同 START：进程启动的时间 TIME：进程实际使用的CPU运行时间 2.进程监控：top 使用方法 top [选项] 选项： -d：跟秒数指定更新间隔 -n：与-b搭配，指定需要进行几次top输出，重定向时常用 -p：指定PID，监控特定进程 top模式下的命令： ?：显示可用的命令 P：以CPU使用情况排序 M：以内存使用情况排序 N：以PID排序 q：退出 1：多核情况下切换CPU %Cpu(s)后面的“wa”表示I/O wait，过高说明长时间等待I/O，I/O存在瓶颈 3.打开文件查询：lsof 使用方法 lsof [选项] 选项： -i：-i:端口号查看端口被占用的情况 -u：后跟用户名查看具体用户打开的文件 -p：后跟PID查看指定进程打开的文件 +d：后跟目录查看指定目录下被进程打开的文件，&quot;+D&quot;递归 4.内存使用量：free 使用方法 free [选项] 选项： -b|-k|-m|-g：单位 -t：列出物理内存与swap的汇总情况 buffers：主要缓存dentry和inode等元数据 cached：主要缓存文件内容，即page cache - buffers/cache：实际使用的内存。used-buffers-cached + buffers/cache：可用内存。free+buffers+cached（在内存紧张时，buffers和cached可以回收） 详细结果说明 5.shell进程的资源限制：ulimit 使用方法 ulimit [选项] #查看 ulimit [选项] 新值 #修改 选项： -a：列出shell进程的所有资源限制情况（-a命令会列出查看某一资源限制的选项参数） ... 使用ulimit修改资源限制只会对当前终端环境有效，如果想永久生效，可以修改文件/etc/security/limits.conf，该文件的内容如下； # /etc/security/limits.conf # #Each line describes a limit for a user in the form: # #&lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt; # #Where: #&lt;domain&gt; can be: # - a user name # - a group name, with @group syntax # - the wildcard *, for default entry # - the wildcard %, can be also used with %group syntax, # for maxlogin limit # - NOTE: group and wildcard limits are not applied to root. # To apply a limit to the root user, &lt;domain&gt; must be # the literal username root. # #&lt;type&gt; can have the two values: # - &quot;soft&quot; for enforcing the soft limits # - &quot;hard&quot; for enforcing hard limits # #&lt;item&gt; can be one of the following: # - core - limits the core file size (KB) # - data - max data size (KB) # - fsize - maximum filesize (KB) # - memlock - max locked-in-memory address space (KB) # - nofile - max number of open files # - rss - max resident set size (KB) # - stack - max stack size (KB) # - cpu - max CPU time (MIN) # - nproc - max number of processes # - as - address space limit (KB) # - maxlogins - max number of logins for this user # - maxsyslogins - max number of logins on the system # - priority - the priority to run user process with # - locks - max number of file locks the user can hold # - sigpending - max number of pending signals # - msgqueue - max memory used by POSIX message queues (bytes) # - nice - max nice priority allowed to raise to values: [-20, 19] # - rtprio - max realtime priority # - chroot - change root to directory (Debian-specific) # #&lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt; # #* soft core 0 #root hard core 100000 #* hard rss 10000 #@student hard nproc 20 #@faculty soft nproc 20 #@faculty hard nproc 50 #ftp hard nproc 0 #ftp - chroot /ftp #@student - maxlogins 4 # End of file 示例 root@068ca8da6d06:/# ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 7863 max locked memory (kbytes, -l) 82000 max memory size (kbytes, -m) unlimited open files (-n) 1048576 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) unlimited virtual memory (kbytes, -v) unlimited file locks (-x) unlimited 四.网络工具 1.网卡配置：ifconfig 2.查看当前网络连接：netstat netstat [选项] 选项： -a：将所有的连接、监听、Socket数据都列出来（如，默认情况下，不会列出监听状态的连接） -t：列出tcp连接 -u：列出udp连接 -n：将连接的进程服务名称以端口号显示（如下图中Local Address会换成10.0.2.15:22） -l：列出处于监听状态的连接 -p：添加一列，显示网络服务进程的PID（需要root权限） -i：显示网络接口列表，可以配合ifconfig一起分析 -s：打印网络统计数据，包括某个协议下的收发包数量 Active Internet connections（w/o servers）：网络相关的连接 Recv-Q：接收队列(已接收还未递交给应用) Send-Q：发送队列(接收方未确认的数据) Local Address：本地IP(主机):端口(服务名) Foreign Address：远端IP:端口 Recv-Q和Send-Q通常应该为0，如果长时间不为0可能存在问题 Active UNIX domain sockets（w/o servers）：本地相关的套接字 RefCnt：连接到此socket的进程数 Flags：连接标识 Type：socket访问的类型 Path：连接到此socket的相关程序的路径 netstat的10个基本用法 3.查看路由表：route 4.检查网络连通性：ping 5.转发路径：traceroute 6.网络Debug分析：nc 7.命令行抓包：tcpdump 使用方法 sudo tcpdump [选项] ... 选项： -D/-i：查看/指定网卡 示例 #抓取本地9877号端口的TCP数据包 sudo tcpdump -i lo tcp port 9877 下图为tcp回射服务器，客户端分别键入&quot;hello&quot;和“world”时，使用tcpdump抓取到的数据包 8.域名解析工具：dig 9.网络请求：curl 五.开发及调试 1.编辑器：vim 2.编译器：gcc和g++ C程序的编译过程 使用方法 gcc/g++ [选项] 源文件 选项： -E：让编译器在预处理之后停止，不进行后续编译过程，得到.i文件 -S：让编译器在编译之后停止 ，不进行后续过程，得到.s文件 -c：生成机器码即二进制.o文件 -o：指定目标文件名 -g：在编译的时候生成调试信息 -Wall：生成所有警告信息 -I 目录：指定头文件的查找目录 生成动态链接库： 1. gcc/g++ -c -fPIC 源文件 -o 目标文件名 2. gcc -shared 目标文件名 -o 动态链接库名.so 生成静态链接库： 1. gcc/g++ -c 源文件 -o 目标文件名 2. ar -crv 静态链接库名.a 目标文件名 -l库名 -L 目录：引入链接库，-L指定查找该库的目录。如-lm表示引入libm.so 3.调试工具：gdb 使用方法 #第一步：得到可执行文件 gcc/g++ -o 可执行文件 -g 源文件 #第二步：启动gdb gdb #启动gdb #第三步：执行gdb命令进行调试 (gdb) gdb命令 gdb命令： file 可执行文件：导入需要调试的文件 r：运行程序 q：退出gdb b：设置断点 b 行号 b 函数名称 b *函数名 b *代码地址 b 编号 c：继续执行，直到下一断点或程序结束 s：执行一行代码，如果此行代码有函数调用则进入函数 n：执行一行代码，如果此行代码有函数调用，不进入函数，直接执行函数 i(info) 子命令：查看某些信息（只输入info或i可以查看有哪些子命令） info thread：查看进程的所有线程，会显示每个线程的序号（1~n） thread 线程序号：切换到相应的线程（线程序号可以由info thread得到） f(frame) 函数栈帧号：切换到相应的函数栈帧（函数栈帧号可以由where等命令得到） list：查看源码 list 行号：查看指定行号附近的源码 list 函数：查看指定函数附近的源码 list 文件:行号：查看指定文件中指定行附近的代码 where：查看当前位置 p(print) /格式 表达式 格式： x：按十六进制格式显示变量 d：按十进制格式显示变量 u：按十六进制格式显示无符号整形 o：按八进制格式显示变量 t：按二进制格式显示变量 a：按十六进制格式显示变量 c：按字符格式显示变量 f：按浮点数格式显示变量 表达式中可用的操作符： @：一个和数组有关的操作符，左边是起始地址，右边是长度（p *arr@3） ::：指定一个在文件或是函数中的变量（p 'f2.c'::x） {&lt;type&gt;}&lt;addr&gt;：一个指向内存&lt;addr&gt;的类型为type的一个对象 x(examine) &lt;n/f/u&gt; &lt;addr&gt;：查看内存 n：正整数，表示需要显示的内存单元个数 f：显示的格式（格式字母同上面的print） u：每个单元的字节数 b：1字节 h：2字节 w：4字节（默认） g：8字节 4.查看依赖库：ldd 5.二进制文件分析：objdump 6.ELF文件格式分析：readelf 7.跟踪进程中系统调用：strace 8.跟踪进程栈：pstack 9.进程内存映射：pmap 六.其他 1.终止进程：kill 2.修改文件权限：chmod w权限不具有删除文件的能力 目录的x权限表示能否进入目录 使用方法 chmod [选项] [u|g|o|a][+|-][r|w|x] 文件或目录 chmod [选项] 权限的数字表示 文件或目录 选项： -R：递归式的修改 3.创建链接：ln 4.显示文件尾：tail 5.版本控制：git 6.设置别名：alias ","link":"https://bingery111.github.io/post/linux-chang-yong-ming-ling/"},{"title":"只面试不招人","content":"1、面试地点诡异的 一般的正规公司，不是写字楼就是在商业场所，除去近几年新兴的创业园，工作室确实会在商住一体，或是居民楼内，大部分还是会有相对正规的，商业办公地址。写着面试地点比较偏僻，或者是某酒店的，建议查询下其工商注册信息，不符的，不建议贸然尝试。 如果真的要去，可以在楼下和保安打个招呼，提前询问几零几是否是XX公司，自己约了去面试，如果半小时没有下来，请对方上门查看，甚至有紧急情况，代为报警。 2、面试场所诡异的 面试地点没有异常，如约而至，坐在办公场所。那么一般会被安置在会议室或者接待区，在等待的时候请别闲着，可以环顾四周，看看是否有和异常，前台的状态，员工的状态，出现大量的空置，那么多半是有问题的，除了初创阶段，正常的公司不可能大量的空置。如果员工状态懒散，那么多半是公司制度不完善，效益不好，甚至是有不良的劳动用工，恶意欠薪的隐患。这种情况，也不建议继续面试下去。 3、面试邀约诡异的 非正常工作时段打电话邀约的，邀约的时候语气特别殷切的，需要特别注意。非上班时间还在电话邀约，那么至少说明在加班，经常加班。语气特别殷切，说明招人难，为什么招人难？大多是公司不咋地。 4、要收取费用的 如果是在网上投递简历，通知你面试，然后在面试过程中交押金培训费等各种费用时，这些可能都是骗人的。如果到人才市场去找工作，也要找正规的人才市场，就比如：深圳兴达人才市场就是正规的，应聘者可以到兴达人才市场找工作。 5、一次性招聘很多人 如果一个公司招聘很多人，从高层到底层，除非这家公司是新建的公司，否则就是骗人的。求职者们在找工作时一定要注意不要被虚假的招聘信息给欺骗了，一定要到正规的网站投递简历，或者是到正规的人才市场找工作。 ","link":"https://bingery111.github.io/post/zhi-mian-shi-bu-zhao-ren/"},{"title":"markdown学习笔记","content":"一、标题： 1、markdown标题用=和-表示一级和二级标题 2、 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 二、段落格式： Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 字体： *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 三、分隔线 你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： *** * * * ***** - - - ---------- 四、删除线 如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下： RUNOOB.COM GOOGLE.COM ~~BAIDU.COM~~ 下划线 ","link":"https://bingery111.github.io/post/markdown-xue-xi-bi-ji/"},{"title":"git学习笔记","content":"学习git之前，我们需要先明白一个概念：版本控制！ 版本控制 版本控制：版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。 实现跨区域多人协同开发 追踪和记载一个或者多个文件的历史记录 组织和保护你的源代码和文档 统计工作量 并行开发、提高开发效率 跟踪记录整个软件的开发过程 减轻开发人员的负担，节省时间，同时降低人为错误 简单说就是用于管理多人协同开发项目的技术。 没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。 无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！ 多人开发就必须要使用版本控制！ 常见的版本控制工具 我们学习的东西，一定是当下最流行的！ 主流的版本控制器有如下这些： Git SVN（Subversion） CVS（Concurrent Versions System） VSS（Micorosoft Visual SourceSafe） TFS（Team Foundation Server） Visual Studio Online 版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN 版本控制分类 1、本地版本控制 记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。 2、集中版本控制 SVN 所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改 所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS 3、分布式版本控制 Git 每个人都拥有全部的代码！安全隐患！ 所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。 不会因为服务器损坏或者网络问题，造成不能工作的情况！ Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！ Git与SVN的主要区别 SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。 Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！ Git是目前世界上最先进的分布式版本控制系统。 聊聊Git的历史 同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。 Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。 Linux社区中存在很多的大佬！破解研究 BitKeeper ！ 到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！ Git是目前世界上最先进的分布式版本控制系统。 Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！ 常用的Linux命令 cd : 改变目录。 cd . . 回退到上一个目录，直接cd进入默认目录 pwd : 显示当前所在的目录路径。 ls(ll): 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。 touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。 rm: 删除一个文件, rm index.js 就会把index.js文件删除。 mkdir: 新建一个目录,就是新建一个文件夹。 rm -r : 删除一个文件夹, rm -r src 删除src目录 rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！ mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。 reset 重新初始化终端/清屏。 clear 清屏。 history 查看命令历史。 help 帮助。 exit 退出。 #表示注释 Git配置 所有的配置文件，其实都保存在本地！ 查看配置 git config -l 查看不同级别的配置文件： #查看系统config git config --system --list #查看当前用户（global）配置 git config --global --list Git相关的配置文件： Git\\etc\\gitconfig ：Git 安装目录下的 gitconfig --system 系统级 C:\\Users\\Administrator\\ .gitconfig 只适用于当前登录用户的配置 --global 全局 设置用户名与邮箱（用户标识，必要） 当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中： git config --global user.name &quot;kuangshen&quot; #名称 git config --global user.email 24736743@qq.com #邮箱 只需要做一次这个设置，如果你传递了--global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要--global选项。总之--global为全局配置，不加为某个项目的特定配置。 Git基本理论（重要） 三个区域 Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。 Workspace：工作区，就是你平时存放项目代码的地方 Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 本地的三个区域确切的说应该是git仓库中HEAD指向的版本： +Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。 +WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。 +.git：存放Git管理信息的目录，初始化仓库的时候自动创建。 +Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。 +Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。 +Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。 工作流程 git的工作流程一般是这样的： １、在工作目录中添加、修改文件； ２、将需要进行版本管理的文件放入暂存区域； ３、将暂存区域的文件提交到git仓库。 因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed) Git项目搭建 创建工作目录与常用指令 工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。 本地仓库搭建 创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。 1、创建全新的仓库，需要用GIT管理的项目的根目录执行： # 在当前目录新建一个Git代码库 $ git init 2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。 克隆远程仓库 1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！ # 克隆一个项目和它的整个代码历史(版本信息) $ git clone [url] # https://gitee.com/kuangstudy/openclass.git Git文件操作 文件的四种状态 版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 ! Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified 查看文件状态 上面说文件有4种状态，通过如下命令可以查看到文件的状态： #查看指定文件状态 git status [filename] #查看所有文件状态 git status # git add . 添加所有文件到暂存区 # git commit -m &quot;消息内容&quot; 提交暂存区中的内容到本地仓库 -m 提交信息 忽略文件 有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立&quot;.gitignore&quot;文件，此文件有如下规则： 忽略文件中的空行或以井号（#）开始的行将会被忽略。 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,...}）代表可选的字符串等。 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 GIT分支 # 列出所有本地分支 git branch # 列出所有远程分支 git branch -r # 新建一个分支，但依然停留在当前分支 git branch [branch-name] # 新建一个分支，并切换到该分支 git checkout -b [branch] # 合并指定分支到当前分支 $ git merge [branch] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] ","link":"https://bingery111.github.io/post/git-xue-xi-bi-ji/"}]}